<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>buuCTF-reverse（三）</title>
      <link href="/2022/08/07/buuCTF-reverse%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2022/08/07/buuCTF-reverse%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="flareon4login"><a class="markdownIt-Anchor" href="#flareon4login">#</a> [FlareOn4]login</h3><p> 这道题给了一个 html 网页，网页打开就是让你输入一段字符串，和平常我们做的逆向题没有什么区别，只不过我们不需要用 IDA 打开，只需要查看源代码就行。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220804095051.png" alt=""><br> 我也是看了别人的 wp 才知道这是个 rot13 加密，直接网上找个网站就能解开，但是我已经把 py 解密脚本给写出来了，难受，写了挺久才知道原来这么简单，不过不用担心，写出来肯定也是收获满满。<br> 照常分析一下代码，在我不知道 rot13 的情况下。首先，给定了一个范围：a-z/A-Z；然后就是加密部分，先把字符与 Z 比较，小于等于赋值 90，大于赋值 122；然后把原字符加上 13，这个再和前面的赋值进行比较，如果赋值大于原字符串加 13，则返回原字符串加 13，否则返回原字符串加 13-26。简单的说就是原字符串满足条件加 13，不满足条件减 13。<br> 脚本如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test = <span class="string">&quot;PyvragFvqrYbtvafNerRnfl@syner-ba.pbz&quot;</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line">list1 = <span class="built_in">list</span>(test)</span><br><span class="line">length = <span class="built_in">len</span>(test)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">65</span>,<span class="number">122</span>):</span><br><span class="line">        <span class="keyword">if</span> j &lt;= <span class="number">90</span>:</span><br><span class="line">            sum1 = <span class="number">90</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sum1= <span class="number">122</span></span><br><span class="line">        <span class="keyword">if</span> sum1 &gt;= j + <span class="number">13</span>:</span><br><span class="line">            sum1 = j + <span class="number">13</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sum1 = j - <span class="number">26</span> + <span class="number">13</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">chr</span>(sum1) == test[i]:</span><br><span class="line">            list1[i] = <span class="built_in">chr</span>(j)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;flag&#123;&quot;</span>,end = <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">    <span class="built_in">print</span>(i,end = <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#125;&quot;</span>,end = <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p> 总的来说，这道题换汤不换药，而且特别简单，写脚本也很简单，当然对我来说就是难办了。</p><h3 id="2019红帽杯easyre"><a class="markdownIt-Anchor" href="#2019红帽杯easyre">#</a> [2019 红帽杯] easyRE</h3><p> 题目给了一个 elf 文件，64 位直接用 IDA 打开查看伪代码。<br> 这道题分为好几个部分，看似代码都挺好理解（当然我看了好久，对我来说很难），但是却有几个坑，因为我见识少，所以这也是我遇到的第一个有坑的题。<br> 正常的分析代码可以发现，主函数有两块加密，第一个就比较简单。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220804185818.png" alt=""><br> 首先是 v15，v16，v17 三段字符串合起来，我们输入的字符串 v18 进行简单的异或加密，再与前面的合并字符串进行对比，相同就输出 continue。我们可以吧这段合并字符串写个脚本逆出来。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220804190137.png" alt=""><br> 翻译一下就是：前四个字符是 “flag”，根据后面的做题来看只能这么翻译（也可能是我英语不好)。这段当然不是 flag，只是一个提示。<br> 我们再看第二段加密，也就是 base64 编码。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220804190407.png" alt=""><br> 这段代码很简单，sub_400E44（) 就是 base64 编码函数，当然你也可以 shift+f12 看到 base64 编码表。那么就很好理解了，输入的字符串 v21base64 编码十次，最后的结果与 off_6CC090 比较，相同就输出 you found me！！！off_6CC090 点开后是一段很长的 base 码。我们可以写一个脚本解码十次。py 脚本如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">str1 = <span class="built_in">input</span>(<span class="string">&quot;请输入你的解码字符串：&quot;</span>)</span><br><span class="line">sum1 = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你的解码次数：&quot;</span>))</span><br><span class="line">str2 = base64.b64decode(str1.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(sum1-<span class="number">1</span>):</span><br><span class="line">    str2 = base64.b64decode(str2.decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(str2,<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><p> 这个脚本可以指定解码次数，比用网站方便，也不容易出错。<br> 最后解出来是一个网址：<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220804191435.png" alt=""><br><a href="https://bbs.pediy.com/thread-254172.htm">https://bbs.pediy.com/thread-254172.htm</a><br> 这个网址就相当于那啥：“哈哈，你被骗了”。就是这种感觉，评论区也有好心网友给出答案，但这肯定不是正确的解法。<br> 前面的那个 off_6CC090 点开后下面还隐藏一段字符。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220804191804.png" alt=""><br> 点开那个函数：<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220804191850.png" alt=""><br> 发现这里还有一段加密，这里才是核心代码。这段解密的意思就是隐藏的字符串与四个不知道的字符进行异或，得到的就是 flag，但是这四个字符不知道啊，还记得前面的提示么，前四个字符是 “flag”，也就是说 flag 前四个字符是 “flag”，我们可以进行爆破，把未知字符爆破出来。写个脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;Iodl&gt;Qnb(ocy y.i d`3w&#125;wek9&#123;iy=~yL@EC&quot;</span></span><br><span class="line">str2 = [<span class="number">0x40</span>, <span class="number">0x35</span>, <span class="number">0x20</span>, <span class="number">0x56</span>, <span class="number">0x5D</span>, <span class="number">0x18</span>, <span class="number">0x22</span>, <span class="number">0x45</span>, <span class="number">0x17</span>, <span class="number">0x2F</span>, </span><br><span class="line">  <span class="number">0x24</span>, <span class="number">0x6E</span>, <span class="number">0x62</span>, <span class="number">0x3C</span>, <span class="number">0x27</span>, <span class="number">0x54</span>, <span class="number">0x48</span>, <span class="number">0x6C</span>, <span class="number">0x24</span>, <span class="number">0x6E</span>, </span><br><span class="line">  <span class="number">0x72</span>, <span class="number">0x3C</span>, <span class="number">0x32</span>, <span class="number">0x45</span>, <span class="number">0x5B</span>]</span><br><span class="line">str3 = <span class="string">&quot;flag&quot;</span></span><br><span class="line">str4 = <span class="string">&quot;&quot;</span></span><br><span class="line">flag1 = <span class="string">&quot;&quot;</span></span><br><span class="line">flag2 = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">length = <span class="built_in">len</span>(str1)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">127</span>):</span><br><span class="line">        <span class="keyword">if</span> j ^ i == <span class="built_in">ord</span>(str1[i]):</span><br><span class="line">            flag1 += <span class="built_in">chr</span>(j)</span><br><span class="line"><span class="built_in">print</span>(flag1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">127</span>):</span><br><span class="line">        <span class="keyword">if</span> b ^ <span class="built_in">int</span>(str2[a]) == <span class="built_in">ord</span>(str3[a]):</span><br><span class="line">            str4 += <span class="built_in">chr</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;四个字符：&quot;</span>,str4)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(str2)):</span><br><span class="line">    flag2 += <span class="built_in">chr</span>(<span class="built_in">int</span>(str2[c]) ^ <span class="built_in">ord</span>(str4[c%<span class="number">4</span>]))</span><br><span class="line"><span class="built_in">print</span>(flag2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 这个脚本包括前面提示的解密，以及四个字符的爆破和 flag。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220804192516.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;Act1ve_Defen5e_Test&#125;</span><br></pre></td></tr></table></figure><h3 id="findit"><a class="markdownIt-Anchor" href="#findit">#</a> findit</h3><p> 题目给的是 apk 文件，用 jeb 打开，tab 查看 java 伪代码。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void onCreate(Bundle arg8) &#123;</span><br><span class="line">        super.onCreate(arg8);</span><br><span class="line">        this.setContentView(0x7F030018);</span><br><span class="line">        this.findViewById(0x7F05003D).setOnClickListener(new View$OnClickListener(new char[]&#123;&#x27;T&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;s&#x27;, &#x27;I&#x27;, &#x27;s&#x27;, &#x27;T&#x27;, &#x27;h&#x27;, &#x27;e&#x27;, &#x27;F&#x27;, &#x27;l&#x27;, &#x27;a&#x27;, &#x27;g&#x27;, &#x27;H&#x27;, &#x27;o&#x27;, &#x27;m&#x27;, &#x27;e&#x27;&#125;, this.findViewById(0x7F05003E), new char[]&#123;&#x27;p&#x27;, &#x27;v&#x27;, &#x27;k&#x27;, &#x27;q&#x27;, &#x27;&#123;&#x27;, &#x27;m&#x27;, &#x27;1&#x27;, &#x27;6&#x27;, &#x27;4&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;5&#x27;, &#x27;2&#x27;, &#x27;6&#x27;, &#x27;2&#x27;, &#x27;0&#x27;, &#x27;3&#x27;, &#x27;3&#x27;, &#x27;l&#x27;, &#x27;4&#x27;, &#x27;m&#x27;, &#x27;4&#x27;, &#x27;9&#x27;, &#x27;l&#x27;, &#x27;n&#x27;, &#x27;p&#x27;, &#x27;7&#x27;, &#x27;p&#x27;, &#x27;9&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;k&#x27;, &#x27;2&#x27;, &#x27;8&#x27;, &#x27;k&#x27;, &#x27;7&#x27;, &#x27;5&#x27;, &#x27;&#125;&#x27;&#125;, this.findViewById(0x7F05003F)) &#123;</span><br><span class="line">            public void onClick(View arg13) &#123;</span><br></pre></td></tr></table></figure><p> 发现这一长串字符串，pvkq {m164675262033l4m49lnp7p9mnk28k75}<br> 有点像凯撒解密，不确定，试一下结果就出来了。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220804233149.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;c164675262033b4c49bdf7f9cda28a75&#125;</span><br></pre></td></tr></table></figure><p> 当然也可以写脚本直接解出来，我没写所以就不放了（java 没好好学，实在看不懂）。</p><h3 id="suctf2019signin"><a class="markdownIt-Anchor" href="#suctf2019signin">#</a> [SUCTF2019]SignIn</h3><p> 程序无壳，直接拖到 IDA 中查看伪代码。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220806153131.png" alt=""><br> 看到 65537 我就立马想到这是 RSA 加密，因为之前做过类似的题，都是老套路了。那么就简单了，代码中给出了 e，n，c。而我们的目的是求出明文 m，明文 m 就是我们输入的东西，也就是 flag。<br> 接下来就是写脚本去解密，我找的是网上别人的脚本。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Decrypt</span>(<span class="params">c,e,p,q</span>):</span></span><br><span class="line">L=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d=gmpy2.invert(e,L)</span><br><span class="line">n=p*q</span><br><span class="line">m=gmpy2.powmod(c,d,n)</span><br><span class="line">flag=<span class="built_in">str</span>(m)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;flag&#123;&quot;</span>+flag+<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(binascii.unhexlify(<span class="built_in">hex</span>(m)[<span class="number">2</span>:]).decode(encoding=<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">p =  <span class="number">282164587459512124844245113950593348271</span></span><br><span class="line">q =  <span class="number">366669102002966856876605669837014229419</span></span><br><span class="line">e =  <span class="number">65537</span></span><br><span class="line">c =  <span class="number">0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35</span></span><br><span class="line">Decrypt(c,e,p,q)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 下面是输出：<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220806153718.png" alt=""><br> buu 的题，答案包上 flag 提交</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;Pwn_@_hundred_years&#125;</span><br></pre></td></tr></table></figure><h3 id="mrctf2020transform"><a class="markdownIt-Anchor" href="#mrctf2020transform">#</a> [MRCTF2020]Transform</h3><p> 程序是 64 位，无壳，直接拖到 IDA 中查看伪代码。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220806215254.png" alt=""><br> 程序只有一个简单的加密，其实并不难，写出叫本就可以了。程序加密的原理是第一个 for 循环中，先进行一次替换，然后进行一次异或运算。<br> dword_40F040 和 byte_40F0E0 中给出有数据，用 shift+E 进行提取。在提取的时候一定要注意是否漏掉数据，不知道什么原因，我这个提取有时候就会漏掉一些数据，很奇怪，所以提取过后对照一下，不然怎么出错的都不知道。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220806215844.png" alt=""><br> 提取完数据之后，我们就开始写脚本。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = [<span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">7</span>, <span class="number">24</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">16</span>, <span class="number">3</span>, <span class="number">17</span>, <span class="number">32</span>, <span class="number">29</span>, <span class="number">11</span>,<span class="number">30</span>, <span class="number">27</span>, <span class="number">22</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">2</span>, <span class="number">25</span>, <span class="number">5</span>, <span class="number">31</span>, <span class="number">8</span>, <span class="number">18</span>,<span class="number">26</span>, <span class="number">28</span>, <span class="number">14</span>, <span class="number">0</span>]</span><br><span class="line">str2 = [<span class="number">103</span>, <span class="number">121</span>, <span class="number">123</span>, <span class="number">127</span>, <span class="number">117</span>, <span class="number">43</span>, <span class="number">60</span>, <span class="number">82</span>, <span class="number">83</span>, <span class="number">121</span>, <span class="number">87</span>, <span class="number">94</span>,<span class="number">93</span>, <span class="number">66</span>, <span class="number">123</span>, <span class="number">45</span>, <span class="number">42</span>, <span class="number">102</span>, <span class="number">66</span>, <span class="number">126</span>, <span class="number">76</span>, <span class="number">87</span>, <span class="number">121</span>, <span class="number">65</span>,<span class="number">107</span>, <span class="number">126</span>, <span class="number">101</span>, <span class="number">60</span>, <span class="number">92</span>, <span class="number">69</span>, <span class="number">111</span>, <span class="number">98</span>, <span class="number">77</span>,<span class="number">63</span>]</span><br><span class="line">flag = [<span class="number">0</span>]*<span class="number">33</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">33</span>):</span><br><span class="line">    str2[i] = str2[i] ^ str1[i]</span><br><span class="line">    flag[str1[i]] = str2[i]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(i),end = <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220806220027.png" alt=""><br> 因为是 buu 的题。答案包上 flag 后提交。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;Tr4nsp0sltiON_Clph3r_1s_3z&#125;</span><br></pre></td></tr></table></figure><h3 id="actf新生赛2020usualcrypt"><a class="markdownIt-Anchor" href="#actf新生赛2020usualcrypt">#</a> [ACTF 新生赛 2020] usualCrypt</h3><p> 题目 32 位无壳，直接用 IDA 打开。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220806220924.png" alt=""><br> 程序可以运行，运行一下试试。然后分析伪代码。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220807163530.png" alt=""><br> 这是程序的主函数。程序的大致思路是，输入 v8，v8 加密后放入 v5 中，然后 v5 和 byte_40E0E4 中的字符串进行比较，如果相同，那么输入的 v8 就是正确的 flag，然后 sub1080 是主要的加密函数，我们主要分析一下这个加密函数。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220807163931.png" alt=""><br> 这个函数一眼就能看出是 base64 加密，但是这个不是正常的加密，首先 sub_401000 () 函数的作用是将正常的 base64 编码表进行换表。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220807164115.png" alt=""><br> 其次就是结尾的大小写替换，也就是下图的 sub_401030（）函数，他的作用是对 v8 进行换表 base64 加密后的字符串进行大小写替换，所有大写字母替换成小写，所有小写字母替换成大写。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220807164201.png" alt=""><br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220807164350.png" alt=""><br> 那么我们要做的就是将 base64 换表得出来，然后再将 byte_40E0E4 中的字符串进行大小写替换后再进行 base64 换表解码。下图是 byte_40E0E4 和 base64 换表前的编码表。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220807164648.png" alt=""><br> 提取字符串的时候一定不要漏掉数据。下面写脚本。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;zMXHz3TIgnxLxJhFAdtZn2fFk3lYCrtPC2l9&quot;</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line">flag = <span class="built_in">list</span>(str1)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(str1)):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">ord</span>(str1[i]) &gt;= <span class="number">65</span> <span class="keyword">and</span> <span class="built_in">ord</span>(str1[i]) &lt;= <span class="number">90</span>:</span><br><span class="line">        flag[i] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(str1[i]) + <span class="number">32</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">ord</span>(str1[i]) &gt;= <span class="number">97</span> <span class="keyword">and</span> <span class="built_in">ord</span>(str1[i]) &lt;= <span class="number">122</span>:</span><br><span class="line">        flag[i] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(str1[i]) - <span class="number">32</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    <span class="built_in">print</span>(i,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><p> 这是大小写替换脚本，得出的字符串是：ZmxhZ3tiGNXlXjHfaDTzN2FfK3LycRTpc2L9。替换过后的 base64 编码表是：ABCDEFQRSTUVWXYPGHIJKLMNOZabcdefghijklmnopqrstuvwxyz0123456789+/<br> 推荐使用这个网站进行换表解码：<a href="https://icyberchef.com/">CyberChef (icyberchef.com)</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;bAse64_h2s_a_Surprise&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 逆向 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buuCTF-reverse题解（二）</title>
      <link href="/2022/07/29/buuCTF-re%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/07/29/buuCTF-re%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="rsa"><a class="markdownIt-Anchor" href="#rsa">#</a> RSA</h3><p> 这是一道和 RSA 有关的逆向题，但是做起来有点像密码题。<br> 首先是要理解 RSA 加密解密的原理，然后做这道题才能理解的透彻。<br> 具体讲解可以看这篇文章：<a href="https://blog.csdn.net/dbs1215/article/details/48953589">(3 条消息) 带你彻底理解 RSA 算法原理_小宝一号的博客 - CSDN 博客_rsa 算法</a><br> 题目给了两个附件，一个是公钥，一个是 flag 文件。<br> 首先用这个网站将公钥文件的公钥解析出来：<a href="http://tool.chacuo.net/cryptrsakeyparse">RSA 公私钥分解 Exponent、Modulus，Rsa 公私钥指数、系数 (模数) 分解–查错网 (chacuo.net)</a><br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220729132033.png" alt=""><br> 这样就已经知道了 n 和 e。然后就可以根据 n 算出 p 和 q，根据 n 算出 p 和 q 的网站在这里：<a href="http://www.factordb.com/index.php?">factordb.com</a>，需要注意 n 要转化成 10 进制。进制转换可以用 这个网站：<a href="http://www.hiencode.com/jinzhi.html">CTF 在线工具 - ASCII 与进制转换 | 任意进制转换 | ASCII、2 进制、8 进制、10 进制、16 进制 (hiencode.com)</a><br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220729133322.png" alt=""><br> 知道 n、e、p、q 就可以写脚本去解密了，因为我写脚本的能力不足，所以找的是别人的脚本。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> rsa</span><br><span class="line"></span><br><span class="line">p = <span class="number">285960468890451637935629440372639283459</span></span><br><span class="line">q = <span class="number">304008741604601924494328155975272418463</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">n = <span class="number">86934482296048119190666062003494800588905656017203025617216654058378322103517</span></span><br><span class="line"></span><br><span class="line">d = gmpy2.invert(e,(q-<span class="number">1</span>)*(p-<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line">key = rsa.PrivateKey(n,e,d,p,q)</span><br><span class="line"><span class="built_in">print</span>(key)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;/home/mz/桌面/flag.enc&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="built_in">print</span>(rsa.decrypt(f.read(),key).decode())</span><br></pre></td></tr></table></figure><p> 这类脚本可能需要下载某些 python 库，所以可以去自行搜索。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;decrypt_256&#125;</span><br></pre></td></tr></table></figure><h3 id="re1"><a class="markdownIt-Anchor" href="#re1">#</a> re1</h3><p> 这是学长给我们的一道题，具体来源我不知道，需要自取：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1ppcHnafAD0_zO723T2VF1Q </span><br><span class="line">提取码：wish</span><br></pre></td></tr></table></figure><p> 无壳且 64 位，所以直接用 IDA 打开。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_BOOL8 __fastcall sub_1400451A0(__int64 flag, __int64 a2, __int64 a3)</span><br><span class="line">&#123;</span><br><span class="line">  char *v3; // rdi</span><br><span class="line">  __int64 i; // rcx</span><br><span class="line">  char v6; // [rsp+20h] [rbp+0h] BYREF</span><br><span class="line">  char Str1[<span class="number">64</span>]; // [rsp+28h] [rbp+8h] BYREF</span><br><span class="line">  char Str2[<span class="number">60</span>]; // [rsp+68h] [rbp+48h] BYREF</span><br><span class="line">  <span class="built_in">int</span> j; // [rsp+A4h] [rbp+84h]</span><br><span class="line">  <span class="built_in">int</span> v10; // [rsp+C4h] [rbp+A4h]</span><br><span class="line">  __int64 v11; // [rsp+1A8h] [rbp+188h]</span><br><span class="line"></span><br><span class="line">  v3 = &amp;v6;</span><br><span class="line">  <span class="keyword">for</span> ( i = 56i64; i; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)v3 = -<span class="number">858993460</span>;</span><br><span class="line">    v3 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  j___CheckForDebuggerJustMyCode((__int64)&amp;unk_1400E9007, a2, a3);</span><br><span class="line">  strcpy(Str1, <span class="string">&quot;dmcfyb31c43143:c74`d07d`70`2ggfgc748d|&quot;</span>);</span><br><span class="line">  memset(&amp;Str1[<span class="number">39</span>], <span class="number">0</span>, sizeof(char));</span><br><span class="line">  memset(Str2, <span class="number">0</span>, <span class="number">40</span>);</span><br><span class="line">  v10 = j_strlen(Str1);</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; v10; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( j % <span class="number">2</span> )</span><br><span class="line">      Str2[j] = *(_BYTE *)(flag + j) ^ <span class="number">1</span>;       // 奇数</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      Str2[j] = *(_BYTE *)(flag + j) ^ <span class="number">2</span>;       // 偶数</span><br><span class="line">  &#125;</span><br><span class="line">  v11 = j;</span><br><span class="line">  <span class="keyword">if</span> ( (unsigned __int64)j &gt;= <span class="number">0x28</span> )</span><br><span class="line">    j___report_rangecheckfailure();</span><br><span class="line">  Str2[v11] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> j_strcmp(Str1, Str2) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 上面这一段是主要函数，大致思路就是给出一段字符串 str1，然后你输入一段字符串，在 for 循环那里进行加密，奇数位的字符串和 1 异或，偶数位的字符串和 2 异或，最后得到的加密字符串和 str1 相等，那么就正确，你输入的字符串就是 flag。<br> 接下来写 python 脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;dmcfyb31c43143:c74`d07d`70`2ggfgc748d|&quot;</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">length = <span class="built_in">len</span>(str1)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,length):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">127</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">ord</span>(str1[i]) == j ^ <span class="number">1</span> <span class="keyword">and</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            flag += <span class="built_in">chr</span>(j)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">ord</span>(str1[i]) == j ^ <span class="number">2</span> <span class="keyword">and</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            flag += <span class="built_in">chr</span>(j)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;c10a510628b55be26fa51b3efdfa669f&#125;</span><br></pre></td></tr></table></figure><h3 id="wustctf2020level2"><a class="markdownIt-Anchor" href="#wustctf2020level2">#</a> [WUSTCTF2020]level2</h3><p> 题目所给附件有 UPX 壳，首先进行脱壳。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220730142501.png" alt=""><br> 脱完壳之后，直接拖到 IDA32 位，查看代码。<br> 这道题的难度属实超出我的想象，看着代码很多，实际上 flag 直接就给出来了。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220730142827.png" alt=""><br> 实在是没想到啊，就是这么简单。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;Just_upx_-d&#125;</span><br></pre></td></tr></table></figure><p>总结：（1）题目所给文件如果是没有后缀的，也可以先拖到查壳工具里面查壳，这也是我一直存在的误区。（2）观察题目不仅要看伪代码，汇编也要多看看，这个错误我也犯了，一上来就直接看伪代码，可能会漏掉东西。即便是 shift+f12，这道题的内容也多到你发蒙，不便于查看。</p><h3 id="wustctf2020level1"><a class="markdownIt-Anchor" href="#wustctf2020level1">#</a> [WUSTCTF2020]level1</h3><p> 题目多给附件无壳，并且还多给了一个 output 的文档，打开是 19 个数字。直接把文件拖到 IDA 中查看伪代码。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220730152647.png" alt=""><br> 代码的大致意思是对一个名为 flag 的文件进行修改，也就是将其中的内容进行加密，然后输出，那么 output 文件应该就是加密后的文件了。然后开始写 python 脚本。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test = [<span class="number">198</span>,<span class="number">232</span>,<span class="number">816</span>,<span class="number">200</span>,<span class="number">1536</span>,<span class="number">300</span>,<span class="number">6144</span>,<span class="number">984</span>,<span class="number">51200</span>,<span class="number">570</span>,<span class="number">92160</span>,<span class="number">1200</span>,<span class="number">565248</span>,<span class="number">756</span>,<span class="number">1474560</span>,<span class="number">800</span>,<span class="number">6291456</span>,<span class="number">1782</span>,<span class="number">65536000</span>]</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">19</span>):</span><br><span class="line">        <span class="keyword">if</span> ((i+<span class="number">1</span>) &amp; <span class="number">1</span>):</span><br><span class="line">            flag += <span class="built_in">chr</span>(test[i] &gt;&gt; (i+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag += <span class="built_in">chr</span>(test[i] // (i+<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;d9-dE6-20c&#125;</span><br></pre></td></tr></table></figure><h3 id="guet-ctf2019re"><a class="markdownIt-Anchor" href="#guet-ctf2019re">#</a> [GUET-CTF2019]re</h3><p> 题目是多少位不知道，但知道是 UPX 壳，所以先脱壳，脱完之后拖到 IDA 中查看伪代码。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220730163629.png" alt=""><br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220730163843.png" alt=""></p><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220731152719.png" alt=""><br> 这是主函数，但是关键的代码在 sub_4009AE。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">_BOOL8 __fastcall <span class="title">sub_4009AE</span><span class="params">(<span class="keyword">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">1629056</span> * *a1 != <span class="number">166163712</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">6771600</span> * a1[<span class="number">1</span>] != <span class="number">731332800</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">3682944</span> * a1[<span class="number">2</span>] != <span class="number">357245568</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">10431000</span> * a1[<span class="number">3</span>] != <span class="number">1074393000</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">3977328</span> * a1[<span class="number">4</span>] != <span class="number">489211344</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">5138336</span> * a1[<span class="number">5</span>] != <span class="number">518971936</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">7532250</span> * a1[<span class="number">7</span>] != <span class="number">406741500</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">5551632</span> * a1[<span class="number">8</span>] != <span class="number">294236496</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">3409728</span> * a1[<span class="number">9</span>] != <span class="number">177305856</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">13013670</span> * a1[<span class="number">10</span>] != <span class="number">650683500</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">6088797</span> * a1[<span class="number">11</span>] != <span class="number">298351053</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">7884663</span> * a1[<span class="number">12</span>] != <span class="number">386348487</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">8944053</span> * a1[<span class="number">13</span>] != <span class="number">438258597</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">5198490</span> * a1[<span class="number">14</span>] != <span class="number">249527520</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">4544518</span> * a1[<span class="number">15</span>] != <span class="number">445362764</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">3645600</span> * a1[<span class="number">17</span>] != <span class="number">174988800</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">10115280</span> * a1[<span class="number">16</span>] != <span class="number">981182160</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">9667504</span> * a1[<span class="number">18</span>] != <span class="number">493042704</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">5364450</span> * a1[<span class="number">19</span>] != <span class="number">257493600</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">13464540</span> * a1[<span class="number">20</span>] != <span class="number">767478780</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">5488432</span> * a1[<span class="number">21</span>] != <span class="number">312840624</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">14479500</span> * a1[<span class="number">22</span>] != <span class="number">1404511500</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">6451830</span> * a1[<span class="number">23</span>] != <span class="number">316139670</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">6252576</span> * a1[<span class="number">24</span>] != <span class="number">619005024</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">7763364</span> * a1[<span class="number">25</span>] != <span class="number">372641472</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">7327320</span> * a1[<span class="number">26</span>] != <span class="number">373693320</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">8741520</span> * a1[<span class="number">27</span>] != <span class="number">498266640</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">8871876</span> * a1[<span class="number">28</span>] != <span class="number">452465676</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">4086720</span> * a1[<span class="number">29</span>] != <span class="number">208422720</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">9374400</span> * a1[<span class="number">30</span>] == <span class="number">515592000</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5759124</span> * a1[<span class="number">31</span>] == <span class="number">719890500</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这就是关键代码，是一对判断语句，根据这个进行计算，我不知道怎么写脚本去算 a []，所以直接手动算，网上找一个计算器直接算，结果是少了一个 a [6]，然后 a [17] 和 a [16] 反了，结果就是 flag {e 65421110ba03099a1c039337}，少的那一个数在伪代码中没有提示，所以进行只能爆破，a [6]=1 就直接正确了，所以这道题可能就是让你去爆破的吧。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;e165421110ba03099a1c039337&#125;</span><br></pre></td></tr></table></figure><h3 id="rome"><a class="markdownIt-Anchor" href="#rome">#</a> rome</h3><p> 题目是 32 位，直接拖到 IDA 中查看伪代码。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220731175617.png" alt=""><br> 主要代码在 func（) 中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v1[<span class="number">4</span>]; <span class="comment">// [esp+14h] [ebp-44h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v2; <span class="comment">// [esp+24h] [ebp-34h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v3; <span class="comment">// [esp+25h] [ebp-33h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v4; <span class="comment">// [esp+26h] [ebp-32h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v5; <span class="comment">// [esp+27h] [ebp-31h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v6; <span class="comment">// [esp+28h] [ebp-30h]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [esp+29h] [ebp-2Fh]</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [esp+2Dh] [ebp-2Bh]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [esp+31h] [ebp-27h]</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// [esp+35h] [ebp-23h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v11; <span class="comment">// [esp+39h] [ebp-1Fh]</span></span><br><span class="line">  <span class="keyword">char</span> v12[<span class="number">29</span>]; <span class="comment">// [esp+3Bh] [ebp-1Dh] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(v12, <span class="string">&quot;Qsw3sj_lz4_Ujw@l&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please input:&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;v2);</span><br><span class="line">  result = v2;</span><br><span class="line">  <span class="keyword">if</span> ( v2 == <span class="number">65</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = v3;</span><br><span class="line">    <span class="keyword">if</span> ( v3 == <span class="number">67</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      result = v4;</span><br><span class="line">      <span class="keyword">if</span> ( v4 == <span class="number">84</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        result = v5;</span><br><span class="line">        <span class="keyword">if</span> ( v5 == <span class="number">70</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          result = v6;</span><br><span class="line">          <span class="keyword">if</span> ( v6 == <span class="number">123</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            result = v11;</span><br><span class="line">            <span class="keyword">if</span> ( v11 == <span class="number">125</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              v1[<span class="number">0</span>] = v7;</span><br><span class="line">              v1[<span class="number">1</span>] = v8;</span><br><span class="line">              v1[<span class="number">2</span>] = v9;</span><br><span class="line">              v1[<span class="number">3</span>] = v10;</span><br><span class="line">              *(_DWORD *)&amp;v12[<span class="number">17</span>] = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">while</span> ( *(<span class="keyword">int</span> *)&amp;v12[<span class="number">17</span>] &lt;= <span class="number">15</span> )</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">if</span> ( *((<span class="keyword">char</span> *)v1 + *(_DWORD *)&amp;v12[<span class="number">17</span>]) &gt; <span class="number">64</span> &amp;&amp; *((<span class="keyword">char</span> *)v1 + *(_DWORD *)&amp;v12[<span class="number">17</span>]) &lt;= <span class="number">90</span> )</span><br><span class="line">                  *((_BYTE *)v1 + *(_DWORD *)&amp;v12[<span class="number">17</span>]) = (*((<span class="keyword">char</span> *)v1 + *(_DWORD *)&amp;v12[<span class="number">17</span>]) - <span class="number">51</span>) % <span class="number">26</span> + <span class="number">65</span>;</span><br><span class="line">                <span class="keyword">if</span> ( *((<span class="keyword">char</span> *)v1 + *(_DWORD *)&amp;v12[<span class="number">17</span>]) &gt; <span class="number">96</span> &amp;&amp; *((<span class="keyword">char</span> *)v1 + *(_DWORD *)&amp;v12[<span class="number">17</span>]) &lt;= <span class="number">122</span> )</span><br><span class="line">                  *((_BYTE *)v1 + *(_DWORD *)&amp;v12[<span class="number">17</span>]) = (*((<span class="keyword">char</span> *)v1 + *(_DWORD *)&amp;v12[<span class="number">17</span>]) - <span class="number">79</span>) % <span class="number">26</span> + <span class="number">97</span>;</span><br><span class="line">                ++*(_DWORD *)&amp;v12[<span class="number">17</span>];</span><br><span class="line">              &#125;</span><br><span class="line">              *(_DWORD *)&amp;v12[<span class="number">17</span>] = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">while</span> ( *(<span class="keyword">int</span> *)&amp;v12[<span class="number">17</span>] &lt;= <span class="number">15</span> )</span><br><span class="line">              &#123;</span><br><span class="line">                result = (<span class="keyword">unsigned</span> __int8)v12[*(_DWORD *)&amp;v12[<span class="number">17</span>]];</span><br><span class="line">                <span class="keyword">if</span> ( *((_BYTE *)v1 + *(_DWORD *)&amp;v12[<span class="number">17</span>]) != (_BYTE)result )</span><br><span class="line">                  <span class="keyword">return</span> result;</span><br><span class="line">                ++*(_DWORD *)&amp;v12[<span class="number">17</span>];</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;You are correct!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 代码的大致意思就是你输入一段字符串，然后进行加密，如果和 strcpy (v12, “Qsw3sj_lz4_Ujw@l”); 相等，那么你输入的字符串就是 flag。<br> 写脚本。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">&quot;Qsw3sj_lz4_Ujw@l&quot;</span></span><br><span class="line">flag= <span class="built_in">list</span>(text)</span><br><span class="line">length = <span class="built_in">len</span>(text)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">127</span>):</span><br><span class="line">        <span class="keyword">if</span> j&gt;<span class="number">64</span> <span class="keyword">and</span> j&lt;=<span class="number">90</span> <span class="keyword">and</span> (<span class="built_in">ord</span>(text[i])==(j-<span class="number">51</span>)%<span class="number">26</span> + <span class="number">65</span>):</span><br><span class="line">            flag[i] = <span class="built_in">chr</span>(j)</span><br><span class="line">        <span class="keyword">elif</span> j&gt;<span class="number">96</span> <span class="keyword">and</span> j&lt;=<span class="number">122</span> <span class="keyword">and</span> (<span class="built_in">ord</span>(text[i])==(j-<span class="number">79</span>)%<span class="number">26</span> + <span class="number">97</span>):</span><br><span class="line">            flag[i] = <span class="built_in">chr</span>(j)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;flag&#123;&quot;</span>,end = <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    <span class="built_in">print</span>(i,end = <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#125;&quot;</span>,end = <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p> 刚学 python 没多久，写这个脚本还有点吃力，我是真的菜。而且我不会直接写逆脚本，我绕不过那个坎，所以只能写索引去解这道题。需要注意的是在加密的时候有些字符是不会发生变化的，我写脚本的时候就出错了，下次注意。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;Cae3ar_th4_Gre@t&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buuCTF-Reverse题解（一）</title>
      <link href="/2022/07/15/buuCTF-reverse%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/07/15/buuCTF-reverse%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="java逆向解密"><a class="markdownIt-Anchor" href="#java逆向解密">#</a> Java 逆向解密</h3><p> 这道题算是 java 逆向的入门题了吧，确实很简单，但是我 java 没有好好学，泪目啊，不管学什么都要好好学啊，总会有用的。<br> 首先是用 jd-gui（java 反编译工具）将得到的 class 文件反编译。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reverse</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;Please input the flag );</span></span><br><span class="line"><span class="string">    String str = s.next();               //输入字符串</span></span><br><span class="line"><span class="string">    System.out.println(&quot;</span>Your input is );</span><br><span class="line">    System.out.println(str);</span><br><span class="line">    <span class="keyword">char</span>[] stringArr = str.toCharArray();</span><br><span class="line">    Encrypt(stringArr);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Encrypt</span><span class="params">(<span class="keyword">char</span>[] arr)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; Resultlist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> result = arr[i] + <span class="number">64</span> ^ <span class="number">0x20</span>;</span><br><span class="line">      Resultlist.add(Integer.valueOf(result));</span><br><span class="line">    &#125;            <span class="comment">//此处是将输入的字符串加64，再与0x20异或</span></span><br><span class="line">    <span class="keyword">int</span>[] KEY = &#123; </span><br><span class="line">        <span class="number">180</span>, <span class="number">136</span>, <span class="number">137</span>, <span class="number">147</span>, <span class="number">191</span>, <span class="number">137</span>, <span class="number">147</span>, <span class="number">191</span>, <span class="number">148</span>, <span class="number">136</span>, </span><br><span class="line">        <span class="number">133</span>, <span class="number">191</span>, <span class="number">134</span>, <span class="number">140</span>, <span class="number">129</span>, <span class="number">135</span>, <span class="number">191</span>, <span class="number">65</span> &#125;;</span><br><span class="line">    ArrayList&lt;Integer&gt; KEYList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; KEY.length; j++)</span><br><span class="line">      KEYList.add(Integer.valueOf(KEY[j])); </span><br><span class="line">    System.out.println(<span class="string">&quot;Result:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (Resultlist.equals(KEYList)) &#123;  </span><br><span class="line">      System.out.println(<span class="string">&quot;Congratulations);</span></span><br><span class="line"><span class="string">    &#125; else &#123;</span></span><br><span class="line"><span class="string">      System.err.println(&quot;</span>Error);</span><br><span class="line">    &#125;    <span class="comment">//将result也就是我们输入的字符串助理后的结果与KEY进行比较</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 代码的大致 意思是，输入一段字符串，进行运算：+64  ^ 20。然后与 KEY 进行比较，相同就输出正确。<br> 所以我们可以写个 python 脚本将代码的过程逆一下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = [<span class="number">180</span>,<span class="number">136</span>,<span class="number">137</span>,<span class="number">147</span>,<span class="number">191</span>,<span class="number">137</span>,<span class="number">147</span>,<span class="number">191</span>,<span class="number">148</span>,<span class="number">136</span>,<span class="number">133</span>,<span class="number">191</span>,<span class="number">134</span>,<span class="number">140</span>,<span class="number">129</span>,<span class="number">135</span>,<span class="number">191</span>,<span class="number">65</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;flag&#123;&quot;</span>,end = <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">18</span>):</span><br><span class="line">    arr[i] = (arr[i] ^<span class="number">32</span>) -<span class="number">64</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(arr[i]),end = <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220715162817.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;This_is_the_flag_!&#125;</span><br></pre></td></tr></table></figure><h3 id="刮开有奖"><a class="markdownIt-Anchor" href="#刮开有奖">#</a> 刮开有奖</h3><p> 这道题拿到一个可执行程序。但是加载过后点击没有任何反应。所以直接拖到 IDA 中分析伪代码。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220722152159.png" alt=""></p><p> 代码分析还是有一定难度的，我也是看了很长时间，结果分析错了，于是借鉴了别人写的题解，实在是我技不如人，慢慢努力吧。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220722152711.png" alt=""><br> 首先是找到主函数，对于这种有窗口的程序的题我还是第二次接触，上一次接触还是在上一次，所以这一次写一写加深印象。<br> 如图，Winmain 函数的功能是被系统调用，作为一个 32 位程序的入口点，能够初始化应用程序，显示主窗口。<br> 随后是 DialogFunc 就是程序的主要伪代码所在了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">INT_PTR __stdcall <span class="title">DialogFunc</span><span class="params">(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v4; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v5; <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">int</span> v7[<span class="number">2</span>]; <span class="comment">// [esp+8h] [ebp-20030h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [esp+10h] [ebp-20028h]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [esp+14h] [ebp-20024h]</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// [esp+18h] [ebp-20020h]</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// [esp+1Ch] [ebp-2001Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// [esp+20h] [ebp-20018h]</span></span><br><span class="line">  <span class="keyword">int</span> v13; <span class="comment">// [esp+24h] [ebp-20014h]</span></span><br><span class="line">  <span class="keyword">int</span> v14; <span class="comment">// [esp+28h] [ebp-20010h]</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// [esp+2Ch] [ebp-2000Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [esp+30h] [ebp-20008h]</span></span><br><span class="line">  CHAR String[<span class="number">65536</span>]; <span class="comment">// [esp+34h] [ebp-20004h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v18[<span class="number">65536</span>]; <span class="comment">// [esp+10034h] [ebp-10004h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">272</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a2 != <span class="number">273</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (_WORD)a3 == <span class="number">1001</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(String, <span class="number">0</span>, <span class="number">0xFFFF</span>u);</span><br><span class="line">    GetDlgItemTextA(hDlg, <span class="number">1000</span>, String, <span class="number">0xFFFF</span>);</span><br><span class="line">      <span class="comment">//该函数的作用是获得与对话框中的控件相关的标题和文本</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strlen</span>(String) == <span class="number">8</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v7[<span class="number">0</span>] = <span class="number">90</span>;</span><br><span class="line">      v7[<span class="number">1</span>] = <span class="number">74</span>;</span><br><span class="line">      v8 = <span class="number">83</span>;</span><br><span class="line">      v9 = <span class="number">69</span>;</span><br><span class="line">      v10 = <span class="number">67</span>;</span><br><span class="line">      v11 = <span class="number">97</span>;</span><br><span class="line">      v12 = <span class="number">78</span>;</span><br><span class="line">      v13 = <span class="number">72</span>;</span><br><span class="line">      v14 = <span class="number">51</span>;</span><br><span class="line">      v15 = <span class="number">110</span>;</span><br><span class="line">      v16 = <span class="number">103</span>;   <span class="comment">//可以归为一个数组也就是v7</span></span><br><span class="line">      sub_4010F0(v7, <span class="number">0</span>, <span class="number">10</span>);<span class="comment">//这里将v7数组从小到大排序</span></span><br><span class="line">      <span class="built_in">memset</span>(v18, <span class="number">0</span>, <span class="number">0xFFFF</span>u);</span><br><span class="line">      v18[<span class="number">0</span>] = String[<span class="number">5</span>];</span><br><span class="line">      v18[<span class="number">2</span>] = String[<span class="number">7</span>];</span><br><span class="line">      v18[<span class="number">1</span>] = String[<span class="number">6</span>];</span><br><span class="line">      v4 = (<span class="keyword">const</span> <span class="keyword">char</span> *)sub_401000(v18, <span class="built_in">strlen</span>(v18));</span><br><span class="line">      <span class="built_in">memset</span>(v18, <span class="number">0</span>, <span class="number">0xFFFF</span>u);</span><br><span class="line">      v18[<span class="number">1</span>] = String[<span class="number">3</span>];</span><br><span class="line">      v18[<span class="number">0</span>] = String[<span class="number">2</span>];</span><br><span class="line">      v18[<span class="number">2</span>] = String[<span class="number">4</span>];</span><br><span class="line">      v5 = (<span class="keyword">const</span> <span class="keyword">char</span> *)sub_401000(v18, <span class="built_in">strlen</span>(v18));</span><br><span class="line">      <span class="keyword">if</span> ( String[<span class="number">0</span>] == v7[<span class="number">0</span>] + <span class="number">34</span></span><br><span class="line">        &amp;&amp; String[<span class="number">1</span>] == v10</span><br><span class="line">        &amp;&amp; <span class="number">4</span> * String[<span class="number">2</span>] - <span class="number">141</span> == <span class="number">3</span> * v8</span><br><span class="line">        &amp;&amp; String[<span class="number">3</span>] / <span class="number">4</span> == <span class="number">2</span> * (v13 / <span class="number">9</span>)</span><br><span class="line">        &amp;&amp; !<span class="built_in">strcmp</span>(v4, <span class="string">&quot;ak1w&quot;</span>)</span><br><span class="line">        &amp;&amp; !<span class="built_in">strcmp</span>(v5, <span class="string">&quot;V1Ax&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        MessageBoxA(hDlg, <span class="string">&quot;U g3t 1T!&quot;</span>, <span class="string">&quot;@_@&quot;</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (_WORD)a3 != <span class="number">1</span> &amp;&amp; (_WORD)a3 != <span class="number">2</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  EndDialog(hDlg, (<span class="keyword">unsigned</span> __int16)a3);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 代码的大致意思为 String 中的字符串就是我们需要的 flag。通过分析代码我们能够求出 String 中的字符串，所以也不用写脚本去逆。<br> 关键的部分其实只有两个：（1）排序；（2）base64 解码。<br> sub_4010F0 (v7, 0, 10); 函数的作用是排序，将 v7 进行排序。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">sub_4010F0</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// edx</span></span><br><span class="line"></span><br><span class="line">  result = a3;</span><br><span class="line">  <span class="keyword">for</span> ( i = a2; i &lt;= a3; a2 = i )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = <span class="number">4</span> * i;</span><br><span class="line">    v6 = *(_DWORD *)(<span class="number">4</span> * i + a1);</span><br><span class="line">    <span class="keyword">if</span> ( a2 &lt; result &amp;&amp; i &lt; result )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v6 &gt; *(_DWORD *)(a1 + <span class="number">4</span> * result) )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( i &gt;= result )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          ++i;</span><br><span class="line">          *(_DWORD *)(v5 + a1) = *(_DWORD *)(a1 + <span class="number">4</span> * result);</span><br><span class="line">          <span class="keyword">if</span> ( i &gt;= result )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">while</span> ( *(_DWORD *)(a1 + <span class="number">4</span> * i) &lt;= v6 )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( ++i &gt;= result )</span><br><span class="line">              <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ( i &gt;= result )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          v5 = <span class="number">4</span> * i;</span><br><span class="line">          *(_DWORD *)(a1 + <span class="number">4</span> * result) = *(_DWORD *)(<span class="number">4</span> * i + a1);</span><br><span class="line">        &#125;</span><br><span class="line">        --result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( i &lt; result );</span><br><span class="line">    &#125;</span><br><span class="line">LABEL_13:</span><br><span class="line">    *(_DWORD *)(a1 + <span class="number">4</span> * result) = v6;</span><br><span class="line">    sub_4010F0(a1, a2, i - <span class="number">1</span>);</span><br><span class="line">    result = a3;</span><br><span class="line">    ++i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 排序的结果是：[51, 67, 69, 72, 74, 78, 83, 90, 97, 103, 110]。<br> 然后就是 base64 解码了，在分析代码的时候发现了类似 base64 的编码表。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220722163158.png" alt=""></p><p>&amp;e 至于为什么少了一个字符，开头有个 A 应该能解释，所以这不是 base64 换表，就是 base64 解码。</p><p UJWP1jMp=""> sub_401000 就是 base64 编码函数。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220722163444.png" alt=""><br> v4 和 v5 经历了 base64 的编码。<br> 经过一系列的运算就能够得到 String 中的字符串了。<br>flag：flag</p><h3 id="简单注册器"><a class="markdownIt-Anchor" href="#简单注册器">#</a> 简单注册器</h3><p> 这道题给的是一个 apk 文件，很明显是一个安卓逆向，但是用安卓逆向工具得到的 smile 代码我是真的看不懂，所以找了一个反编译工具把这个代码反编译成 java 代码。我找的这个工具是 JEB。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.flag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.support.v4.app.Fragment;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.ActionBarActivity;</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater;</span><br><span class="line"><span class="keyword">import</span> android.view.Menu;</span><br><span class="line"><span class="keyword">import</span> android.view.MenuItem;</span><br><span class="line"><span class="keyword">import</span> android.view.View$OnClickListener;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">ActionBarActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaceholderFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PlaceholderFragment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater arg4, ViewGroup arg5, Bundle arg6)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> arg4.inflate(<span class="number">0x7F030018</span>, arg5, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle arg7)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(arg7);</span><br><span class="line">        <span class="keyword">this</span>.setContentView(<span class="number">0x7F030017</span>);</span><br><span class="line">        <span class="keyword">if</span>(arg7 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.getSupportFragmentManager().beginTransaction().add(<span class="number">0x7F05003C</span>, <span class="keyword">new</span> PlaceholderFragment()).commit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.findViewById(<span class="number">0x7F05003F</span>).setOnClickListener(<span class="keyword">new</span> View$OnClickListener(<span class="keyword">this</span>.findViewById(<span class="number">0x7F05003D</span>), <span class="keyword">this</span>.findViewById(<span class="number">0x7F05003E</span>)) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View arg13)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> v11 = <span class="number">0x1F</span>;</span><br><span class="line">                <span class="keyword">int</span> v9 = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">int</span> v2 = <span class="number">1</span>;</span><br><span class="line">                String v6 = <span class="keyword">this</span>.val$editview.getText().toString();</span><br><span class="line">                <span class="keyword">if</span>(v6.length() != <span class="number">0x20</span> || v6.charAt(v11) != <span class="number">97</span> || v6.charAt(<span class="number">1</span>) != <span class="number">98</span> || v6.charAt(<span class="number">0</span>) + v6.charAt(v9) - <span class="number">0x30</span> != <span class="number">56</span>) &#123;</span><br><span class="line">                    v2 = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(v2 == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">char</span>[] v5 = <span class="string">&quot;dd2940c04462b4dd7c450528835cca15&quot;</span>.toCharArray();</span><br><span class="line">                    v5[v9] = ((<span class="keyword">char</span>)(v5[v9] + v5[<span class="number">3</span>] - <span class="number">50</span>));</span><br><span class="line">                    v5[<span class="number">4</span>] = ((<span class="keyword">char</span>)(v5[v9] + v5[<span class="number">5</span>] - <span class="number">0x30</span>));</span><br><span class="line">                    v5[<span class="number">30</span>] = ((<span class="keyword">char</span>)(v5[v11] + v5[<span class="number">9</span>] - <span class="number">0x30</span>));</span><br><span class="line">                    v5[<span class="number">14</span>] = ((<span class="keyword">char</span>)(v5[<span class="number">27</span>] + v5[<span class="number">28</span>] - <span class="number">97</span>));</span><br><span class="line">                    <span class="keyword">int</span> v4;</span><br><span class="line">                    <span class="keyword">for</span>(v4 = <span class="number">0</span>; v4 &lt; <span class="number">16</span>; ++v4) &#123;</span><br><span class="line">                        <span class="keyword">char</span> v0 = v5[<span class="number">0x1F</span> - v4];</span><br><span class="line">                        v5[<span class="number">0x1F</span> - v4] = v5[v4];</span><br><span class="line">                        v5[v4] = v0;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">this</span>.val$textview.setText(<span class="string">&quot;flag&#123;&quot;</span> + String.valueOf(v5) + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.val$textview.setText(<span class="string">&quot;输入注册码错误&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu arg3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.getMenuInflater().inflate(<span class="number">0x7F0C0000</span>, arg3);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem arg3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> v1 = arg3.getItemId() == <span class="number">0x7F050040</span> ? <span class="keyword">true</span> : <span class="keyword">super</span>.onOptionsItemSelected(arg3);</span><br><span class="line">        <span class="keyword">return</span> v1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这是经过反编译得到的 java 代码，特别简单的一段代码，所以直接看核心代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(v2 == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">char</span>[] v5 = <span class="string">&quot;dd2940c04462b4dd7c450528835cca15&quot;</span>.toCharArray();</span><br><span class="line">                    v5[v9] = ((<span class="keyword">char</span>)(v5[v9] + v5[<span class="number">3</span>] - <span class="number">50</span>));</span><br><span class="line">                    v5[<span class="number">4</span>] = ((<span class="keyword">char</span>)(v5[v9] + v5[<span class="number">5</span>] - <span class="number">0x30</span>));</span><br><span class="line">                    v5[<span class="number">30</span>] = ((<span class="keyword">char</span>)(v5[v11] + v5[<span class="number">9</span>] - <span class="number">0x30</span>));</span><br><span class="line">                    v5[<span class="number">14</span>] = ((<span class="keyword">char</span>)(v5[<span class="number">27</span>] + v5[<span class="number">28</span>] - <span class="number">97</span>));</span><br><span class="line">                    <span class="keyword">int</span> v4;</span><br><span class="line">                    <span class="keyword">for</span>(v4 = <span class="number">0</span>; v4 &lt; <span class="number">16</span>; ++v4) &#123;</span><br><span class="line">                        <span class="keyword">char</span> v0 = v5[<span class="number">0x1F</span> - v4];</span><br><span class="line">                        v5[<span class="number">0x1F</span> - v4] = v5[v4];</span><br><span class="line">                        v5[v4] = v0;</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure><p> 这段代码就是修改了 v5 中的值，最后得到的 v5 就是 flag 了。可以将这串代码拿出来运行一下就能得到 flag。我改了一下用的是 c 语言。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v11 = <span class="number">0x1F</span>;</span><br><span class="line">    <span class="keyword">int</span> v9 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> v2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> v5[<span class="number">100</span>] = <span class="string">&quot;dd2940c04462b4dd7c450528835cca15&quot;</span>;</span><br><span class="line">    v5[v9] = ((<span class="keyword">char</span>)(v5[v9] + v5[<span class="number">3</span>] - <span class="number">50</span>));</span><br><span class="line">    v5[<span class="number">4</span>] = ((<span class="keyword">char</span>)(v5[v9] + v5[<span class="number">5</span>] - <span class="number">0x30</span>));</span><br><span class="line">    v5[<span class="number">30</span>] = ((<span class="keyword">char</span>)(v5[v11] + v5[<span class="number">9</span>] - <span class="number">0x30</span>));</span><br><span class="line">    v5[<span class="number">14</span>] = ((<span class="keyword">char</span>)(v5[<span class="number">27</span>] + v5[<span class="number">28</span>] - <span class="number">97</span>));</span><br><span class="line">    <span class="keyword">int</span> v4;</span><br><span class="line">    <span class="keyword">for</span>(v4 = <span class="number">0</span>; v4 &lt; <span class="number">16</span>; ++v4)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> v0 = v5[<span class="number">0x1F</span> - v4];</span><br><span class="line">        v5[<span class="number">0x1F</span> - v4] = v5[v4];</span><br><span class="line">        v5[v4] = v0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flag&#123;&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,v5);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag：flag&#123;59acc538825054c7de4b26440c0999dd&#125;</span><br></pre></td></tr></table></figure><h3 id="gwctf-2019pyre"><a class="markdownIt-Anchor" href="#gwctf-2019pyre">#</a> [GWCTF 2019]pyre</h3><p> 第一次接触这种 python 的逆向题，题目给了一个 pyc 文件，咱也不知道是干什么的，于是上网查了一下。<br> py. : 源码文件，由 python 程序解释<br> pyc. : 源码经过编译后生成的二进制字节码<br> 所以我们要做的就是反编译 pyc，做法是先下载一个 uncompyle 库：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//下载</span><br><span class="line">pip install uncompyle</span><br><span class="line">//命令行</span><br><span class="line">uncompyle6 test.pyc &gt; test1.py </span><br></pre></td></tr></table></figure><p> 把题目给的 pyc 反编译得到一个.py 文件。代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># uncompyle6 version 3.8.0</span></span><br><span class="line"><span class="comment"># Python bytecode 2.7 (62211)</span></span><br><span class="line"><span class="comment"># Decompiled from: Python 3.10.1 (tags/v3.10.1:2cd268a, Dec  6 2021, 19:10:37) [MSC v.1929 64 bit (AMD64)]</span></span><br><span class="line"><span class="comment"># Embedded file name: encode.py</span></span><br><span class="line"><span class="comment"># Compiled at: 2019-08-19 21:01:57</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Welcome to Re World!&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Your input1 is your flag~&#x27;</span></span><br><span class="line">l = <span class="built_in">len</span>(input1)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">    num = ((input1[i] + i) % <span class="number">128</span> + <span class="number">128</span>) % <span class="number">128</span></span><br><span class="line">    code += num</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l - <span class="number">1</span>):</span><br><span class="line">    code[i] = code[i] ^ code[(i + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> code</span><br><span class="line">code = [<span class="string">&#x27;\x1f&#x27;</span>, <span class="string">&#x27;\x12&#x27;</span>, <span class="string">&#x27;\x1d&#x27;</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;\x01&#x27;</span>, <span class="string">&#x27;\x06&#x27;</span>, <span class="string">&#x27;\x14&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;\x1b&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;:&#x27;</span>, <span class="string">&#x27;\x01&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;;&#x27;</span>, <span class="string">&#x27;%&#x27;</span>, <span class="string">&#x27;\x13&#x27;</span>]</span><br><span class="line"><span class="comment"># okay decompiling attachment.pyc</span></span><br></pre></td></tr></table></figure><p> 写一个脚本逆一下就能得到 flag。 取余逆运算的原理，如果：A=(B-C)% D，那么 B=(A+C)% D。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">code = [<span class="string">&#x27;\x1f&#x27;</span>, <span class="string">&#x27;\x12&#x27;</span>, <span class="string">&#x27;\x1d&#x27;</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;\x01&#x27;</span>, <span class="string">&#x27;\x06&#x27;</span>, <span class="string">&#x27;\x14&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;\x1b&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;:&#x27;</span>, <span class="string">&#x27;\x01&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;;&#x27;</span>, <span class="string">&#x27;%&#x27;</span>, <span class="string">&#x27;\x13&#x27;</span>]</span><br><span class="line">L = <span class="built_in">len</span>(code)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L-<span class="number">1</span>):</span><br><span class="line">    code[L-i-<span class="number">2</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(code[L-i-<span class="number">2</span>])^<span class="built_in">ord</span>(code[L-i-<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">    code[i] = <span class="built_in">chr</span>((<span class="built_in">ord</span>(code[i]) - i)%<span class="number">128</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">    <span class="built_in">print</span>(code[i],end = <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag：flag&#123;Just_Re_1s_Ha66y!&#125;</span><br></pre></td></tr></table></figure><h2 id="hdctf2019maze"><a class="markdownIt-Anchor" href="#hdctf2019maze">#</a> [HDCTF2019]Maze</h2><p> 之前遇到过迷宫题，但是没有好好做记录，这次遇到的迷宫题，不仅有花指令，还有迷宫，正好两个都做一下记录。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220724143507.png" alt=""><br> 程序没有 main 函数，看到了没这个红色的标积，这就是花指令，通常的做法有两种，一种是动调，程序可以自行恢复正常状态。一种是固定的操作。<br> 主要说说怎么用 IDA 清除这些花指令。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220724150409.png" alt=""><br> 将这个一块选中按 D 键。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220724150456.png" alt=""><br> 代码变成这样就可以了。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220724150626.png" alt=""><br> 将 0E8h 选中，然后按照图中的操作进行。</p><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220724150744.png" alt=""></p><p> 然后把开头的 E8 改为 90，再保存，再按一下 C 键。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220724150948.png" alt=""><br> 代码变成这样就可以了。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220724151054.png" alt=""><br> 这时候反汇编依然是看不出东西，先把代码往上翻找到这个__main，选中按下 P 键就可以看到主函数了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [esp+10h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> v5[<span class="number">16</span>]; <span class="comment">// [esp+14h] [ebp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  sub_401140(aGoThroughTheMa);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%14s&quot;</span>, v5);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">13</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( v5[i] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        --*(_DWORD *)asc_408078;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">        ++*(_DWORD *)asc_408078;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">        --dword_40807C;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">        ++dword_40807C;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( *(_DWORD *)asc_408078 == <span class="number">5</span> &amp;&amp; dword_40807C == <span class="number">-4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_401140(aCongratulation);</span><br><span class="line">    sub_401140(aHereIsTheFlagF);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    sub_401140(aTryAgain);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这就是主函数，迷宫的步数就是 flag。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220724151340.png" alt=""><br> 在这里找到迷宫，将这串东西复制到文本当中。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220724151435.png" alt=""><br> 分段的标准是对齐就行，所以按照 5 或 7 或 10 分就可以了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag:flag&#123;ssaaasaassdddw&#125;</span><br></pre></td></tr></table></figure><h3 id="pe"><a class="markdownIt-Anchor" href="#pe">#</a> PE</h3><p> 这道题我不知道来源。自取：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1qgiqIx6C31w40BlfBelmVA </span><br><span class="line">提取码：wish</span><br></pre></td></tr></table></figure><p> 给的程序是无法运行的，并且直接用 IDA 打开也看不到任何东西。做法是用 010 打开，然后修改。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220724164509.png" alt=""><br> 将 E0 改成 F0，再用 IDA 打开就能看到主函数了。我在网上找了一篇文章应该能大概了解下 PE。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://cloud.tencent.com/developer/article/1910254</span><br></pre></td></tr></table></figure><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220724164853.png" alt=""><br> 主函数大概就是这样，然后 sub_411339 是一个 base64 换表。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220724165059.png" alt=""><br> 在 sub4114B0 里面能发现一段字符串。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220724165236.png" alt=""><br> 程序的大致思路就是，将这段字符串通过换表解码，得到的就是 flag 了。</p><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220724165308.png" alt=""><br> 这个网站可以轻松实现换表解码，倾力推荐。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://icyberchef.com/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag：flag&#123;you_really_know_pe&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buuCTF题解（三）</title>
      <link href="/2022/07/10/buuCTF-Misc%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/07/10/buuCTF-Misc%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="easycap"><a class="markdownIt-Anchor" href="#easycap">#</a> easycap</h3><p 385b87afc8671dee07550290d16a8071=""> 这是一道比较简单的流量分析题。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710165530.png" alt=""><br> 拖到 wireshark 里面，然后右键追踪 TCP 流。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710165634.png" alt=""><br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710165727.png" alt=""><br> 答案就直接出来了。flag</p><h3 id="flag"><a class="markdownIt-Anchor" href="#flag">#</a> FLAG</h3><p> 这道题给了一张图片，拖到 010 里面没有发现什么东西，所以打开 stegsolve，看一下有没有 LSB 隐写。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710194812.png" alt=""><br> 可以看到在这里图片明显隐藏有东西。所以我们将它提取出来。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710195005.png" alt=""><br> 这是一个 zip 文件，提取出来，提取出来解压，但是不要用 window 自带的 Winrar 解压，会出现错误，用 7z 可以直接解压出来。<br> 解压得到的文件拖进 010 里面<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710195303.png" alt=""><br> 发现这是一个 ELF 文件，是 linux 下的可执行文件，我们把它拖进 linux 虚拟机里面，执行一下，答案就出来了。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710195437.png" alt=""><br> 如果出现权限不足的情况，可以执行下面这个指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod 777 &lt;program&gt;</span><br></pre></td></tr></table></figure><p>flag：flag{dd0gf4c3tok3yb0ard4g41n~~~}<br> 总结：看到 ELF，可以先拖到 Linux 中运行一下。</p><h3 id="假如给我三天光明"><a class="markdownIt-Anchor" href="#假如给我三天光明">#</a> 假如给我三天光明</h3><p> 题目给了一个图片和一个压缩包。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/pic.jpg" alt=""><br> 很明显是盲文，对照盲文表得出的字符串是 kmdonowg。压缩包有密码，那么这串字符很有可能就是压缩包的密码，解开压缩包之后得到一个音乐文件。拖到 Audacity 里面看一下是不是有摩斯密码。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710214204.png" alt=""><br> 果然是摩斯密码，网上找一个摩斯密码对照表解一下。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/%E6%91%A9%E6%96%AF%E5%AF%86%E7%A0%81%E8%A1%A82.png" alt=""><br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/%E6%91%A9%E6%96%AF%E5%AF%86%E7%A0%81%E8%A1%A81.png" alt=""><br> 解出来：CTFWPEI08732?23DZ<br> 很明显 CTF 后面就是我们所要的 flag，但是要将字母都转化为小写。<br>flag：flag{wpei08732?23dz}<br> 总结：这道题虽然简单，但是我却卡住了，原因就是最后解出来了，但是没有转成小写，故而出错，所以在做题的时候，最后的 flag 输入不正确，不妨转一下大小写。</p><h3 id="神秘龙卷风"><a class="markdownIt-Anchor" href="#神秘龙卷风">#</a> 神秘龙卷风</h3><p> 题目给了一个有密码的压缩包，并且题目有提示如下：<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220711143344.png" alt=""><br> 四位数字，很明显，压缩包的密码是四位数字，那么就用 ARCHPR 对压缩包进行暴力破解。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220711143549.png" alt=""><br> 密码出来以后进行解压，解压出一个 txt 文档。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220711143658.png" alt=""><br> 是 Brainfuck 语言，找一个解密网站解一下就出来了。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220711143819.png" alt=""><br>flag：flag{e4bbef8bdf9743f8bf5b727a9f6332a8}<br> 总结：Brainfuck 语言解密网站： <a href="https://www.splitbrain.org/services/ook">https://www.splitbrain.org/services/ook</a></p><h3 id="数据包中的线索"><a class="markdownIt-Anchor" href="#数据包中的线索">#</a> 数据包中的线索</h3><p>这又是一道流量分析题，直接用 wireshark 打开。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220711145702.png" alt=""><br> 发现导出对象里只有 HTTP 能导出东西。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220711145758.png" alt=""><br> 用文档打开那个 fenxi.php。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220711145853.png" alt=""><br> 发现有点像 base，但是这个 base64 太长了，那就有可能是 base64 转图片，随便找个 base62 转图片网站，转一下。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220711150023.png" alt=""><br> 答案直接就出来了。<br>flag：flag{209acebf6324a09671abc31c869de72c}<br> 总结：因为我对流量分析一点都不懂，做题也可能是误打误撞，所以看了别人写的 wp，对这道题的分析是，TCP 流很多，所以直接过滤出 http 流，然后就能分析出那串文本，最后也是转成图片就行了。</p><h3 id="后门查杀"><a class="markdownIt-Anchor" href="#后门查杀">#</a> 后门查杀</h3><p 6ac45fb83b3bc355c024f5034b947dd3="">这道题是后门查杀，用 D 盾进行后门查杀就行了。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220713115238.png" alt=""><br>图中红的的文件就是查到的东西。右键查看。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220713115649.png" alt=""><br>题目中说查到的 md5 就是密码。<br>flag：flag</p><h3 id="面具下的flag"><a class="markdownIt-Anchor" href="#面具下的flag">#</a> 面具下的 flag</h3><p> 面具之下，是更美的面具。<br> 题目给了一个图片，而且是 jpg 格式，用 010 打开。<br><img src="C:%5CUsers%5Ca%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220713161441430.png" alt="image-20220713161441430"><br> 能够很明显的看到图片中隐藏了一个压缩包文件。所以将这个图片脱到 kali 虚拟机中用 binwalk 提取一下。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220713165708.png" alt=""><br> 那个 zip 文件里的内容和另一个文件是相同的，zip 文件是伪加密，解开后也能得到右边的文件。flag.vmdk 用 7z 或者 winrar 提取一下得到两个密文文件。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220713170051.png" alt=""><br> 第一个文件中有一段密文。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220713170139.png" alt=""><br> 这是 Brainfuck 语言，之前遇到过，解出来是：flag {N7F5_AD5。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220713171503.png" alt=""><br> 显然还有另外一段。另外一段我是直接将 flag.vmdk 文件拖入到 010 中找到的。因为在看 010 的时候，发现 flag.vmdk 文件里有 ook 语言，所以找了一下，总共有三段 ook 语言，全部解密一边，发现只有其中一段能够解出来。<br> <img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220713171418.png" alt=""><br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220713171814.png" alt=""><br>那么这一段很明显就是 flag 的后半段了。<br>flag：flag {N7F5_AD5_i5_funny!} Java 逆向解密</p><h3 id="java逆向解密"><a class="markdownIt-Anchor" href="#java逆向解密">#</a> java 逆向解密</h3><p> 这道题算是 java 逆向的入门题了吧，确实很简单，但是我 java 没有好好学，泪目啊，不管学什么都要好好学啊，总会有用的。<br> 首先是用 jd-gui（java 反编译工具）将得到的 class 文件反编译。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reverse</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;Please input the flag );</span></span><br><span class="line"><span class="string">    String str = s.next();               //输入字符串</span></span><br><span class="line"><span class="string">    System.out.println(&quot;</span>Your input is );</span><br><span class="line">    System.out.println(str);</span><br><span class="line">    <span class="keyword">char</span>[] stringArr = str.toCharArray();</span><br><span class="line">    Encrypt(stringArr);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Encrypt</span><span class="params">(<span class="keyword">char</span>[] arr)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; Resultlist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> result = arr[i] + <span class="number">64</span> ^ <span class="number">0x20</span>;</span><br><span class="line">      Resultlist.add(Integer.valueOf(result));</span><br><span class="line">    &#125;            <span class="comment">//此处是将输入的字符串加64，再与0x20异或</span></span><br><span class="line">    <span class="keyword">int</span>[] KEY = &#123; </span><br><span class="line">        <span class="number">180</span>, <span class="number">136</span>, <span class="number">137</span>, <span class="number">147</span>, <span class="number">191</span>, <span class="number">137</span>, <span class="number">147</span>, <span class="number">191</span>, <span class="number">148</span>, <span class="number">136</span>, </span><br><span class="line">        <span class="number">133</span>, <span class="number">191</span>, <span class="number">134</span>, <span class="number">140</span>, <span class="number">129</span>, <span class="number">135</span>, <span class="number">191</span>, <span class="number">65</span> &#125;;</span><br><span class="line">    ArrayList&lt;Integer&gt; KEYList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; KEY.length; j++)</span><br><span class="line">      KEYList.add(Integer.valueOf(KEY[j])); </span><br><span class="line">    System.out.println(<span class="string">&quot;Result:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (Resultlist.equals(KEYList)) &#123;  </span><br><span class="line">      System.out.println(<span class="string">&quot;Congratulations);</span></span><br><span class="line"><span class="string">    &#125; else &#123;</span></span><br><span class="line"><span class="string">      System.err.println(&quot;</span>Error);</span><br><span class="line">    &#125;    <span class="comment">//将result也就是我们输入的字符串助理后的结果与KEY进行比较</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 代码的大致 意思是，输入一段字符串，进行运算：+64  ^ 20。然后与 KEY 进行比较，相同就输出正确。<br> 所以我们可以写个 python 脚本将代码的过程逆一下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = [<span class="number">180</span>,<span class="number">136</span>,<span class="number">137</span>,<span class="number">147</span>,<span class="number">191</span>,<span class="number">137</span>,<span class="number">147</span>,<span class="number">191</span>,<span class="number">148</span>,<span class="number">136</span>,<span class="number">133</span>,<span class="number">191</span>,<span class="number">134</span>,<span class="number">140</span>,<span class="number">129</span>,<span class="number">135</span>,<span class="number">191</span>,<span class="number">65</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;flag&#123;&quot;</span>,end = <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">18</span>):</span><br><span class="line">    arr[i] = (arr[i] ^<span class="number">32</span>) -<span class="number">64</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(arr[i]),end = <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220715162817.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python（二）</title>
      <link href="/2022/07/10/python%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/07/10/python%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="分支和循环"><a class="markdownIt-Anchor" href="#分支和循环">#</a> 分支和循环</h3><h5 id="分支语句"><a class="markdownIt-Anchor" href="#分支语句">#</a> 分支语句</h5><ol><li></li></ol><p> 分支语句，满足条件，执行一个分支</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">3</span>&lt;<span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我在里面&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我也在里面&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我在外面&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我在里面</span><br><span class="line">我也在里面</span><br><span class="line">我在外面</span><br></pre></td></tr></table></figure><p> python 的 if 语句是通过缩进来区分它从属关系的，所以在写代码的时候需要注意缩进，并且在语句后面加上分号。<br>2.<br> 判断一个条件：<br>如果成立，就执行其包含的某个语句或代码块<br>如果不成立，就执行另外的某个语句或代码块</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">3</span>&gt;<span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3&gt;5&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3&lt;5&quot;</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li></li></ol><p> 判断多个条件，如果第一个条件不成立，则继续判断第二个条件，如果第二个条件还不成立，则继续判断第三个条件…</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">score = <span class="built_in">input</span>(<span class="string">&quot;请输入你的分数：&quot;</span>)</span><br><span class="line">score = <span class="built_in">int</span>(score)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span>&lt;=score&lt;<span class="number">60</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;D&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="number">60</span>&lt;=score&lt;<span class="number">80</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;C&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="number">80</span>&lt;=score&lt;<span class="number">90</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="number">90</span>&lt;=score&lt;<span class="number">100</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> score == <span class="number">100</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;S&quot;</span>)</span><br></pre></td></tr></table></figure><p> 但是上述代码的判断较为复杂，因为不管哪个条件成立，都要进行满五次判断，不如用下面的代替：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">score = <span class="built_in">input</span>(<span class="string">&quot;请输入你的分数：&quot;</span>)</span><br><span class="line">score = <span class="built_in">int</span>(score)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span>&lt;=score&lt;<span class="number">60</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;D&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">60</span>&lt;=score&lt;<span class="number">80</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;C&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">80</span>&lt;=score&lt;<span class="number">90</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">90</span>&lt;=score&lt;<span class="number">100</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;S&quot;</span>)</span><br></pre></td></tr></table></figure><p> 如果第一次判断成立，那么程序直接结束，大大节省了效率。</p><h5 id="条件表达式"><a class="markdownIt-Anchor" href="#条件表达式">#</a> 条件表达式</h5><p> 条件表达式就差不多是写在一行语句上的判断语句。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="number">3</span></span><br><span class="line">b=<span class="number">5</span></span><br><span class="line">small = a <span class="keyword">if</span> a&lt;b <span class="keyword">else</span> b</span><br><span class="line"><span class="built_in">print</span>(small)</span><br></pre></td></tr></table></figure><p> 将上面的分值测评程序用条件表达式表示是这样的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">score = <span class="number">45</span></span><br><span class="line">level = (<span class="string">&#x27;D&#x27;</span> <span class="keyword">if</span> <span class="number">0</span>&lt;= score &lt; <span class="number">60</span> <span class="keyword">else</span></span><br><span class="line">         <span class="string">&#x27;C&#x27;</span> <span class="keyword">if</span> <span class="number">60</span>&lt;= score &lt;<span class="number">80</span> <span class="keyword">else</span></span><br><span class="line">         <span class="string">&#x27;B&#x27;</span> <span class="keyword">if</span> <span class="number">80</span>&lt;= score &lt;<span class="number">90</span> <span class="keyword">else</span></span><br><span class="line">         <span class="string">&#x27;A&#x27;</span> <span class="keyword">if</span> <span class="number">90</span>&lt;= score &lt;<span class="number">100</span> <span class="keyword">else</span></span><br><span class="line">         <span class="string">&#x27;S&#x27;</span> <span class="keyword">if</span> score == <span class="number">100</span> <span class="keyword">else</span></span><br><span class="line">         <span class="string">&quot;请输入0~100之间的分值&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(level)</span><br></pre></td></tr></table></figure><h5 id="分支结构的嵌套"><a class="markdownIt-Anchor" href="#分支结构的嵌套">#</a> 分支结构的嵌套</h5><p> if 语句的嵌套，很简单。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">18</span></span><br><span class="line">isMale = <span class="literal">True</span></span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;抱歉，未满18岁，禁止访问！&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> isMale:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;任君选购！&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;抱歉，本店商品不适合您购买！&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="循环语句"><a class="markdownIt-Anchor" href="#循环语句">#</a> 循环语句</h5><h6 id="while"><a class="markdownIt-Anchor" href="#while">#</a> while</h6><p> while 循环就是根据条件的成立的与否来执行循环的语句。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">love = <span class="string">&#x27;yes&#x27;</span></span><br><span class="line"><span class="keyword">while</span> love ==<span class="string">&#x27;yes&#x27;</span>:</span><br><span class="line">    love = <span class="built_in">input</span>(<span class="string">&quot;今天你还爱我么？\n&quot;</span>)</span><br></pre></td></tr></table></figure><h6 id="continue"><a class="markdownIt-Anchor" href="#continue">#</a> continue</h6><p> continue 语句是跳出循环语句，并回到循环语句的开头，与 break 语句不同，break 是直接跳出循环执行下面的语句。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i&lt;<span class="number">10</span>:</span><br><span class="line">    i+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p> 上述程序输出 1 3 5 7 9。</p><h6 id="else"><a class="markdownIt-Anchor" href="#else">#</a> else</h6><p> while 中的 else 语句的作用是当循环语句不再为真时，else 语句才会被执行。else 语句可以检测循环的退出状况。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">day = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> day &lt;= <span class="number">7</span>:</span><br><span class="line">    answer = <span class="built_in">input</span>(<span class="string">&quot;今天有好好学习么？\n&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> answer != <span class="string">&quot;有&quot;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    day+=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;非常棒！你已经完成了7天的学习！&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="循环的嵌套"><a class="markdownIt-Anchor" href="#循环的嵌套">#</a> 循环的嵌套</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">9</span>:</span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= i:</span><br><span class="line">        <span class="built_in">print</span>(j,<span class="string">&quot;*&quot;</span>,i,<span class="string">&quot;=&quot;</span>,j * i,end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        j += 1s</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    i+=<span class="number">1</span></span><br></pre></td></tr></table></figure><p> 九九乘法口诀表的实现</p><h5 id="for循环"><a class="markdownIt-Anchor" href="#for循环">#</a> for 循环</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> <span class="string">&quot;FishC&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(each)</span><br></pre></td></tr></table></figure><p> 这段代码的作用就是将字符串中的字符依次赋值给 each，然后 print 再输出 each。这就是迭代。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10001</span>):</span><br><span class="line">    <span class="built_in">sum</span>+=i</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure><p> 用 for 循环实现 1 加到 10000，用到了 range。range 有三种形式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)    <span class="comment">#输出1-10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)    <span class="comment">#输出5-9</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">10</span>,<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)    <span class="comment">#输出5-10，指定跨度为2，实际输出的是5 7 9</span></span><br></pre></td></tr></table></figure><p> range 也可以设置负数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n):</span><br><span class="line">        <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(n,<span class="string">&quot;=&quot;</span>,x,<span class="string">&quot;*&quot;</span>,n//x)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(n,<span class="string">&quot;是一个素数&quot;</span>)</span><br></pre></td></tr></table></figure><p> 用 for 循环嵌套实现 10 以内的素数的输出。</p><h3 id="列表"><a class="markdownIt-Anchor" href="#列表">#</a> 列表</h3><h5 id="创建列表"><a class="markdownIt-Anchor" href="#创建列表">#</a> 创建列表</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lb = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">&quot;我是社牛&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(lb)   <span class="comment">#定义列表并输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lb:</span><br><span class="line">    <span class="built_in">print</span>(i)   <span class="comment">#for循环依次输出列表</span></span><br><span class="line"></span><br><span class="line">lb[<span class="number">0</span>]   <span class="comment">#输出列表中对应下标中的数据</span></span><br><span class="line">lb[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">length = <span class="built_in">len</span>(lb)</span><br><span class="line">lb[length-<span class="number">1</span>]  <span class="comment">#将列表长度赋值给length，并输出列表最后一位</span></span><br><span class="line"></span><br><span class="line">lb[<span class="number">0</span>:<span class="number">3</span>]     <span class="comment">#发挥想象，和range差不多</span></span><br><span class="line">lb[:<span class="number">3</span>]</span><br><span class="line">lb[<span class="number">3</span>:]</span><br><span class="line">lb[::<span class="number">2</span>]</span><br><span class="line">lb[::-<span class="number">2</span>]</span><br><span class="line">lb[:]</span><br><span class="line">lb[<span class="number">0</span>:<span class="number">6</span>:<span class="number">2</span>]</span><br><span class="line">lb[-<span class="number">1</span>]</span><br><span class="line">lb[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h5 id="增删改查"><a class="markdownIt-Anchor" href="#增删改查">#</a> 增删改查</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">heros = [<span class="string">&quot;钢铁侠&quot;</span>,<span class="string">&quot;绿巨人&quot;</span>]</span><br><span class="line">heros.append(<span class="string">&quot;黑寡妇&quot;</span>)</span><br><span class="line"></span><br><span class="line">heros.extend([<span class="string">&quot;鹰眼&quot;</span>,<span class="string">&quot;灭霸&quot;</span>,<span class="string">&quot;雷神&quot;</span>])</span><br></pre></td></tr></table></figure><p> append 方法的作用是在列表末位添加一个数据。而 expend 的作用是添加一个迭代在列表的末尾。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">s.insert(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p> insert 的作用是添加指定位置的数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">heros = [<span class="string">&#x27;钢铁侠&#x27;</span>, <span class="string">&#x27;绿巨人&#x27;</span>, <span class="string">&#x27;黑寡妇&#x27;</span>, <span class="string">&#x27;鹰眼&#x27;</span>, <span class="string">&#x27;灭霸&#x27;</span>, <span class="string">&#x27;雷神&#x27;</span>]</span><br><span class="line">heros.remove(<span class="string">&quot;钢铁侠&quot;</span>)</span><br></pre></td></tr></table></figure><p> remove 方法的作用是删除指定元素，如果列表中存在多个匹配的元素，那么只会删除下表最小的那个。如果指定的元素不存在，那么就会报错。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">heros = [&#x27;钢铁侠&#x27;, &#x27;绿巨人&#x27;, &#x27;黑寡妇&#x27;, &#x27;鹰眼&#x27;, &#x27;灭霸&#x27;, &#x27;雷神&#x27;]</span><br><span class="line">heros.clear()</span><br></pre></td></tr></table></figure><p> clear 方法是清空列表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">heros = [<span class="string">&#x27;钢铁侠&#x27;</span>, <span class="string">&#x27;绿巨人&#x27;</span>, <span class="string">&#x27;黑寡妇&#x27;</span>, <span class="string">&#x27;鹰眼&#x27;</span>, <span class="string">&#x27;灭霸&#x27;</span>, <span class="string">&#x27;雷神&#x27;</span>]</span><br><span class="line">heros[<span class="number">3</span>:] = [<span class="string">&quot;宋江&quot;</span>,<span class="string">&quot;武松&quot;</span>,<span class="string">&quot;林冲&quot;</span>]</span><br></pre></td></tr></table></figure><p> 上述代码的作用是替换指定位置的列表的元素。</p><h5 id="列表排序"><a class="markdownIt-Anchor" href="#列表排序">#</a> 列表排序</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br><span class="line">nums.sort()</span><br><span class="line">nums.reverse()</span><br></pre></td></tr></table></figure><p> sort 的作用是将列表按从小到大排序，reverse 的作用是将列表按从大到小的顺序排序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">heros = [<span class="string">&quot;李逵&quot;</span>,<span class="string">&quot;林冲&quot;</span>,<span class="string">&quot;宋江&quot;</span>,<span class="string">&quot;鲁智深&quot;</span>,<span class="string">&quot;武松&quot;</span>]</span><br><span class="line">heros.reverse()</span><br></pre></td></tr></table></figure><p> 这里 reverse 的作用是将列表倒序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br><span class="line">nums.count(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p> count 的作用是获取某个元素在列表中的数目。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">heros = [<span class="string">&quot;李逵&quot;</span>,<span class="string">&quot;林冲&quot;</span>,<span class="string">&quot;宋江&quot;</span>,<span class="string">&quot;鲁智深&quot;</span>,<span class="string">&quot;武松&quot;</span>]</span><br><span class="line">heros.index(<span class="string">&quot;鲁智深&quot;</span>)  </span><br><span class="line">    <span class="comment">#获取下标</span></span><br><span class="line">heros[heros.index(<span class="string">&quot;鲁智深&quot;</span>)] = <span class="string">&quot;史进&quot;</span> </span><br><span class="line">        <span class="comment">#替换</span></span><br></pre></td></tr></table></figure><p> 我们可以使用 index 来获取列表元素下标，也可以用这个方法去替换不知道下标的元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">t = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">s + t    <span class="comment">#列表的拼接</span></span><br><span class="line">s * <span class="number">3</span>    <span class="comment">#列表的重复</span></span><br><span class="line">   <span class="comment">#二维列表的创建</span></span><br><span class="line">matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">   <span class="comment">#循环嵌套二维列表</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> matrix:</span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> i:</span><br><span class="line">        <span class="built_in">print</span>(each)</span><br><span class="line"></span><br><span class="line">matrix[<span class="number">0</span>][<span class="number">1</span>]  <span class="comment">#访问列表</span></span><br><span class="line">   <span class="comment">#创建二维列表</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    A[i] = [<span class="number">0</span>] * <span class="number">3</span></span><br><span class="line"></span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">y = x.copy()   <span class="comment">#列表的浅拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">x = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">y = copy.copy(x) <span class="comment">#浅拷贝</span></span><br><span class="line">y = copy.decopy(x) <span class="comment">#深拷贝</span></span><br></pre></td></tr></table></figure><h5 id="列表推导式"><a class="markdownIt-Anchor" href="#列表推导式">#</a> 列表推导式</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">oho = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]</span><br><span class="line">oho = [i * <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> oho]</span><br></pre></td></tr></table></figure><p> 这是列表推导式，可以实现多种功能，十分便捷。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  <span class="comment">#将 字符串 * 2</span></span><br><span class="line">y = [c * <span class="number">2</span> <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&quot;FishC&quot;</span>]</span><br><span class="line">  <span class="comment">#将字符串替换成对应的ASCII码值</span></span><br><span class="line">code = [<span class="built_in">ord</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&quot;FishC&quot;</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单程序破解和修改窗口</title>
      <link href="/2022/07/09/%E7%AE%80%E5%8D%95%E7%A0%B4%E8%A7%A3%E5%92%8C%E4%BF%AE%E6%94%B9%E7%AA%97%E5%8F%A3/"/>
      <url>/2022/07/09/%E7%AE%80%E5%8D%95%E7%A0%B4%E8%A7%A3%E5%92%8C%E4%BF%AE%E6%94%B9%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="简单的修改窗口"><a class="markdownIt-Anchor" href="#简单的修改窗口">#</a> 简单的修改窗口</h3><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709224730.png" alt=""><br> 拿到一个简单的小程序，我们要做的是把它的标题和显示的 “win32” 修改一下。<br>1. 使用 010<br> 第一种方法是用 010 修改，拖进去。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709225132.png" alt=""><br> 用这个文本搜索，搜到之后，直接改，但是要注意修改的字符长度要和原来的相同，如果不足可以用空格代替。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709225422.png" alt=""><br> 改过之后是这样的。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709225458.png" alt=""><br>2. 使用 od<br> 第二种是使用 od 修改内容。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709231026.png" alt=""><br> 使用中文搜索，直接搜索我们想要改的字符串。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709231120.png" alt=""><br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709231207.png" alt=""><br> 程序在这一行，然后数据右键窗口跟随。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709231331.png" alt=""></p><p> 我们就能找到数据窗口中文本所在位置。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709235358.png" alt="">在数据窗口选择需要改的东西然后 ctrl+E。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709235630.png" alt=""></p><p>然后进行修改。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709235544.png" alt=""><br> 我在 ASCII 写入了我爱你。修改前，关闭窗口左下角的保持大小，修改后注意尽量保证你修改的数据与原来的数据的长度相同，不然可能会出现乱码，还有尽量不要修改除文本之外的其他东西。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709231732.png" alt=""><br>再选中你改的东西，右键复制到可执行文件。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709231822.png" alt=""><br>这里选择保存文件，保存过后就完成修改了。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709234859.png" alt=""></p><h3 id="简单的程序破解"><a class="markdownIt-Anchor" href="#简单的程序破解">#</a> 简单的程序破解</h3><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709235044.png" alt=""><br> 我们拿到这样一个小程序，当你输入错误的用户名和密码时，它会提示<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709235158.png" alt=""><br> 我们可以用 od 进行简单的破解，直接绕过这个错误窗口。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709235307.png" alt=""><br> 不管你输入什么，都会提示你成功！<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709235942.png" alt=""><br> 插件选择 API 断点的常用断点设置。这个可以帮助我们下断点。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710000057.png" alt=""><br> 选择图中的那个选项，然后确定，再点击运行让程序跑起来。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710000510.png" alt=""><br> 出现这个窗口后，我们随机输入数字，然后点击 check，<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710000635.png" alt=""><br> 发现程序自动跳到断点这里，再不断地 f8 运行。直到程序跳出这个窗口<br><img src="C:%5CUsers%5Ca%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220710000827311.png" alt="image-20220710000827311"><br> 然后我们再分析一波汇编代码。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710001013.png" alt=""><br> 发现程序是到了这里停了下来，说明这里可能就是导致出现序列号错误窗口的那个点。所以我们将程序再重新运行，点左上角的两个三角的符号重新运行，我们按照和之前同样的操作不断进行，只不过需要注意的就是 je、jl 等这些跳转操作，关注右边的标志寄存器，如果有发生跳转的地方，我们就将标志寄存器的值修改一下，不断运行，不让程序发生跳转，最后我们同样是运行到了和之前错误窗口出现的那个位置。但是这次窗口不再显示错误，而是显示成功了。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710003524.png" alt=""></p><p> 说明我们已经成功了一半，接下来就是找到我们认为可疑的会进行跳转的地方，我发现了下面这几个跳转：<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710001907.png" alt=""><br>发现几个可疑的跳转，我们把它们右键全部 nop 掉，<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710002003.png" alt=""><br>然后在右键选中复制 —&gt; 全选<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710004425.png" alt=""><br>再右键复制到可执行文件 —&gt; 选择<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710004652.png" alt=""><br>再右键灰色窗口保存文件即可。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710004614.png" alt=""><br>最后就能得到我们破解的程序了。</p>]]></content>
      
      
      <categories>
          
          <category> pj </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buuCTF题解（二）</title>
      <link href="/2022/07/03/buuCTF%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/07/03/buuCTF%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="reverse1"><a class="markdownIt-Anchor" href="#reverse1">#</a> reverse1</h4><p>程序是 64，拖进 IDA 直接分析伪代码。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706143247.png" alt=""><br> 程序的下方，if (!strncmp (Str1, Str2, v5) ) 的意思是，str2=str1，则 输出 this is the right flag!\n。二 str1 是我们要输入的字符串，所以关键点就在于 str2，我们掉进去查看一下 str2 的值。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706143532.png" alt=""><br> 发现隐藏了一个字符串，所以我们再分析上面的代码。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706143648.png" alt=""><br> 这段的意思就是将 o 替换成 0，即 {hello_world}–&gt;{hell0_w0rld}, 这就是最后的 flag 了。<br>flag：flag{hell0_w0rld}<br> 总结：strncmp（str1，str2，str3) 函数的作用是对比字符串是否相等，str3 是指定前几个字符串。</p><h4 id="reverse2"><a class="markdownIt-Anchor" href="#reverse2">#</a> reverse2</h4><p hack1ng_fo1_fun=""> 直接分析源代码。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706144831.png" alt=""><br> 图中方框中的代码表示将 flag 中 存储的字符串的中的 i 和 r 替换成 1，再看下方的代码，将 flag 和 s2 进行比较，如果相等输出 this is right flag！，s2 是我们输入的字符串，所以我们调进去查看 flag 的内容。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706145204.png" alt=""><br> 发现 hacking_for_fun，替换成 hack1ng_fo1_fun 就是我们的 flag 了。<br>flag：flag</p><h4 id="新年快乐"><a class="markdownIt-Anchor" href="#新年快乐">#</a> 新年快乐</h4><p> 这道题是加了壳的。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706161032.png" alt=""><br>将程序拖进 PE 中查看，发现是 UPX 的壳，并且将程序拖进 IDA 中发现只有两个函数，所以我们要进行脱壳。</p><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706161532.png" alt=""></p><p> 脱完之后再拖进 IDA 中就能查看函数了。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706161254.png" alt=""><br>分析代码，得到 flag。<br>flag：flag{HappyNewYear!}<br> 总结：用 UPX 脱 UPX 的壳。</p><h4 id="helloworld"><a class="markdownIt-Anchor" href="#helloworld">#</a> helloworld</h4><p 7631a988259a00816deda84afb29430a=""><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706173018.png" alt=""><br> 发现他是一个 apk 文件，所以需要用 apkIDA 打开，打开之后找到 MainActivity 查看，就能发现 flag。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706173250.png" alt=""><br>flag：flag</p><h4 id="reverse3"><a class="markdownIt-Anchor" href="#reverse3">#</a> reverse3</h4><p>程序直接拖到 IDA 中分析代码。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706174435.png" alt=""><br> 大致思路就是，输入一段字符串 Str，进行 base64 加密之后变成 Destination，Destination 的每一个字符再加上一个数，最后 Destination 与 Str2 进行比较，相同则输出 right flag！。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706174823.png" alt=""><br> v4 = (const char *) sub_4110BE (Str, v3, v14);main 函数中的这行代码进行的是 base64 加密（如图)。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706175103.png" alt=""><br> 这是 Str2 字符串的内容，e3nifIH9b_C@n@dH</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> iflag[<span class="number">40</span>]=<span class="string">&quot;e3nifIH9b_C@n@dH&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">16</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        iflag[i]-=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(iflag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p i_l0ve_you=""> 简单写一个 c 代码逆一下那个 Destination 加数，得到 e2lfbDB2ZV95b3V9。然后将这段字符串找一个 base64 解码网站解一下，就得到 flag 了。<br>flag：flag</p><h4 id="simplerev"><a class="markdownIt-Anchor" href="#simplerev">#</a> SimpleRev</h4><p>用 IDA64 打开文件，直接分析伪代码。我在代码中做了注释。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v11 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">*(_QWORD *)src = <span class="string">&#x27;SLCDN&#x27;</span>;</span><br><span class="line">v7 = <span class="number">0LL</span>;</span><br><span class="line">v8 = <span class="number">0</span>;</span><br><span class="line">v9[<span class="number">0</span>] = <span class="string">&#x27;wodah&#x27;</span>;</span><br><span class="line">v9[<span class="number">1</span>] = <span class="number">0LL</span>;</span><br><span class="line">v10 = <span class="number">0</span>;</span><br><span class="line">text = (<span class="keyword">char</span> *)((__int64 (__fastcall *)(<span class="keyword">char</span> *, __int64 *))join)(key3, v9);</span><br><span class="line"><span class="built_in">strcpy</span>(key, key1);   <span class="comment">//作用是将key1的值复制到key中</span></span><br><span class="line"><span class="built_in">strcat</span>(key, src);  <span class="comment">//作用是将src中字符串拼接到key中</span></span><br><span class="line">v2 = <span class="number">0</span>;</span><br><span class="line">v3 = <span class="number">0</span>;</span><br><span class="line">getchar();</span><br><span class="line">v5 = <span class="built_in">strlen</span>(key);   <span class="comment">//计算key的长度</span></span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v5; ++i )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( key[v3 % v5] &gt; <span class="number">64</span> &amp;&amp; key[v3 % v5] &lt;= <span class="number">90</span> )</span><br><span class="line">    key[i] = key[v3 % v5] + <span class="number">32</span>;</span><br><span class="line">  ++v3;   <span class="comment">//这里for的作用是将key中的大写字符串全部转化为小写字符串</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input your flag:&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v1 = getchar();</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">10</span> )</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">32</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    ++v2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v1 &lt;= <span class="number">96</span> || v1 &gt; <span class="number">122</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v1 &gt; <span class="number">64</span> &amp;&amp; v1 &lt;= <span class="number">90</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        str2[v2] = (v1 - <span class="number">39</span> - key[v3 % v5] + <span class="number">97</span>) % <span class="number">26</span> + <span class="number">97</span>;</span><br><span class="line">        ++v3;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      str2[v2] = (v1 - <span class="number">39</span> - key[v3 % v5] + <span class="number">97</span>) % <span class="number">26</span> + <span class="number">97</span>;</span><br><span class="line">      ++v3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !(v3 % v5) )</span><br><span class="line">      <span class="built_in">putchar</span>(<span class="number">32</span>);</span><br><span class="line">    ++v2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(text, str2) )   <span class="comment">//比较text和str2，如果相同，返回0，不相同 </span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Congratulation!\n&quot;</span>); <span class="comment">//返回1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Try again!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v11;</span><br></pre></td></tr></table></figure><p> 代码给了四个关键字符串，也就是 src、v9 [0]、key1、key3。下面是 key1 和 key3 存储的字符串：<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220708181806.png" alt=""><br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220708181845.png" alt=""></p><p> 字符串拼接完之后，是这样的：text = killshadow，key = adsfkndcls，注意第二段字符串都是倒过来，然后再拼起来的。<br> 得到这两个字符串之后，就是通过一系列运算，最后得到 str2，再与 text 进行比较，相同就输出 Congratulation!，即为正确答案。</p><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220708182520.png" alt=""></p><p> 那就写一个脚本逆一下。我写的是 c 语言脚本。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> text[<span class="number">100</span>] = <span class="string">&quot;killshadow&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> key[<span class="number">100</span>] = <span class="string">&quot;adsfkndcls&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> v1[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">128</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; <span class="string">&#x27;A&#x27;</span> || j &gt; <span class="string">&#x27;z&#x27;</span> || j &gt; <span class="string">&#x27;Z&#x27;</span> &amp;&amp; j &lt; <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">if</span>(text[i] == (j - <span class="string">&#x27;\&#x27;&#x27;</span> - key[i] + <span class="string">&#x27;a&#x27;</span>)%<span class="number">26</span> + <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,j);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 本来是想着写取余逆运算，但是发现实在太复杂，而且我实现不了，所以就在网上借鉴了别人写的脚本，大致思路就是通过 if 语句的判断来筛选出符合条件的字符串，这个思路也可以用到其他题，学到了不少。</p><h4 id="gxyctf2019luck_guy"><a class="markdownIt-Anchor" href="#gxyctf2019luck_guy">#</a> [GXYCTF2019]luck_guy</h4><p>这道题还是非常简单的，看懂伪代码就直接出来了，甚至脚本都不用写。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709131401.png" alt=""><br>F5 主函数，查看这个 patch_me（v4)<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709131510.png" alt=""><br> 再进入那个 get_flag（) 函数，就能看到我们的关键伪代码了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">get_flag</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+4h] [rbp-3Ch]</span></span><br><span class="line">  <span class="keyword">int</span> j; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  __int64 s; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v5; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v6; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v0 = time(<span class="number">0LL</span>);</span><br><span class="line">  srand(v0);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )     </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( rand() % <span class="number">200</span> )     <span class="comment">//简单的循环语句嵌套了一个switch语句</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;OK, it&#x27;s flag:&quot;</span>);</span><br><span class="line">        <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x28</span>uLL);</span><br><span class="line">        <span class="built_in">strcat</span>((<span class="keyword">char</span> *)&amp;s, f1);</span><br><span class="line">        <span class="built_in">strcat</span>((<span class="keyword">char</span> *)&amp;s, &amp;f2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;s);</span><br><span class="line">        <span class="keyword">break</span>;       <span class="comment">//这段代码的作用是将f1和f2拼接</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Solar not like you&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Solar want a girlfriend&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        s = <span class="number">0x7F666F6067756369</span>LL;</span><br><span class="line">        v5 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">strcat</span>(&amp;f2, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;s);  </span><br><span class="line">        <span class="keyword">break</span>;    <span class="comment">//这段的作用是将s的字符串复制到f2中</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">7</span>; ++j )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( j % <span class="number">2</span> == <span class="number">1</span> )</span><br><span class="line">            *(&amp;f2 + j) -= <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            --*(&amp;f2 + j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">//这段的作用是将f2的字符串按奇数减2，偶数减1</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;emmm,you can&#x27;t find flag 23333&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p do_not_hate_me=""> 本题的大致思路是，case4 将 s 的字符串复制到 f2 里面，然后 case5 将 f2 进行加减处理，最后 case1 将 f1 和 f2 拼接到一起，得到 flag。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709142851.png" alt=""><br> 这是字符串 f1 的内容，很容易就能看出这就是 flag 的前半段，因为 GXY 恰好就是题目的标题，所以我们只需要求出后半段即可，然后我们看 f2，f2 的值其实就是 s 的值，将 ASCII 码转换成字符串就是fo`guci，再带到 case5 中进行运算，case5 的作用就是将字符串的奇数位 ASCII 码减 2，偶数位减 1，最后得到} em_etah，再进行倒序就得到 hate_me}，这就是 flag 的后半段。<br>flag：flag</p><h4 id="actf新生赛2020easyre"><a class="markdownIt-Anchor" href="#actf新生赛2020easyre">#</a> [ACTF 新生赛 2020] easyre</h4><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709213233.png" alt=""><br> 拿到程序先用 PE 查壳，发现是 upx 壳，用 upx shell 脱下壳<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709213434.png" alt=""><br> 然后将程序拖到 IDA 中分析伪代码。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_BYTE v4[<span class="number">12</span>]; <span class="comment">// [esp+12h] [ebp-2Eh] BYREF</span></span><br><span class="line">  _DWORD v5[<span class="number">3</span>]; <span class="comment">// [esp+1Eh] [ebp-22h]</span></span><br><span class="line">  _BYTE v6[<span class="number">5</span>]; <span class="comment">// [esp+2Ah] [ebp-16h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [esp+2Fh] [ebp-11h]</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [esp+33h] [ebp-Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [esp+37h] [ebp-9h]</span></span><br><span class="line">  <span class="keyword">char</span> v10; <span class="comment">// [esp+3Bh] [ebp-5h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [esp+3Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  __main();</span><br><span class="line">  qmemcpy(v4, <span class="string">&quot;*F&#x27;\&quot;N,\&quot;(I?+@&quot;</span>, <span class="keyword">sizeof</span>(v4));<span class="comment">//把字符串复制到v4里面</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please input:&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, v6);</span><br><span class="line">  <span class="keyword">if</span> ( v6[<span class="number">0</span>] != <span class="number">65</span> || v6[<span class="number">1</span>] != <span class="number">67</span> || v6[<span class="number">2</span>] != <span class="number">84</span> || v6[<span class="number">3</span>] != <span class="number">70</span> || v6[<span class="number">4</span>] != <span class="number">123</span> || v10 != <span class="number">125</span> )<span class="comment">//v6+v10的内容恰好是ACTF&#123;&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v5[<span class="number">0</span>] = v7;</span><br><span class="line">  v5[<span class="number">1</span>] = v8;</span><br><span class="line">  v5[<span class="number">2</span>] = v9;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">11</span>; ++i ) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v4[i] != _data_start__[*((<span class="keyword">char</span> *)v5 + i) - <span class="number">1</span>] )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//将v4里的值和_data_start__中对比，不相同返回0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;You are correct!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 重要的就是上面 for 语句中的比较，将 v4 中的字符串的 ASCII 码和_data_start__中的字符串进行对比，相同的话就是我们要找的 flag 了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v4[i] != _data_start__[*((char *)v5 + i) - 1] </span><br></pre></td></tr></table></figure><p> 这段代码的意思是在_data_start__中寻找到一个字符再减 1，然后再与 v4 中的字符串的 ASCII 码值对比。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709214237.png" alt=""></p><p> 这是_data_start__中的字符串，其中 “7Eh”，“27h” 需要转成字符，分别是 “~”，“ ‘ ”。<br> 接下来我们写一个 py 脚本来输出 flag。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v4 = <span class="string">&quot;*F&#x27;\&quot;N,\&quot;(I?+@&quot;</span>  </span><br><span class="line">text = <span class="string">&#x27;~&#125;|&#123;zyxwvutsrqponmlkjihgfedcba`_^]\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;=&lt;;:9876543210/.-,+*)(\&#x27;&amp;%$# !&quot;&#x27;</span></span><br><span class="line">  <span class="comment">#注意该段字符串中有的字串需要转义，“ ‘ ”需要转义，还有后面的#后面有个空格不要忘了</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span>  <span class="comment">#空的数组</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> v4:</span><br><span class="line">    flag += <span class="built_in">chr</span>(text.find(i)+<span class="number">1</span>)   <span class="comment">#使用find函数进行查找</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;flag&#123;&quot;</span>+ flag +<span class="string">&quot;&#125;&quot;</span>)   <span class="comment">#以flag&#123;&#125;形式输出</span></span><br></pre></td></tr></table></figure><p>flag：flag{U9X_1S_W6@T?}<br> 总结：这道题我觉得最难得地方就在于字符串的处理，不仅在 IDA 中，v4 字符串的那堆乱码让人不好辨别，还有_data_start__中的字符串有的容易漏掉，有的容易忘记转换成字符，有的在写脚本的时候忘记转义。说实话，一开始我用 shift+E 提取字符串的时候长度恰好 64 位，我一度以为是 base64，结果编码函数都没找到，我还在那里用换表硬算，真的是让人笑掉大牙。所以做题的时候细心最重要。通过这道题，我也对字符串认识更加深了一步。</p><h4 id="简单题"><a class="markdownIt-Anchor" href="#简单题">#</a> 简单题</h4><p> 这道题思路不难理解，就是写脚本那一块卡了很久。这题不是 buu 的题，学长给的，找不到出处了，和之前 buu 的 xor 类似。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706205009.png" alt=""><br> 分析一波代码，还是很好理解的。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706205224.png" alt=""><br> 核心就是这段代码，将 buf 与 xor_str 进行异或，得到的结果与 result 进行比较。如果相同，就输出 right！<br> 再看 result 和 xor_str 中的值。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/SH7@G4~BEO8R2DLKJ5BT4%5DT.png" alt=""><br> 可以看到确实有东西，shift+E 提取。<br><img src="C:%5CUsers%5Ca%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220706205824410.png" alt="image-20220706205824410"><br> 然后再看 xor<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706205857.png" alt=""><br> 同样 shift+E，最后写脚本。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1=[<span class="number">0xC0</span>,<span class="number">0x7A</span>,<span class="number">0xDB</span>,<span class="number">0x29</span>,<span class="number">0x2B</span>,<span class="number">0x5A</span>,<span class="number">0x9D</span>,<span class="number">0x78</span>,<span class="number">0x08</span>,<span class="number">0x1F</span>, </span><br><span class="line"><span class="number">0xA5</span>,<span class="number">0x30</span>,<span class="number">0x3D</span>,<span class="number">0x18</span>,<span class="number">0x6C</span>,<span class="number">0xFD</span>,<span class="number">0xD9</span>,<span class="number">0x9E</span>,<span class="number">0x07</span>,<span class="number">0xA0</span>, </span><br><span class="line"><span class="number">0x0D</span>,<span class="number">0xF2</span>,<span class="number">0x3A</span>,<span class="number">0xDE</span>,<span class="number">0xCE</span>,<span class="number">0xEF</span>,<span class="number">0x23</span>,<span class="number">0x58</span>,<span class="number">0xC3</span>,<span class="number">0x56</span>, </span><br><span class="line"><span class="number">0xA0</span>,<span class="number">0x67</span>,<span class="number">0xCC</span>,<span class="number">0x0E</span>,<span class="number">0x59</span>,<span class="number">0x33</span>,<span class="number">0x54</span>,<span class="number">0x70</span>]</span><br><span class="line">list2=[<span class="number">0xA6</span>,<span class="number">0x16</span>,<span class="number">0xBA</span>,<span class="number">0x4E</span>,<span class="number">0x50</span>,<span class="number">0x3E</span>,<span class="number">0xFE</span>,<span class="number">0x41</span>,<span class="number">0x31</span>,<span class="number">0x2F</span>, </span><br><span class="line"><span class="number">0xC4</span>,<span class="number">0x52</span>,<span class="number">0x5F</span>,<span class="number">0x2A</span>,<span class="number">0x08</span>,<span class="number">0xC8</span>,<span class="number">0xE9</span>,<span class="number">0xAA</span>,<span class="number">0x61</span>,<span class="number">0xC4</span>, </span><br><span class="line"><span class="number">0x6F</span>,<span class="number">0xCA</span>,<span class="number">0x0A</span>,<span class="number">0xBB</span>,<span class="number">0xFB</span>,<span class="number">0xDB</span>,<span class="number">0x12</span>,<span class="number">0x6D</span>,<span class="number">0xF4</span>,<span class="number">0x61</span>, </span><br><span class="line"><span class="number">0xC1</span>,<span class="number">0x5E</span>,<span class="number">0xFD</span>,<span class="number">0x37</span>,<span class="number">0x3C</span>,<span class="number">0x04</span>,<span class="number">0x36</span>,<span class="number">0x0D</span>]</span><br><span class="line">flag=<span class="string">&#x27;0&#x27;</span></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  <span class="keyword">if</span> i&lt;<span class="built_in">len</span>(list1):</span><br><span class="line">    flag += <span class="built_in">chr</span>(<span class="built_in">int</span>(list1[i])^<span class="built_in">int</span>(list2[i]))</span><br><span class="line">    i+=<span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p> 运行一下，输出结果。<br><img src="C:%5CUsers%5Ca%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220706210126210.png" alt="image-20220706210126210"><br>flag{dc990abb2d504fdb80e541577a919e7b}<br> 总结：这个脚本想了好久，也是因为之前做的 buuctf 的逆向 xor 题和这个十分类似，要不然脚本这一块真不知道怎么写。写脚本，以及逻辑运算这两块都有待提升。</p>]]></content>
      
      
      <categories>
          
          <category> writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buuCTF题解（一）</title>
      <link href="/2022/07/01/buuCTF%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/07/01/buuCTF%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="不一样的flag"><a class="markdownIt-Anchor" href="#不一样的flag">#</a> 不一样的 flag</h4><p> 这道题与传统的逆向题不同，更像是一个游戏，一个盲人走迷宫游戏。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220701162403.png" alt=""><br> 上来直接分析伪代码，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ( *((_BYTE *)&amp;v5 + 5 * v1 + v2 - 41) == &#x27;1&#x27; )</span><br><span class="line">if ( *((_BYTE *)&amp;v5 + 5 * v1 + v2 - 41) == &#x27;#&#x27; )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;\nok, the order you enter is the flag!&quot;);</span><br><span class="line">       exit(0);</span><br></pre></td></tr></table></figure><p> 关键就在于这两行代码，上面一句意思是说如果某个值等于 1，那么程序就终止，下面的意思是如果等于 #，则程序运行结束，游戏胜利。<br> 分析整个代码的话，大致理解为不断输入 1-4 这 4 个数，然后程序不断运行，最后输出 \nok, the order you enter is the flag! 代表胜利。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220701162913.png" alt=""><br> 程序运行，可以看到 1-4 代表上下左右四个方向，并且在 IDA 中我们可以找到一串字符。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220701163026.png" alt=""><br> 这串字符很有可能就是这个盲人迷宫的地图。并且字符的数目是 25，那么除以 5 可以得到：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*1111</span><br><span class="line">01000</span><br><span class="line">01010</span><br><span class="line">00010</span><br><span class="line">1111#</span><br></pre></td></tr></table></figure><p> 只有 0 和 1，并且前面我们分析程序输入 1 终止，那么只能输入 0，因此再看这个地图就很明显了。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220701163355.png" alt=""><br> 根据这个地图我们向程序中输入数字。最后就能得到 flag。<br>flag：222441144222<br> 总结：<br>1.exit (1)：非正常运行导致程序退出。exit（0) 程序正常退出<br> 2. 多开阔思维，再遇到这样的题型要多想想。</p><h4 id="变异凯撒"><a class="markdownIt-Anchor" href="#变异凯撒">#</a> 变异凯撒</h4><p> 这道题不是常规的凯撒解密，但是和凯撒密码的移位原理相同。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220702110439.png" alt=""><br>给了一串字符，放到常规凯撒解密中不能解出任何东西，可以说这个格式和常规凯撒没有任何关系，这时候就该想到 ASCII 码，前四个字符的 ASCII 码是 97,102,90,95，而 flag 的 ASCII 码是 102，108，97，103，刚好相差 5,6,7,8，所以可以看到这实际上是 ASCII 码的偏移，写个 c 简单减一下。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> sum[<span class="number">100</span>]=&#123;<span class="number">97</span>,<span class="number">102</span>,<span class="number">90</span>,<span class="number">95</span>,<span class="number">114</span>,<span class="number">57</span>,<span class="number">86</span>,<span class="number">89</span>,<span class="number">102</span>,<span class="number">83</span>,<span class="number">99</span>,<span class="number">79</span>,<span class="number">101</span>,<span class="number">79</span>,<span class="number">95</span>,<span class="number">85</span>,<span class="number">76</span>,<span class="number">94</span>,<span class="number">82</span>,<span class="number">87</span>,<span class="number">85</span>,<span class="number">99</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">22</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[i] = sum[i] + (<span class="number">5</span> + i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,sum[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>最后得到 flag：flag {Caesar_variation}<br> 总结：应该早点想到 ASCII 码的。<br>ASCII 码与字符串转化网站：<a href="https://www.asciim.cn/m/tools/convert_string_to_ascii.html">字符串转 ASCII 码 - ASCII 码 (asciim.cn)</a><br><a href="https://www.asciim.cn/m/tools/convert_ascii_to_string.html"> ASCII 码转字符串 - ASCII 码 (asciim.cn)</a></p><h4 id="rsa"><a class="markdownIt-Anchor" href="#rsa">#</a> RSA</h4><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220702161850.png" alt=""></p><p> 实在没看懂网上对于 RSA 的讲解，因为数学特别差，抽个时间还要再学一下，这道题感觉就像是数学的求解题，到网上找了个 py 脚本。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util <span class="keyword">import</span> number</span><br><span class="line">p = <span class="number">473398607161</span></span><br><span class="line">q = <span class="number">4511491</span></span><br><span class="line">e = <span class="number">17</span></span><br><span class="line">d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure><p> 在用这个脚本的时候发现还要下载 gmpy2 和 Crypto 的模块，不然脚本是无法正常运行的，所以安装方法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux：</span><br><span class="line">sudo apt-get install libgmp-dev     //安装gmp</span><br><span class="line">sudo apt-get install libmpfr-dev    //安装mpfr</span><br><span class="line">sudo apt-get install libmpc-dev     //安装mpc</span><br><span class="line">sudo pip3 install gmpy2       //安装gmpy2</span><br><span class="line">sudo pip install gmpy2   </span><br><span class="line">pip install pycrypto        //安装Crypto</span><br></pre></td></tr></table></figure><p 125631357777427553="">flag：flag</p><h4 id="大帝的密码武器"><a class="markdownIt-Anchor" href="#大帝的密码武器">#</a> 大帝的密码武器</h4><p PbzrPuvan=""> 比较正常的一道凯撒密码题，主要思路就是穷举。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220702160455.png" alt=""><br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220702161123.png" alt=""><br> 通过穷举法我们得出的明文是 SECURITY（意为 “安全”)，偏移量是 13，再用偏移量去加密 ComeChina，得到 flag。<br>flag：flag</p><h4 id="alice和bob"><a class="markdownIt-Anchor" href="#alice和bob">#</a> Alice 和 Bob</h4><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220702162632.png" alt=""><br>将整数分解成两个素数，网上找一个在线网站，也就是在线分解质因数：<a href="http://tools.jb51.net/jisuanqi/factor_calc">在线分解质因数计算器工具 - 在线计算器 - 脚本之家在线工具 (jb51.net)</a><br> 分解整合得到的新数是：101999966233，然后按题目要求进行 md5 的 32 位小写加密得到 flag。<br>flag：flag{d450209323a847c8d01c6be47c81811a}<br> 总结：只要能看懂题目就能做出来，重要的是学会运用在线工具网站。推荐的 md5 加密网站：<a href="https://www.23bei.com/tool/1.html#">MD5 加密 (16 位，32 位，大写，小写) 在线计算器 (23bei.com)</a><br> md5 解密网站：<a href="https://cmd5.com/">md5 在线解密破解，md5 解密加密 (cmd5.com)</a></p><h4 id="windows系统密码"><a class="markdownIt-Anchor" href="#windows系统密码">#</a> Windows 系统密码</h4><p> 附件用记事本打开。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220702165352.png" alt=""><br> 可以看到第三行有个 ctf 字样，说明后面的字符串有可能是密文，并且看见这种样式首先想到的就是 md5，ctf 后面的字符串中间用分号隔开了，前半段无法解开，后半段解开是<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220702165657.png" alt=""><br>这个就是 flag 了。<br>flag：flag{good-luck}<br> 总结：<a href="https://cmd5.com/">md5 在线解密破解，md5 解密加密 (cmd5.com)</a> 这个网站很强大。</p><h4 id="信息化时代的步伐"><a class="markdownIt-Anchor" href="#信息化时代的步伐">#</a> 信息化时代的步伐</h4><p>这是个中文电码题，我还傻傻的去用 ASCII 转字符。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220702193518.png" alt=""><br>flag：flag {计算机要从娃娃抓起}<br> 总结：编码解码网站：<a href="http://code.mcdvisa.com/">中文电码查询 Chinese Commercial Code - 标准电报码免费在线查询 | 姓名电码 | 美国签证电码 (mcdvisa.com)</a></p><h4 id="凯撒替换呵呵"><a class="markdownIt-Anchor" href="#凯撒替换呵呵">#</a> 凯撒？替换？呵呵！</h4><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220702210825.png" alt=""><br> 这里的密文用常规的移位解密无法解出来，用 ASCII 码移位去解同样也是解不出来，并且 MTHJ 看似很对应 flag，所以有可能是简单的替换密码，原理大概是设置一个字母对应表，每一种字母均唯一对应一种字母，破解方式是词频分析进行破解。网站：<a href="https://quipqiup.com/">quipqiup - cryptoquip and cryptogram solver</a><br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220702211339.png" alt=""><br> 解密后是这样的：<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220702211423.png" alt=""><br> 第一行就是我们的 flag 了，flag substitution cipher decryption is always easy just like a piece of cake（标志替换密码解密总是很容易，就像小菜一碟一样)，去掉空格加上括号就是答案了。<br>flag：flag{substitutioncipherdecryptionisalwayseasyjustlikeapieceofcake}<br> 总结：虽然凯撒密码比较简单，但是这些变异也是让人防不胜防，替换的原理我还没搞清，所以还是要继续学。</p><h4 id="rsarsa"><a class="markdownIt-Anchor" href="#rsarsa">#</a> rsarsa</h4><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220703115158.png" alt=""></p><p> 我还是在网上找的脚本，我现在的能力着实写不粗来。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Decrypt</span>(<span class="params">c,e,p,q</span>):</span></span><br><span class="line">L=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d=gmpy2.invert(e,L)</span><br><span class="line">n=p*q</span><br><span class="line">m=gmpy2.powmod(c,d,n)</span><br><span class="line">flag=<span class="built_in">str</span>(m)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;flag&#123;&quot;</span>+flag+<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">p =  <span class="number">9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483</span></span><br><span class="line">q =  <span class="number">11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407</span></span><br><span class="line">e =  <span class="number">65537</span></span><br><span class="line">c =  <span class="number">83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034</span></span><br><span class="line">Decrypt(c,e,p,q)</span><br></pre></td></tr></table></figure><p 5577446633554466577768879988=""> 运行就能得到 flag。<br>flag：flag</p><h4 id="萌萌哒的八戒"><a class="markdownIt-Anchor" href="#萌萌哒的八戒">#</a> 萌萌哒的八戒</h4><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220703120347.png" alt=""><br>很明显是猪圈密码，解开后是 when the pig want to eat。<br>flag：flag{whenthepigwanttoeat}<br> 总结：猪圈密码对照表<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220703120558.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python(一)</title>
      <link href="/2022/06/30/python-%E4%B8%80/"/>
      <url>/2022/06/30/python-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="执行python的几个方式"><a class="markdownIt-Anchor" href="#执行python的几个方式">#</a> 执行 python 的几个方式</h4><p> 1. 解释器 —python/python3<br> 2. 交互式 —ipython<br> 3. 集成开发环境 —Pycharm</p><h4 id="第一个helloworld程序"><a class="markdownIt-Anchor" href="#第一个helloworld程序">#</a> 第一个 Helloworld 程序</h4><p> 写代码的第一步肯定是少不了 Helloworld 的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;HelloWorld&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;HelloPhython&quot;</span>)</span><br></pre></td></tr></table></figure><p> python <program>执行。</p><h4 id="python2x和python3x"><a class="markdownIt-Anchor" href="#python2x和python3x">#</a> python2.x 和 python3.x</h4><p> 1.Python2.x 的解释器名称是 python，python3.x 的解释器名称是 python3<br> 2. 两者开发的差别不是很大，新学的建议使用 python3.x。</p><h4 id="交互式python解释器"><a class="markdownIt-Anchor" href="#交互式python解释器">#</a> 交互式 python 解释器</h4><p> 1. 在终端输入 python/python3 就能打开交互式解释器，输入一句 py 语句就执行一句。<br> 2. 适合学习或者验证局部代码<br> 3. 代码不利于保存，不适合写较大的代码。<br> 4.exit（）或 ctrl+d 退出。</p><h4 id="ipython"><a class="markdownIt-Anchor" href="#ipython">#</a> IPython</h4><p>1. 特点<br>（1）支持自动补全<br>（2）自动缩进<br>（3）支持 bash shell 命令<br>（4）内置了许多有用的功能和函数<br> 2. 版本<br> python2.x 使用 ipython<br> python3.x 使用 ipython3<br>3. 安装<br>安装 ipython</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ipython</span><br></pre></td></tr></table></figure><p>安装 ipython3</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ipython3</span><br></pre></td></tr></table></figure><p>4. 使用<br> ipython/ipython3 进入，exit/ctrl+d 退出。</p><h4 id="pycharm"><a class="markdownIt-Anchor" href="#pycharm">#</a> PyCharm</h4><p>1.IDE<br> PyCharm 是一个强大的集成开发环境。<br>2. 下载安装<br> 在 linux 中直接到商城下载就行。</p><h4 id="常见出错"><a class="markdownIt-Anchor" href="#常见出错">#</a> 常见出错</h4><p>1. 符号不是英文下的符号<br> 2. 不必要的缩进，多添加的空格会导致程序出错。<br>3. 拼写错误</p><h4 id="变量和字符串"><a class="markdownIt-Anchor" href="#变量和字符串">#</a> 变量和字符串</h4><p>1. 变量<br> 简而言之，不要用数字开头就行，py3 支持中文做变量名，但是一般不用中文。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>2. 字符串<br> 通常用单引号或双引号包裹起来，两种形式并没有什么区别，我们只是根据具体情况来使用两种方式，有时候也可以使用转义字符来避免出错。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Let&#x27;s go&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;HelloWorld&#x27;</span>)</span><br></pre></td></tr></table></figure><p>3. 转义字符</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">r&quot;D:\three\two\one&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;D:\\three\\two\\one&quot;</span>)</span><br></pre></td></tr></table></figure><p> 第一行代码，在前面加上 r，可以使后面的所有转义字符失效。第二行则是转义 &quot;\&quot;。<br> 为了避免歧义，有时候我们需要使用转义字符来转义一些东西。<br>4. 拼接和复制</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;520&quot;</span> + <span class="string">&quot;1314&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我爱你\n&quot;</span>*<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p> 字符串的加法是拼接，字符串的乘法是复制。</p><h4 id="用py做第一个小游戏"><a class="markdownIt-Anchor" href="#用py做第一个小游戏">#</a> 用 py 做第一个小游戏</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用py设计的第一个小游戏</span></span><br><span class="line"></span><br><span class="line">counts = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> counts &gt; <span class="number">0</span>:</span><br><span class="line">    temp = <span class="built_in">input</span>(<span class="string">&quot;不妨猜一下我心中的所想的是那个数字：&quot;</span>)</span><br><span class="line">    guess = <span class="built_in">int</span>(temp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> guess == <span class="number">8</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;你是我肚子里的蛔虫么？&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;就算你猜中了也没有奖励&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> guess &lt; <span class="number">8</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;你的有点小&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;你的太大了&quot;</span>)</span><br><span class="line">        counts = counts - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;游戏结束！&quot;</span>)</span><br></pre></td></tr></table></figure><p>1.break 语句：跳出一层循环。<br>2. 记得加上 “：”。</p><h4 id="random"><a class="markdownIt-Anchor" href="#random">#</a> random</h4><p> 1.random 是 py 自带的伪随机数生成模块，特别的方便，如果是用其他语言进行编写的话，需要写的代码可就多了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random <span class="comment">#导入伪随机数模块</span></span><br><span class="line">random.randint(<span class="number">1</span>,<span class="number">10</span>) <span class="comment">#生成1-10的随机数</span></span><br></pre></td></tr></table></figure><p>2. 将伪随机数添加到小游戏中</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">counts = <span class="number">3</span></span><br><span class="line">x = random.randint(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> counts &gt; <span class="number">0</span>:</span><br><span class="line">    temp = <span class="built_in">input</span>(<span class="string">&quot;不妨猜一下我心中的所想的是那个数字：&quot;</span>)</span><br><span class="line">    guess = <span class="built_in">int</span>(temp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> guess == x:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;你是我肚子里的蛔虫么？&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;就算你猜中了也没有奖励&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> guess &lt; x:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;你的有点小&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;你的太大了&quot;</span>)</span><br><span class="line">        counts = counts - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;游戏结束！&quot;</span>)</span><br></pre></td></tr></table></figure><p>3. 伪随机数重现<br> random 生成的伪随机数根据当前操作系统的时间，可以被重现。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">x = random.getstate()</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">random.randint(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">random.randint(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">random.randint(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">random.setstate(x)</span><br><span class="line">random.randint(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">random.randint(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">random.randint(<span class="number">1</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p> 我们通过获取伪随机数的种子就可以重现伪随机数。</p><h4 id="数字类型"><a class="markdownIt-Anchor" href="#数字类型">#</a> 数字类型</h4><p>1. 整数<br> 整数的长度不受限制，有无限大的精度，所以能随时进行大数运算。<br>2. 浮点数<br> 浮点数采用 IEEE754 标准，在运算的时候和实例有时会不相同。就比如 0.1 + 0.2，在现实中等于 0.3，但是 py 运算的结果是 0.30000000000000004。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import decimal</span><br><span class="line">a = decimal.Decimal(&#x27;0.1&#x27;)</span><br><span class="line">b = decimal.Decimal(&#x27;0.2&#x27;)</span><br><span class="line">print(a + b)</span><br></pre></td></tr></table></figure><p> 但是我们可以采用 decimal 模块将结果更精确的运算出来。<br>3. 复数的表示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = 1 + 2j</span><br><span class="line">x.real</span><br><span class="line">x.imag</span><br></pre></td></tr></table></figure><p> 复数有实部和虚部，我们可以用 x.real 获取它的实部，用 x.imag 获取它的虚部。</p><h4 id="一些运算操作"><a class="markdownIt-Anchor" href="#一些运算操作">#</a> 一些运算操作</h4><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220701102223.png" alt=""><br> 一些比较常用的运算以及函数。</p><h4 id="布尔类型"><a class="markdownIt-Anchor" href="#布尔类型">#</a> 布尔类型</h4><p>1. 定义为 False 的对象：<br>（1）False 和 None<br>（2）值为 0 的数字类型：0,  0.0,  0j,Decimal（0），Fraction（0,1）。<br>（3）空的序列和集合：’’,  [],  (),  {},  set (),  range (0)。<br>2. 逻辑运算<br> 与或非，老生常谈，没啥可讲。<br> 唯一需要了解的是短路逻辑和运算符优先级。<br> 短路逻辑的核心思想就是：从左往右，只有当第一个操作数的值无法确定逻辑运算的结果时，才对第二个操作数进行求值。<br> 运算符有优先级，所以在遇到实际情况时该添加括号就添加括号。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>program Interaction的C前解题记录</title>
      <link href="/2022/06/25/pwncollege%E7%9A%84%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/"/>
      <url>/2022/06/25/pwncollege%E7%9A%84%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="program-interaction的c前解题记录"><a class="markdownIt-Anchor" href="#program-interaction的c前解题记录">#</a> program Interaction 的 C 前解题记录</h1><p>做题之前在终端输入：ssh -i key hacker@dojo.pwn.college，打开做题环境。</p><h3 id="11-3关"><a class="markdownIt-Anchor" href="#11-3关">#</a> 1.1-3 关</h3><p>前三关是密码传参。基本操作就是进入 challenge 文件夹，然后运行文件夹下的 embryoio_level，第一关没有密码，第二关程序运行后输入密码，第三关 embryoio_level + 密码，然后运行。密码都在提示中写了。</p><h3 id="2level47环境变量"><a class="markdownIt-Anchor" href="#2level47环境变量">#</a> 2.level4,7：环境变量</h3><p>主要就是使用指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">env -i &lt;program&gt;</span><br><span class="line">env -i NAME1=VALUE1 NAME2=VALUE2 </span><br><span class="line">//env -i ....=....  命令行（不用加括号）</span><br><span class="line">env -i ./embryoio_level7（设置空环境变量）</span><br></pre></td></tr></table></figure><p><command-line>使用指定的环境变量执行命令行<br> env -i …=…  命令行（不用加括号）<br>4 要求新增一个环境变量，7 要求设置一个空环境变量。</p><h3 id="3level56重定向"><a class="markdownIt-Anchor" href="#3level56重定向">#</a> 3.level5,6: 重定向</h3><p>5：重定向输入 : ./embryoio_level5 &lt;/tmp/mqetmb<br>6：重定向输出 : ./embryoio_level5 &gt;/tmp/mqetmb<br>5 题 vim 指定文件随便输入值，然后重定向，会提示输入某值替换掉你输入的值，然后再运行得出答案。<br>6 题 vim 指定文件随便输入值，然后重定向，再 vim 指定文件，答案就在文件中。</p><h3 id="48-14shell脚本"><a class="markdownIt-Anchor" href="#48-14shell脚本">#</a> 4.8-14：shell 脚本</h3><p>8：vim /tmp/my_script.sh 创建 shell 脚本，然后输入 /challenge/embryoio_level8 保存退出，再 bash /tmp/my_script.sh 运行脚本，得出答案。<br>14: 设置空环境变量并创建运行 shell 脚本，需要在脚本中写上：env -i /challenge/embryoio_level14。</p><h3 id="515-21ipython"><a class="markdownIt-Anchor" href="#515-21ipython">#</a> 5.15-21：ipython</h3><p>15：ipython 进入，然后使用下面这个指令运行程序。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess;subprocess.run([&quot;./embryoio_level15&quot;])</span><br></pre></td></tr></table></figure><p>16：要求输入密码<br> 17：要求传参，使用以下指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess;subprocess.run([&quot;./embryoio_level17&quot;,&quot;ianqniorrn&quot;])</span><br></pre></td></tr></table></figure><p>18：要求设置环境变量。使用以下指令。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess;subprocess.run([&quot;./embryoio_level18&quot;],env=&#123;&quot;yclqvl&quot;:&quot;gqfnjtrdva&quot;&#125;)</span><br></pre></td></tr></table></figure><p>19：要求重定向输入。使用以下指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">file = &#x27;/challenge/embryoio_level19&#x27;</span><br><span class="line">infile = open(&#x27;/tmp/...&#x27;)</span><br><span class="line">io = process(file,stdin=infile)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>20: 要求重定向输出。使用以下指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">file = &#x27;/challenge/embryoio_level20&#x27;</span><br><span class="line">outfile = open(&#x27;/tmp/...&#x27;,&#x27;a+&#x27;)</span><br><span class="line">io = process(file,stdout=outfile)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>21：设置空环境变量，需要以下指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess;subprocess.run([&quot;./embryoio_level21&quot;],env=&#123;&#125;)</span><br></pre></td></tr></table></figure><p> 以上指令也恰好差不多是 python 关卡的解题指令，所以说我在思考这些题的时候也把 python 给做完了，可能也是因为这些本来就很相似吧。</p><h3 id="622-28python"><a class="markdownIt-Anchor" href="#622-28python">#</a> 6.22-28:python</h3><p> python 做题的基本套路是 vim /tmp/my_script.py, 然后 python /tmp/my_script.py 运行即可。</p><p>22：要求创建并运行 python 文件，指令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">subprocess.run([&quot;./embryoio_level22&quot;])</span><br></pre></td></tr></table></figure><p>23：要求输入密码，和上题一样，运行之后在输入密码就行了。<br>24：要求传参，指令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">subprocess.run([&quot;./embryoio_level24&quot;,&quot;参数&quot;])</span><br></pre></td></tr></table></figure><p>25：要求设置环境变量，指令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">subprocess.run([&quot;./embryoio_level25&quot;],env=&#123;&quot;.....&quot;:&quot;....&quot;&#125;)</span><br></pre></td></tr></table></figure><p>26：要求输入重定向，指令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">file=&#x27;/challenge/embryoio_level26&#x27;</span><br><span class="line">infile=open(&#x27;/tmp/qxyfzu&#x27;)</span><br><span class="line">subprocess.run(file,stdin=infile)</span><br></pre></td></tr></table></figure><p>27：要求输出重定向，指令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">file=&#x27;/challenge/embryoio_level27&#x27;</span><br><span class="line">outfile=open(&#x27;/tmp/ayibsk&#x27;,&#x27;a+&#x27;)</span><br><span class="line">subprocess.run(file,stdout=outfile)</span><br></pre></td></tr></table></figure><p>28：要求设置空环境变量，指令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">subprocess.run([&quot;./embryoio_level28&quot;],env=&#123;&#125;)</span><br></pre></td></tr></table></figure><p> c 语言之前的关卡就已经打完了，对于很多指令代码我还都是一知半解的状态，特别是 python 这一块，我应该好好学一下。</p><h3 id="7python-file方法"><a class="markdownIt-Anchor" href="#7python-file方法">#</a> 7.python File 方法</h3><p> Python open () 方法用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。<br> ** 注意：** 使用 open () 方法一定要保证关闭文件对象，即调用 close () 方法。open () 函数常用形式是接收两个参数：文件名 (file) 和模式 (mode)。<br> 完整的语法是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open(file, mode=&#x27;r&#x27;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</span><br></pre></td></tr></table></figure><p>参数说明：<br>（1）file: 必需，文件路径（相对或者绝对路径）。<br>（2）mode: 可选，文件打开模式。<br>mode 参数有：</p><table><thead><tr><th style="text-align:left">模式</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">t</td><td style="text-align:left">文本模式 (默认)。</td></tr><tr><td style="text-align:left">x</td><td style="text-align:left">写模式，新建一个文件，如果该文件已存在则会报错。</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">二进制模式。</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">打开一个文件进行更新 (可读可写)。</td></tr><tr><td style="text-align:left">U</td><td style="text-align:left">通用换行模式（不推荐）。</td></tr><tr><td style="text-align:left">r</td><td style="text-align:left">以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr><td style="text-align:left">rb</td><td style="text-align:left">以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td></tr><tr><td style="text-align:left">r+</td><td style="text-align:left">打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td style="text-align:left">rb+</td><td style="text-align:left">以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td></tr><tr><td style="text-align:left">w</td><td style="text-align:left">打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td style="text-align:left">wb</td><td style="text-align:left">以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td style="text-align:left">w+</td><td style="text-align:left">打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td style="text-align:left">wb+</td><td style="text-align:left">以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td style="text-align:left">a</td><td style="text-align:left">打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td style="text-align:left">ab</td><td style="text-align:left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td style="text-align:left">a+</td><td style="text-align:left">打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr><td style="text-align:left">ab+</td><td style="text-align:left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> pwncolloge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滴水逆向：C语言（一）</title>
      <link href="/2022/06/24/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91%EF%BC%9AC%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/06/24/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91%EF%BC%9AC%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1c语言函数调用的基本流程"><a class="markdownIt-Anchor" href="#1c语言函数调用的基本流程">#</a> 1.c 语言函数调用的基本流程</h2><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220624090352079.png" alt=""><br> 在程序调用时，大致是按照这样的流程进行的，开栈也就是保存栈底，为缓冲区填充过数据之后，就开始进行我们函数所要干的事情，函数做的事情结束后，需要恢复现场，和开栈的顺序是相反的，然后降低堆栈，最后返回，一般返回之后会进行平栈，有的是外平栈，有的是内平栈。</p><h2 id="2c语言是怎样变成汇编的"><a class="markdownIt-Anchor" href="#2c语言是怎样变成汇编的">#</a> 2.c 语言是怎样变成汇编的？</h2><p>（1) 裸函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void __declspec(naked) Function()</span><br><span class="line">&#123;...&#125;</span><br><span class="line"></span><br><span class="line">void __declspec(naked) Function()  </span><br><span class="line">&#123;</span><br><span class="line">__asm ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 和正常的函数不同，裸函数生成汇编时啥也没有，所以要你自己添东西，正常函数还会生成一堆东西，防止出错。裸函数要自己添加一个 ret 返回，否则会报错。<br>（2) 调用约定</p><table><thead><tr><th>调用约定</th><th>参数压栈顺序</th><th>平衡堆栈</th></tr></thead><tbody><tr><td>__cdecl</td><td>从右至左入栈</td><td>调用者清理栈</td></tr><tr><td>__stdcall</td><td>从右至左入栈</td><td>自身清理堆栈</td></tr><tr><td>__fastcall</td><td>ECX/EDX 传送前两个剩下：从右至左入栈</td><td>自身清理堆栈</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eg:void __cdecl sum&#123;...&#125;</span><br></pre></td></tr></table></figure><p> 从右至左入栈就是设定的参数从右边往左边依次压栈，调用者清理堆栈就是外平栈，自身清理堆栈就是内平栈，__ fastcall 设定不多于两个参数时，用寄存器传参，这样比用内存传参更快，当设定参数过多时，多出的参数依然用内存传，也就是 PUSH，但是这样的话，快速传参的意义就消失了，所以使用__fastcall 时一般不设置那么多参数。</p><h2 id="3c语言中的数据类型"><a class="markdownIt-Anchor" href="#3c语言中的数据类型">#</a> 3.c 语言中的数据类型</h2><p>（1）数据类型<br> 基本类型：整数类型、浮点类型。<br> 构造类型：数组、结构体、共用体。<br> 指针类型。<br> 空类型。<br>（2）学习数据类型的要素<br> 存储数据的宽度<br> 存储数据的格式<br> 作用范围 (作用域)<br>（3）整数类型：char    short    int    long</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char    8BIT   1字节</span><br><span class="line">short   16BIT  2字节</span><br><span class="line">int     32BIT  4字节</span><br><span class="line">long    32BIT  4字节</span><br></pre></td></tr></table></figure><p>（4）有无符号数<br> 默认的数据类型都是有符号数，如果定义无符号数需要在开头加上 unsigned，计算机对于有无符号数的存储都是相同的。<br>（5）浮点类型<br> float 和 double 在存储方式上都是遵从 IEEE 的规范的。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220625215456.png" alt=""><br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220625215548.png" alt=""></p><p>将一个 float 型转化为内存存储格式的步骤为：<br> a. 先将这个实数的绝对值化为二进制格式<br> b. 将这个二进制格式实数的小数点左移或右移 n 位，直到小数点移动到第一个有效数字的右边。<br> c. 从小数点右边第一位开始数出二十三位数字放入第 22 到第 0 位。<br> d. 如果实数是正的，则在第 31 位放入 “0”，否则放入 “1”。<br> e. 如果 n 是左移得到的，说明指数是正的，第 30 位放入 “1”。如果 n 是右移得到的或 n=0，则第 30 位放入 “0”。<br> f. 如果 n 是左移得到的，则将 n 减去 1 后化为二进制，并在左边加 “0” 补足七位，放入第 29 到第 23 位。如果 n 是右移得到的或 n=0，则将 n 化为二进制后在左边加 “0” 补足七位，再各位求反，再放入第 29 到第 23 位。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220626001447.png" alt=""></p><h2 id="4程序的真正入口"><a class="markdownIt-Anchor" href="#4程序的真正入口">#</a> 4. 程序的真正入口</h2><p>（1） main 或 WinMain  是 “语法规定的用户入口”，而不是 “应用程序入口”。应用程序入口通常是启动函数。<br>（2） mainCRTStartup 和  wmainCRTStartup 是控制台环境下多字节编码和 Unicode 编码的启动函数。而 WinMainCRTStartup  和 wWinMainCRTStartup 是 windows 环境下多字节编码和 Unicode 编码的启动函数.<br>（3）main 函数的识别:<br>main  函数被调用前要先调用的函数如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GetVersion() </span><br><span class="line">_heap_init() </span><br><span class="line">GetCommandLineA() </span><br><span class="line">_crtGetEnvironmentStringsA() </span><br><span class="line">_setargv()</span><br><span class="line">_setenvp()</span><br><span class="line">_cinit()</span><br></pre></td></tr></table></figure><p> 这些函数调用结束后就会调用 main 函数。根据 main 调用参数的特征就可以找到函数的入口。</p><h2 id="5ascii编码和中文编码"><a class="markdownIt-Anchor" href="#5ascii编码和中文编码">#</a> 5.ASCII 编码和中文编码</h2><p>（1）ASCII 编码：<br> a.ASCII 码使用指定的 7 位或  8 位二进制数组合来表示 128 或 256 种可能的字符。<br> b. 标准 ASCII 码使用 7  位二进制数来表示所有的大写和小写字母，数字 0 到 9、标点符号，以及在美式英语中使用的特殊控制字符。<br> c. 扩展 ASCII  码允许将每个字符的第 8 位用于确定附加的 128 个特殊符号字符、外来语字母和图形符号。<br> 一般我们使用的都是标准的 ASCII 编码表，因为已经够用了。<br>（2）GB2312 和 GB2312-80<br> 这些编码设计视为了能够显示中文，用于将汉字转为计算机可以接受的数字系统的数。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220625235637.png" alt=""><br> 从图中可以看出一个汉字用两个 ASCII 码表示，这样可以将所表示的量大大增加，可以组合大约 7000 多个汉字。</p>]]></content>
      
      
      <categories>
          
          <category> 逆向学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯云+PicGo搭建图床</title>
      <link href="/2022/06/24/%E8%85%BE%E8%AE%AF%E4%BA%91-PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"/>
      <url>/2022/06/24/%E8%85%BE%E8%AE%AF%E4%BA%91-PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> 前段时间 github 博客崩了好长时间，好在后来又恢复了，但是我搭建的图床彻底崩了，图片上传不上，因为是用 github+picx 搭建的图床，不稳定也是在意料之内，索性用腾讯云更安稳一些。</p><h1 id="1腾讯云创建存储桶"><a class="markdownIt-Anchor" href="#1腾讯云创建存储桶">#</a> 1. 腾讯云创建存储桶</h1><p> 先注册个账号，然后在云产品中找到它的对象存储服务。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220624173311.png" alt=""><br> 云产品在页面左上，进入对象存储。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220624173620.png" alt=""><br> 点击创建存储桶<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220624173831.png" alt=""><br> 输入名称，不做啥要求，只不过这个是你的域名的一部分。访问权限一定要选公有读私有写，否则你上传的图片无法使用。默认警告可以打开，内容安全闭掉，然后下一步。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220624174051.png" alt=""><br> 直接下一步即可。确认配置也是直接过就行。</p><h1 id="2设置密钥"><a class="markdownIt-Anchor" href="#2设置密钥">#</a> 2. 设置密钥</h1><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220624180103.png" alt=""><br> 密钥管理 -&gt; 访问密钥<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220624183646.png" alt=""><br> API 密钥管理 -&gt; 新建密钥</p><h1 id="3下载picgo"><a class="markdownIt-Anchor" href="#3下载picgo">#</a> 3. 下载 PicGo</h1><p>下载 PicGo 地址：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/Molunerfinn/PicGo/releases</span><br></pre></td></tr></table></figure><p> 建议挂一个代理，或者网上找网盘资源，现在 github 下个东西真是太难了。<br> 下载好之后打开。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220624175241.png" alt=""><br> 在图床设置 -&gt; 腾讯云 COS 中，先设置前三个选项，前三个选项其实就是你设置的密钥了，除此之外 COS 版本选 v5。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220624180601.png" alt=""></p><p> 接着设置存储空间名、存储区域、自定义域名。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220624180939.png" alt=""><br> 存储桶列表 -&gt; 点击存储桶名称 -&gt; 概览，就能找到上图这个界面，然后根据信息完善你的设置，注意存储区域写的是你的所属地域后面括号里的内容。都设置好之后保存，然后开始测试能否上传图片。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220624181444.png" alt=""><br> 上传区上传一张图片，然后在相册中查看你上传的图片。可以复制一下网址在浏览器打开，能打开说明你的图床已经配置好了。</p><h1 id="4壁纸"><a class="markdownIt-Anchor" href="#4壁纸">#</a> 4. 壁纸</h1><p> 最后推荐一个肥肠好用的壁纸网站：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wall.alphacoders.com</span><br></pre></td></tr></table></figure><p> 不管是写博客用，还是主题用，或者电脑用，都力荐！</p>]]></content>
      
      
      <categories>
          
          <category> 图床搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reverse的wp</title>
      <link href="/2022/06/18/reverse%E7%9A%84wp/"/>
      <url>/2022/06/18/reverse%E7%9A%84wp/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-bobs-code"><a class="markdownIt-Anchor" href="#一-bobs-code">#</a> 一、Bob‘s Code</h1><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618164821624.png" alt=""><br> 首先，1 是给定的字符串，然后我们看 2 和 3，这两个都属于 base64 解密，但是其中一个 base 换了表。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618165248386.png" alt=""><br> 再看 4,4 的作用是将字符串的开头和结尾加上一个 &quot;.&quot;。</p><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618165639761.png" alt=""><br> 然后观察第 5 个函数，这个函数是一个爆破，可以写一个脚本逆一下。也就是遍历字符串对应的 ascII 可见字符串。<br>逆过来后是这样的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.U1ZorfEzdEZomVZkTXPOb.U5TmVLHaKP6VLZvmK5DmDBsaKUwULdZnVLYmD0.</span><br></pre></td></tr></table></figure><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618165521925.png" alt=""><br> 然后将逆过来的字符串去点，再进行 base 解码和换表解码。<br> base64 换表网上找的脚本可以用一下，然后正常的 base64 解码找个网站解。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import base64</span><br><span class="line">import string</span><br><span class="line">str1 = &quot;U1ZorfEzdEZomVZkTXPOb.U5TmVLHaKP6VLZvmK5DmDBsaKUwULdZnVLYmD0====&quot;</span><br><span class="line">string1 = &quot;ABCDEfghijklmnopqrsTUVWXYZabcdeFGHIJKLMNOPQRStuvwxyz0123456789-_&quot;</span><br><span class="line">string2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span><br><span class="line">print (base64.b64decode(str1.translate(str.maketrans(string1,string2))))</span><br></pre></td></tr></table></figure><p E7UI38f5-Xj2sUZ64-4F14Ef9a=""> Flag：ISCC</p><h1 id="二-经典base"><a class="markdownIt-Anchor" href="#二-经典base">#</a> 二、经典 base</h1><p gA6JawpVMZdVL=""><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618160430174.png" alt=""><br> 根据下面那一串字符可以知道这是 base58, 编码，把上面那串字符找一个网站拖进去就可以解出来。<br> Flag：ISCC</p><h1 id="三-经典re1用x64dbug进行调试"><a class="markdownIt-Anchor" href="#三-经典re1用x64dbug进行调试">#</a> 三、经典 re1（用 x64Dbug 进行调试)</h1><p> 拖进 IDA 中无法搜到字符串，也不能看到 mian 函数的伪代码，那就拖到 x64Dbug 中调试。运行一下程序，然后直接搜索字符串。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618184409092.png" alt=""></p><h1 id="四-手动脱壳"><a class="markdownIt-Anchor" href="#四-手动脱壳">#</a> 四、手动脱壳</h1><p> 将修狗程序拖入 ollyDbug。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618200250285.png" alt=""><br> F8 运行一步，可以看到 ESP 发生变化，然后右键。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618200328565.png" alt=""><br> 选择数据窗口跟随。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618200427735.png" alt=""><br> 选择硬件写入，然后 shift+f9<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618200528957.png" alt=""><br> F8 运行几步，在 jnz 这里的下面设置一个断点，f4 执行跳过 jnz，因为 jnz 是往上跳转的，所以要跳过这里。然后执行完 jmp 来到一个新的入口。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618200817646.png" alt=""><br> 右键选择用 OllyDump 脱壳调试进程。</p><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618203916051.png" alt=""><br> 先点获取 EIP 作为 OEP，然后再点脱壳进行保存。<br> 保存的文件再用 IDA 打开就可以发现 flag 了。</p><h1 id="五-squid"><a class="markdownIt-Anchor" href="#五-squid">#</a> 五、squid</h1><p>用 IDA 打开程序，发现很多 py，可以确定这是和 python 反编译有关。<br><a href="http://xn--pyinstxtractor-9v1wl125b.py">使用 pyinstxtractor.py</a>，将文件拖入文件夹，使用以下指令，可以分出一些文件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objcopy --dump-section pydata=pydata.dump</span><br><span class="line">python pyinstxtractor.py &lt;filename&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 逆向学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆栈图</title>
      <link href="/2022/06/18/%E5%A0%86%E6%A0%88%E5%9B%BE/"/>
      <url>/2022/06/18/%E5%A0%86%E6%A0%88%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一、堆栈图<br> 1.Windows 堆栈的特点<br> （1）先进后出<br> （2）向低地址扩展<br> Windows 中的堆栈，是一块普通的内存，主要用来存储一些临时的数据和参数等可以把 Windows 中的堆栈想象成是一个公用的书箱，函数就像是使用箱子的人函数在执行的时候，会用到这个书箱，把一些数据存到里面，但用完的时候一定要记得把书拿走，否则会乱的，也就是说，你放进去几本书，走的时候也要拿走几本书，这个就是堆栈平衡。<br>2. 函数<br> 计算机的函数，是一个固定的一个程序段，或称其为一个子程序，它在可以实现固定运算功能的同时还带有一入口和一个出口，所谓的入口，就是函数所带的各个参数，我们可以通过这个入口，把函数的参数值代入子程序，供计算机处理，所谓出口，就是指函数的计算结果，也称为返回值，在计算机求得之后，由此口带回给调用它的程序。<br>3. 汇编中的函数<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618144251704.png" alt=""><br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618144323907.png" alt=""><br> 4. 常见的操作<br>（1）CALL 指令压入栈的地址我们称作函数执行完之后的返回地址。在 OD 里面画堆栈图执行 call 函数按 F7。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220608124647230.png" alt=""></p><p>（2）这条指令的作用是将 EBP-40 的地址取出放入 EDI 寄存器中。</p><p>（3）<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220608130217339.png" alt=""><br> 这三条指令的作用是防止缓冲区溢出。</p><p>（4）<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220608131538958.png" alt=""><br> 恢复现场。<br> 堆栈平衡：调用函数前后堆栈没有变化<br>（5) return 指令相当于 pop eip<br> 二、画堆栈图<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618152056355.png" alt=""><br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618152152522.png" alt=""><br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618152243776.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 逆向学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滴水逆向（二）</title>
      <link href="/2022/06/07/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/06/07/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-jcc"><a class="markdownIt-Anchor" href="#一-jcc">#</a> 一、JCC</h1><p>1.JMP 指令<br> JMP 指令的作用就是修改 EIP 寄存器的值，MOV 指令不能用来修改 EIP。<br> 简写为：JMP    寄存器 / 立即数<br> 2.CALL 指令<br> PUSH   地址 B<br> 简写为：CALL  地址 A / 寄存器<br>两者的区别：JMP 只修改 EIP，CALL 指令将程序运行的下一行地址 PUSH 堆栈中，再修改 EIP。<br>需要注意：CALL 和 ret 指令一般同时出现，CALL 结束之后，再 ret 返回。<br>3.ESP 寄存器<br> ESP 寄存器就是栈指针寄存器，存储堆栈使用到的地址。<br>4.EIP 寄存器<br> EIP 存储程序运行到的位置。JMP 指令和 CALL 指令就是用来修改 EIP 的指令。<br>5.PUSH 和 POP（压栈和出栈）<br>（1）PUSH 指令<br> 将数据压入栈中。<br>（2）POP 指令<br> 将数据</p><p>6.CMP 指令</p><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220607205200559.png" alt=""></p><p> CMP 指令操作和 SUB 指令相当，但是它不会将结果保存，而是只会修改标志寄存器的值。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220607205342455.png" alt=""></p><p> TEST 指令与 CMP 指令同理。<br>7.JCC<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220607205439657.png" alt=""><br><img src="C:%5CUsers%5Ca%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220607205500689.png" alt="image-20220607205500689"><br> JCC 指令就是 JMP 指令，只不过在执行前增加了一个判断条件，并且也只会修改 EIP 寄存器的值。比如：JE 指令执行时，首先判断 ZF 位是否为 1，为 1 则执行，不为 1 则不执行。JNE 和 JE 的判断条件相反。</p>]]></content>
      
      
      <categories>
          
          <category> 逆向学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现base64编码</title>
      <link href="/2022/04/27/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0base64%E7%BC%96%E7%A0%81/"/>
      <url>/2022/04/27/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0base64%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求">#</a> 题目要求</h1><p> 使用 c/c++ 完成以下下算法:<br> 输入一个字符串，检查该字符串总 ascii 码值。如果值大于 1000 则对该字符串进行 base64 加密输出，否则该字符串与 base64 编码表进行异或输出。<br> 说实话我的 c 语言能力真的弱，这道题看着这么简单，实际上实现起来很有难度。这道题目主要是这几个部分：1. 检测字符串 ASCII 码值；2.base64 编码；3. 将字符串与 base64 编码表异或。</p><h2 id="一-检测字符串的ascii码值"><a class="markdownIt-Anchor" href="#一-检测字符串的ascii码值">#</a> 一、检测字符串的 ASCII 码值</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; chuanchuan[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        n=chuanchuan[i];</span><br><span class="line">        sum = sum +n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你的串串的长度是：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br></pre></td></tr></table></figure><p> 这段代码实现起来十分简单，使用 for 循环就可以了，采用累加的方式将所得单个字符的 ASCII 码值相加，最后得到总的 ASCII 码值。</p><h2 id="二-实现base64编码"><a class="markdownIt-Anchor" href="#二-实现base64编码">#</a> 二、实现 base64 编码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">base64</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *chuanchuan)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *base64laobiao = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line">    <span class="keyword">long</span> changdu = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *res;</span><br><span class="line">     changdu= <span class="built_in">strlen</span>(chuanchuan);</span><br><span class="line">     <span class="keyword">if</span>(changdu%<span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        len = changdu/<span class="number">3</span>*<span class="number">4</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        len = (changdu/<span class="number">3</span>+<span class="number">1</span>)*<span class="number">4</span>;</span><br><span class="line">     res = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>)*len + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//malloc()函数在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。</span></span><br><span class="line">     res[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">     <span class="keyword">int</span> i,j;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;=len<span class="number">-1</span>;j+=<span class="number">3</span>,i+=<span class="number">4</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         res[i] = base64laobiao[chuanchuan[j]&gt;&gt;<span class="number">2</span>];</span><br><span class="line">         res[i+<span class="number">1</span>] = base64laobiao[(chuanchuan[j]&amp; <span class="number">0x3</span>)&lt;&lt;<span class="number">4</span> | (chuanchuan[j+<span class="number">1</span>]&gt;&gt;<span class="number">4</span>)];</span><br><span class="line">         res[i+<span class="number">2</span>] = base64laobiao [(chuanchuan[j+<span class="number">1</span>] &amp; <span class="number">0xf</span>)&lt;&lt;<span class="number">2</span> | (chuanchuan[j+<span class="number">2</span>])&gt;&gt;<span class="number">6</span>];</span><br><span class="line">         res[i+<span class="number">3</span>] = base64laobiao[chuanchuan[j+<span class="number">2</span>]&amp;<span class="number">0x3f</span>];</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//第一个字符的前6位</span></span><br><span class="line"><span class="comment">//第一个字符的后两位与第二个字符的前四位结合</span></span><br><span class="line"><span class="comment">//第二个字符的后四位与第三个字符的前两位结合</span></span><br><span class="line"><span class="comment">//第三个字符的六位</span></span><br><span class="line">     <span class="keyword">switch</span>(changdu%<span class="number">3</span>)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        res[i - <span class="number">2</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        res[i - <span class="number">1</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">             <span class="comment">//对剩余4位的补两个“=”</span></span><br><span class="line">     <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        res[i - <span class="number">1</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">             <span class="comment">//对剩余2位的补一个“=”</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 代码有借鉴别人的成分，只有我自己我可写不出来。<br> 主要难度就在于编码部分，下面附上 base64 编码的简单讲解。<br> Base64 编码，是我们程序开发中经常使用到的编码方法。它是一种基于用 64 个可打印字符来表示二进制数据的表示方法。它通常用作存储、传输一些二进制数据编码方法！</p><p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/base64%E7%BC%96%E7%A0%81%E8%A1%A8.3uee5rdheyi0.webp" alt="base64编码表"><br> base64 其实就是用 64 个可打印的字符去表示所有的二进制数，base64 的编码原理也很简单，假如给定三个字符：M a n，然后找到他们的各自对应的 ASCII 码值，然后将这些码值换算成十六进制，接着再都换算成二进制，然后对所有二进制数重新分割再组合，将最后组合成的二进制数再对照 base64 表编码。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2022-04-27-221311.76lhq8bfrck0.webp" alt="屏幕截图-2022-04-27-221311"><br> 每个字符占八位内存，但是 base64 编码每位占 6 位内存，所以在进行转换的时候，如果源码恰好是 3 的倍数，则可以恰好转换成 base64 编码，就比如上述所举的例子，M a n，对应 24 位内存，除以 6，是四位 base64 编码，所以一般来说，源码在进行编译之后，长度都会变长，如果是 3 的倍数，在编码过后的长度就是源码的 4/3 倍。<br> 但是，如果不是三的倍数的时候，进行编码的时候就会出现位数不足的情况，这种情况下，base64 另有一套解决方案，编码位数不足的时候补 0，并且还要满足凑出的位数是 8 的倍数，因为编码位数的特殊，所以剩余位数不是 2 位就是 4 位，因此当剩余二位的时候，补一个特殊的 6 位符号 “=”，当剩余 4 位的时候，补两个 “=”。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2022-04-27-223118.3x4yepw2t5m0.webp" alt="屏幕截图-2022-04-27-223118"></p><h3 id="三-实现字符串与base64异或运算"><a class="markdownIt-Anchor" href="#三-实现字符串与base64异或运算">#</a> 三、实现字符串与 base64 异或运算</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *n = chuanchuan;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你的串串太短了，接下来将你的串串和base64编码表进行异或：\n&quot;</span>);</span><br><span class="line">        <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; chuanchuan[i]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m= chuanchuan[i]^base64laobiao[i];</span><br><span class="line">            <span class="built_in">sprintf</span> (str, <span class="string">&quot;%c&quot;</span>, m);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, m);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p> 实现这段代码的时候用了好久，主要是没明白计算机怎样计算字符串之间的异或运算，我在尝试了一番之后，我认为的是计算机计算字符串的异或，字符串转十六进制，再异或，最后得到的结果类型可以是整形，我将整形转换成字符串类型，然后再输出。<br>结尾附上源代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _BASE64_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BASE64_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _BASE64_H</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">base64</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *chuanchuan)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">haoduan</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *chuanchuan)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *base64laobiao = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> chuanchuan[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你的串串：\n&quot;</span>);</span><br><span class="line">    gets(chuanchuan);</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; chuanchuan[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        n=chuanchuan[i];</span><br><span class="line">        sum = sum +n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你的串串的长度是：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">if</span>(sum&gt;<span class="number">1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;你的串串有点长，接下来进行base64加密：\n&quot;</span>);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, base64(chuanchuan));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> *n = chuanchuan;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你的串串太短了，接下来将你的串串和base64编码表进行异或：\n&quot;</span>);</span><br><span class="line">        <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; chuanchuan[i]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m= chuanchuan[i]^base64laobiao[i];</span><br><span class="line">            <span class="built_in">sprintf</span> (str, <span class="string">&quot;%c&quot;</span>, m);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">base64</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *chuanchuan)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *base64laobiao = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line">    <span class="keyword">long</span> changdu = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *res;</span><br><span class="line">     changdu= <span class="built_in">strlen</span>(chuanchuan);</span><br><span class="line">     <span class="keyword">if</span>(changdu%<span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        len = changdu/<span class="number">3</span>*<span class="number">4</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        len = (changdu/<span class="number">3</span>+<span class="number">1</span>)*<span class="number">4</span>;</span><br><span class="line">     res = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>)*len + <span class="number">1</span>);</span><br><span class="line">     res[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">     <span class="keyword">int</span> i,j;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;=len<span class="number">-1</span>;j+=<span class="number">3</span>,i+=<span class="number">4</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         res[i] = base64laobiao[chuanchuan[j]&gt;&gt;<span class="number">2</span>];</span><br><span class="line">         res[i+<span class="number">1</span>] = base64laobiao[(chuanchuan[j]&amp; <span class="number">0x3</span>)&lt;&lt;<span class="number">4</span> | (chuanchuan[j+<span class="number">1</span>]&gt;&gt;<span class="number">4</span>)];</span><br><span class="line">         res[i+<span class="number">2</span>] = base64laobiao [(chuanchuan[j+<span class="number">1</span>] &amp; <span class="number">0xf</span>)&lt;&lt;<span class="number">2</span> | (chuanchuan[j+<span class="number">2</span>])&gt;&gt;<span class="number">6</span>];</span><br><span class="line">         res[i+<span class="number">3</span>] = base64laobiao[chuanchuan[j+<span class="number">2</span>]&amp;<span class="number">0x3f</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">switch</span>(changdu%<span class="number">3</span>)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        res[i - <span class="number">2</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        res[i - <span class="number">1</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        res[i - <span class="number">1</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> c语言代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滴水逆向（一）</title>
      <link href="/2022/04/07/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/04/07/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据宽度与逻辑运算"><a class="markdownIt-Anchor" href="#数据宽度与逻辑运算">#</a> 数据宽度与逻辑运算</h1><p>  数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的制约，数据都是有长度限制的（我们称为超过最多宽度的数据会被丢弃，也就是说存不下的超出限制的那些数据直接被抛弃了、不存了）。</p><h2 id="一-数据宽度的表示"><a class="markdownIt-Anchor" href="#一-数据宽度的表示">#</a> 一、数据宽度的表示</h2><p>  1.4 位宽度表示：假设计算机只能存储 4 位 2 进制数<br>  存储无符号数，那么从 0 到 F，再往后还是从零开始。<br>  存储正数和负数，那么正数是 0,1,2,3,4,5,6,7（在计算机里把 0 看做正数），负数是 - 1，-2，-3，-4，-5，-6，-7，-8，对应 F,E，D，C，B，A,9,8, 并且，二进制数 1 开头的都是负数，0 开头的都是正数。<br><img src="https://img-blog.csdnimg.cn/7a6a3da130044aa18779a5f8098fab7b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGwyNjU1ODk0NTIw,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p>  2.8 位宽度表示：假设计算机只能存储 8 位 2 进制数<br><img src="https://img-blog.csdnimg.cn/995858070d7e41bb906a8caf8da0cd3d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGwyNjU1ODk0NTIw,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p>  3.16 位宽度表示：假设计算机只能存储 16 位 2 进制数<br><img src="https://img-blog.csdnimg.cn/508b17abfc7543e08520e3a45006008c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGwyNjU1ODk0NTIw,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p>  4.32 位宽度表示：假设计算机只能存储 32 位 2 进制数<br><img src="https://img-blog.csdnimg.cn/c1cf763a4c9c4825a90b5b9552722401.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGwyNjU1ODk0NTIw,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p>  注：有符号、无符号什么的都是自己定义的。</p><h2 id="二-几个重要的计量单位"><a class="markdownIt-Anchor" href="#二-几个重要的计量单位">#</a> 二、几个重要的计量单位</h2><p>  BYTE      字节       8BIT<br>  WORD     字        16BIT     2 字节<br>  DWORD   双字     32BIT    4 字节</p><h2 id="三-二进制的逻辑运算"><a class="markdownIt-Anchor" href="#三-二进制的逻辑运算">#</a> 三、二进制的逻辑运算</h2><p>  1. 逻辑运算：或（or    |  ）只要有一个为 1 就是 1<br><img src="https://img-blog.csdnimg.cn/fa4c890ad712426eb8f30f80d83ff1d6.png" alt=""></p><p>  在这个电路图中，只要有一个开关闭上，灯泡就亮，然后就为 1，所以或运算只要有一个为 1 就是 1。<br>  2. 逻辑运算：与（and   &amp;  ）两个都为 1 才是 1</p><p><img src="https://img-blog.csdnimg.cn/de08c7de76094741a3ab2c8cfa583484.png" alt=""><br>  在这个电路图中，两个开关都闭上才为 1，<br>  3. 逻辑运算：异或（xor   ^   ) 不一样为 1<br><img src="https://img-blog.csdnimg.cn/9cb90835a6b8498fb2ae16ff93591d47.png" alt=""></p><p>  4. 逻辑运算：非（not     ！ ）1 是 0    0 是 1<br><img src="https://img-blog.csdnimg.cn/514f8aa407ec406293b7341457a900b7.png" alt=""></p><h2 id="四-32位通用寄存器"><a class="markdownIt-Anchor" href="#四-32位通用寄存器">#</a> 四、32 位通用寄存器</h2><p>  32 位意思是能存 32 个 0 或 1，这些寄存器能存 0 到 8 个 F<br><img src="https://img-blog.csdnimg.cn/6de7862a41444a8ab9ae088556ab9059.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGwyNjU1ODk0NTIw,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""><br>  学好这些内容的前提要求：要把二进制与十六进制的映射记到无比熟练的地步。</p><h1 id="通用寄存器内存读写"><a class="markdownIt-Anchor" href="#通用寄存器内存读写">#</a> 通用寄存器 —— 内存读写</h1><p>一、通用寄存器<br><img src="https://img-blog.csdnimg.cn/086eebf3e7d140839772185aafe1193e.png" alt=""><br><img src="https://img-blog.csdnimg.cn/b690fa40ba664d44ad65c77560086800.png" alt=""></p><p>  32 位寄存器从中间分开，其中一半形成了 16 位寄存器，16 位寄存器前四个再从中间分开，形成 8 个 8 位的寄存器，并不是说 32 位、16 位、8 位寄存器是分开来算的，而是包含关系，我只需要 8 位，那就只用到 8 位，我需要 32 位的，那我就用到 32 位。<br>二、汇编代码<br>  所要学的内容：<br>  1.MOV 指令<br>  2.ADD 指令<br>  3.SUB 指令<br>  4.AND 指令<br>  5.OR 指令<br>  6.XOR 指令<br>  7.NOT 指令<br>  各指令所在网址：<a href="https://www.bcdaren.com/video/videoPlay/330285640321339392">https://www.bcdaren.com/video/videoPlay/330285640321339392</a><br>1.MOV 指令<br>  操作码 目标操作数  源操作数<br>  MOV   EAX，OxAAAAAAAA<br>  MOV   AX，OxBBBB<br>  MOV   AH,OxCC<br>  MOV   AL,OxDD</p><p>  MOV 的作用：拷贝源操作数到目标操作数（也就是将源操作数复制到目标操作数中）。<br>  （1）源操作数可以是立即数、通用寄存数、段寄存器、或者内存单元。<br>  （2）目标操作数可以是通用寄存器、段寄存器或者内存单元。<br>  （3）操作数的宽度必须一样。<br>  （4）源操作数和目标操作数不能同时为内存单元。<br>MOV 指令：<br><img src="https://img-blog.csdnimg.cn/6a6bdab14d8f43298ff514d68a628f51.png" alt=""><br>MOV 的语法：<br><img src="https://img-blog.csdnimg.cn/b92b0fe9d99f45f3bebdc74c18b0beb8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGwyNjU1ODk0NTIw,size_11,color_FFFFFF,t_70,g_se,x_16" alt=""><br>三、内存读写</p><p>1. 寄存器与内存的区别<br>  （1）寄存器位于 CPU 内部，执行速度快，但比较贵<br>  （2）内存速度相对较慢，但成本低，所以可以做的很大<br>  （3）寄存器和内存没有本质区别，都是用于存储数据的容器，都是定宽的（即都是有边界的）。<br>  （4）寄存器常用的有 8 个：EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI。<br>  （5）计算机中的几个常用计量单位：BYTE,WORD,DWORD。</p><p>  BYTE      字节    =   8BIT<br>  WORD     字     =  16（BIT）<br>  DWORD   双字     32（BIT）</p><p>  1KB = 1024BYTE<br>  1MB = 1024KB<br>  1GB = 1024MB</p><p>  2. 内存的数量特别庞大，无法每个内存单元都起一个名字，所以用编号来代替，我们称计算机 CPU 是 32 位或者 64 位，有很多书上说之所以叫 32 位计算机是因为寄存器的宽度是 32 位，是不准确的，因为还有很多寄存器是大于 32 位的。<br>计算机内存的每一个字节会有一个编号（即内存编号的单位是字节），如下图：</p><p>  3. 内存格式<br><img src="https://img-blog.csdnimg.cn/3b742423b1f14a70ae1653ed9ea4cb28.png" alt="">  只要涉及内存读写的，一定要指定它的宽度</p><p>  4. 从指定内存中写入 / 读取数据<br><img src="https://img-blog.csdnimg.cn/c0a68e95d5db47878e8e1f028244fa55.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGwyNjU1ODk0NTIw,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h1 id="内存地址堆栈"><a class="markdownIt-Anchor" href="#内存地址堆栈">#</a> 内存地址 —— 堆栈</h1><p>1. 关于 32 位、16 位、8 位通用寄存器<br>  这几个寄存器的关系可以说是包含的关系，32 位寄存器分为上位和下位的话，16 位寄存器就是 32 位寄存器的下位，这几个寄存器不是分开来算的，8 位寄存器发生变化，16 位、32 位寄存器也可能发生变化。</p><p>2. 寄存器的结构：EAX-AX-AH-AL 的对应关系</p><pre><code>这几个寄存器是包含关系</code></pre><p>3. 为什么 8 位寄存器只能存放 2 个十六进制的数？<br>  因为 8 位寄存器只能存 8 位，而一位的十六进制数对应四位二进制数，所以两个 16 进制数换算成 2 进制数正好占 8 位，</p><p>4. 内存单元：字节。<br>  每个字节有个编号，称为内存地址，一个字节等于 8 比特位，也就是一字节等于 8 位。<br>  每个编号对应一块内存，这个内存就是一个字节<br>  内存中的最小单元就是字节</p><pre><code>    内存单元的换算：    1GB=1024MB    1MB=1024KB    1KB=1024B    1B（字节）=8b yte（位）    BYTE      字节    =   8BIT          一个字节    WORD     字     =  16（BIT）   两个字节    DWORD   双字     32（BIT）    四个字节</code></pre><p>5. 数据窗口的使用、数据窗口与堆栈窗口的显示方式<br>反汇编窗口<br>  程序是怎么跑的，汇编的执行都在这个窗口<br><img src="https://img-blog.csdnimg.cn/d1224f538b7b4da1b0ee1803929d7107.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p-Q5Lq65LiN5Lya5pWy5Luj56CB,size_11,color_FFFFFF,t_70,g_se,x_16" alt=""><br>寄存器窗口<br>  8 位的、16 位的、32 位的寄存器都在这个窗口<br><img src="https://img-blog.csdnimg.cn/bd5a0f8d100642a9813275904da34768.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p-Q5Lq65LiN5Lya5pWy5Luj56CB,size_10,color_FFFFFF,t_70,g_se,x_16" alt=""> 堆栈窗口<br>   一个特殊的内存窗口<br>  这个窗口里面的编号是四个字节组成一组进行显示，四个字节换算一下就是 32 位<br><img src="https://img-blog.csdnimg.cn/22a31b34f6d248c69de62f8f9c41d97f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p-Q5Lq65LiN5Lya5pWy5Luj56CB,size_11,color_FFFFFF,t_70,g_se,x_16" alt=""><br>数据窗口<br>  在这个窗口可以了解数据<br><img src="https://img-blog.csdnimg.cn/b5851a587dc84aceb6ac74250c3297a0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p-Q5Lq65LiN5Lya5pWy5Luj56CB,size_12,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p>6. 寻址方式：<br>  寻址公式一：[立即数]<br>  读取内存的值：<br>  MOV EAX,DWORD  PTR  DS:[0x13FFC4]<br>  MOV EAX,DWORD  PTR  DS:[0x13FFC4]<br>  也就是将内存单元的数据给显示出来</p><pre><code>    向内存中写入数据：    MOV DWORD PTR DS:[0x13FFC4],eax    MOV DWORD PTR DS:[0x13FFC4],ebx    获取内存编号：    LEA EAX,DWORD PTR DS:[0X13FFC4]    LEA EAX,DWORD PTR DS:[ESP+8]    和读取内存的值不一样，这个是把内存单元的编号给显示出来的指令</code></pre><p>寻址公式二:[reg]<br>  注：reg 代表寄存器   可以是 8 个通用寄存器中的任意一个<br>  读取内存的值：<br>  MOV ECX,0x13FFD0<br>  MOV EAX,DWORD PTR DS:[ECX]<br>  把地址编号放到 ECX 这个寄存器里面，然后在通过这个寄存器找到内存，再放到 EAX 里面</p><pre><code>    向内存中写入数据：    MOV EDX,0x13FFD8    MOV DWORD PTR DS:[EDX],0x87654321    获取内存编号：    LEA EAX,DWORD PTR DS:[EDX]    MOV EAX,DWORD PTR DS:[EDX]</code></pre><p>寻址公式三:[reg + 立即数]<br>  读取内存的值:<br>  MOV ECX,0x13FFD0<br>  MOV EAX,DWORD PTR DS:[ECX+4]</p><pre><code>    向内存中写入数据:    MOV EDX,0x13FFD8    MOV DWORD PTR DS:[EDX+0xC],0x87654321    获取内存编号:    LEA EAX,DWORD PTR DS:[EDX+4]    MOV EAX,DWORD PTR DS:[EDX+4]</code></pre><p>寻址公式四:[reg+reg*{1,2,4,8}]<br>  读取内存的值<br>  MOV EAX,13FFC4<br>  MOV ECX,2<br>  MOV EDX,DWORD PTR DS:[EAX+ECX*4]<br>  注：1,2,4,8 是固定不变的，不要随意改</p><pre><code>    向内存中写入数据:    MOV EAX,13FFC4    MOV ECX,2    MOV DWORD PTR DS:[EAX+ECX*4],87654321    获取内存编号:    LEA EAX,DWORD PTR DS:[EAX+ECX*4]</code></pre><p>寻址公式五:[reg+reg*{1,2,4,8}+ 立即数]<br>  和寻址公式四同样的道理<br> 7. 堆栈</p><pre><code>    1.什么是堆栈    2.堆栈操作</code></pre><p>思考：<br>  假设我们需要一块内存，有如下的要求：<br>  1. 主要用于临时存储一些数据，如果数量很少就放到寄存器中<br>  2. 能够记录存了多少数据<br> 3. 能够非常快速的找到某个数据<br>那么堆栈的原理可以理解为：</p><pre><code>    1.BASE,TOP是2个32位的通用寄存器，里面存储的是内存单元编号（内存地址）    2.BASE里面存储了一个地址，记录的起始地址    3.TOP里面也存储了一个地址，记录的是结束的地址    4.存入数据的时候，TOP的值减4（为方便演示，每次存取都是4个字节）    5.释放数据的时候，TOP的值加4（为方便演示，每次存取都是4个字节）    6.如果要读取中间的某个数据的时候可以通过TOP或者BASE加上偏移的方式去读取    7.这个内存的读取方式有个学名：堆栈    堆栈的优点：临时存储大量的数据，便于查找。</code></pre><h1 id="标志寄存器"><a class="markdownIt-Anchor" href="#标志寄存器">#</a> 标志寄存器</h1><p>1.push 指令：<br>  PUSH r32<br>  PUSH r16<br>  PUSH m16<br>  PUSH m32<br>  PUSH imm8/imm16/imm32<br>2.POP 指令<br>  把堆栈里面的值取出来放到一个容器里<br>  POP r16<br>  POP r32<br>  POP m16<br>  POP m32<br>  PUSHAD、POPAD 这两个指令稍作了解即可<br> 3.EFLAGS 寄存器<br><img src="https://img-blog.csdnimg.cn/8cf8ce13d4d84ca89fb6898eb3455455.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p-Q5Lq65LiN5Lya5pWy5Luj56CB,size_14,color_FFFFFF,t_70,g_se,x_16" alt=""><br>  查看 DTDBUG 中的 EFLAGS 的值，然后转换成二进制的形式，并取出 CF/PF/AF/ZF/SF/OF 的值<br>记住这几个寄存器的位置和名称<br>  （1）进位标志 CF（Carry Flag）：如果运算结果的最高位产生了一个进位或借位，那么，其值为 1，否则其值为 0。<br>  MOV AL,0xEF<br>  MOV AL,0xFE<br>  ADD AL,2<br>  ADD AL,2<br>  （2）奇偶标志 PF（Parity Flag)：奇偶标志 PF 用于反映运算结果中 “1” 的个数的奇偶性。如果 “1” 的个数为偶数，则 PF 的值为 1，否则其值为 0。<br>  MOV AL,3<br>  MOV AL,3<br>  MOV AL,2</p><p>  （3）辅助进位标志 AF（Auxiliary Carry Flag）:<br> 在发生下列情况是，辅助进位标志 AF 的值被设置为 1，否则其值为 0：<br>  在字操作时，发生低字节向高字节进位或借位时；<br>  在字节操作时，发生低 4 位向高 4 位进位或借位时。<br>MOV EAX,0x55EEFFFF    MOV AX,5EFE    MOV AL,4E<br>ADD EAX,2         ADD AX,2      ADD AL,2</p><p>  （4）零标志 ZF（Zero Flag），零标志 ZF 用来反映运算是否为 0。如果运算结果为 0，则其值为 1，否则为 0。在判断运算结果是否为 0 时，可使用此标志位。<br>  XOR EAX,EAX<br>  MOV EAX,2<br>  SUB EAX,2<br>  （5）符号标志 SF（Sign Flag）：符号标志 SF 用来反映运算结果的符号位，它与运算结果的最高位相同。<br>  MOV AL,7F<br>  ADD AL,2</p><p>  （6）溢出标志 OF（Overflow Flag）：溢出标志 OF 用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF 的值被置为 1，否则，OF 的值被清为 0</p><p>4.ADC 指令：带进位加法<br>  格式：ADC  R/M,R/M/IMM   两边不能同时为内存   宽度要一样<br>  ADC AL,CL<br>  ADC BYTE PTR DS:[12FFC4],2<br>  ADC BYTE PTR DS:[12FFC4],AL</p><p>SBB 指令：带借位减法<br>  格式：SBB  R/M,R/M  两边不能同时为内存  宽度要一样<br>  SBB AL,CL<br>  SBB BYTE PTR DS:[12FFC4],2<br>  SBB BYTE PTR DS:[12FFC4],AL</p><p>XCHG 指令：交换数据<br>  格式：XCGH  R/M,R/M   两边不能同时为内存，宽度要一样<br>  XCGH AL,CL<br>  XCGH DWORD PTR DS:[12FFC4],EAX<br>  XCGH BYTE PTR DS:[12FFC4],AL</p><p>MOVS 指令：移动数据  内存 - 内存<br>  BYTE/WORD/DWORD<br>  MOVS BYTE PTR ES:[EDI],BYTE PTR DS:[ESI]  简写为：MOVSB<br>  MOVS WORD PTR ES:[EDI],BYTE PTR DS:[ESI]  简写为：MOVSW<br>  MOVS DWORD PTR ES:[EDI],BYTE PTR DS:[ESI] 简写为：MOVSD</p><p>5.STOS 指令：将 AI/AX/EAX 的值存储到 [EDI] 指定的内存单元<br>  STOS BYTE PTR ES:[EDI]   简写为 STOSB<br>  STOS WORD PTR ES:[EDI]   简写为 STOSW<br>  STOS DWORD PTR ES:[EDI]   简写为 STOSD</p><p>6.REP 指令：按计数寄存器（ECX）中指定的次数重复执行字符串指令<br>  MOV ECX,10<br>  REP MOVSD<br>  REP STOSD</p><p>本文图片取自我自己的 CSDN 博客的文章。</p>]]></content>
      
      
      <categories>
          
          <category> 逆向学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp datelab详解</title>
      <link href="/2022/04/05/csapp%20datelab%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/04/05/csapp%20datelab%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>  环境搭建用了我好久的时间，这个电脑我是真的服气，进入 vm 卡半天，刚搭建好的 Ubuntu 又遇到一些问题，直接寄了。没办法，只能再耗费一些时间重新搭建 Ubuntu， 结果又因为网卡，下载镜像就下了两天，搭建环境是真滴累。好在是经过一番努力终于将环境搞定，可以开始实验了。</p><h1 id="1bitxor"><a class="markdownIt-Anchor" href="#1bitxor">#</a> 1.bitXor</h1><p>  这道题的目的大致就是用于运算和非运算实现实现异或运算，难度还可以。  逻辑运算有三种基本运算：与、或、非，其他复杂的运算可以用这三种运算实现。</p><p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/1.363n09yqcnk0.webp" alt=""><br>  我推了几遍只推出一个公式，也就是 return (~x &amp; y)|(x &amp; ~y); 大致过程就是先画出真值表，然后推导公式，最后是画逻辑电路图，不过这一步就没必要了。但是这显然不符合题目要求，题目要求只用与和非，所以进一步推导的公式就是 return <sub>(</sub>x &amp; ~y) &amp; ~(x &amp; y); 后面这个式子我是从网上找的。</p><h1 id="2tmin"><a class="markdownIt-Anchor" href="#2tmin">#</a> <strong>2.tmin</strong></h1><p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/2.66yb55z398w0.webp" alt=""><br>  题目大致意思就是返回 32 位二进制补码的最小整数。<br>  首先要知道位移符的作用，对于一个 n 位的操作数 x，x&lt;&lt;k 操作会生成一个值：x 向左移动 k 位，丢弃最高的 k 位，并在右端补 k 个 0。位移量应该是一个 0~n-1 之间的值。计算机中的数都是用补码进行表示的，并且最高位是符号位，应用的运算系统是模运算。</p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/3.6bnxv13upo0.webp" style="zoom:80%;" />&emsp;&emsp;我们可以以这个图位例，使用的是4位二进制数，一共有16个机器数，因为最高位是符号位，所以0111是最大的正数，1000是最小的负数，而在模运算系统中，一个负数的补码等于模减该负数的绝对值，所以1000就是该4位二进制补码的最小整数。因此，对于32位二进制补码来说，最小整数就是0x80000000，1左移31位就得到了答案。<h1 id="3istmax"><a class="markdownIt-Anchor" href="#3istmax">#</a> <strong>3.isTmax</strong></h1><p>  这个题目的大意是：输入的 x 如果是最大值就返回 1，否则返回 0。</p><p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/4.786lnmp907s0.webp" alt=""><br>  我们知道 32 位二进制数的最大值是 0x7FFFFFFF, 则 x+1 就是超出了 int 的这个范围，因此 x 与 x+1 进行比较，x 就是最大值，那么返回值就是应该是 1。所以我们需要做的就是通过逻辑运算让返回值为 1。x+1 是 0x80000000，取反的话就和原来的最大值相同，又因为两个相同的值进行异或得到的结果为 0，所以异或结果再非运算就能得到结果为 1，写成式子就是：!(x<sup>~(x+1))。但是这个式子依然不能涵盖所有结果，还有一种特殊情况，那就是 x=-1 的时候，即 x=0xFFFFFFFF，x+1=0x00000000，取反结果和 x 一样，因此按上述方法运算得到的结果也是 1，但实际上 x=-1 是最小值，输出应该为 0，所以我们应该排除 - 1 这种情况，因此使用与运算就是！(x</sup>~(x+1))&amp;!!(x+1), 在 x+1 前面加上两个非，这样就可以避免 - 1 这种特殊情况了。</p><h1 id="4all0ddbits"><a class="markdownIt-Anchor" href="#4all0ddbits">#</a> <strong>4.ALL0ddBits</strong></h1><p>  这道题的大致意思就是 x 的奇数位上如果都是 1，则返回 1，反之则返回 0。</p><p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/5.6mb6nnvd7vk0.webp" alt=""><br>  那么关键就是判定奇数位上是否都为 1，只要有一个不为 1，那么这个数字就不符合要求了，那么判断它是不是 1，只需要和 1 进行与运算就行了，为 1 则得出 1，为 0 则得出 0，因此 0xAAAAAAAA 恰好符合条件，拿 0xAAAAAAAA 和 x 进行与运算，如果 x 符合条件，那么输出的结果依然是 0xAAAAAAAA，然后让结果继续和 0xAAAAAAAA 进行异或运算，一个值与它自身异或得到的结果为 0，最后！0 即为 1，如果 x 不符合条件，那么最后输出的结果就是 0。最后得到的式子就是：return !((0xAAAAAAAA &amp; x) ^ 0xAAAAAAAA);</p><h1 id="5negate"><a class="markdownIt-Anchor" href="#5negate">#</a> <strong>5.negate</strong></h1><p>  这道题的大致意思就是返回一个值的负数，这绝对是最简单的题，那就短话短说。</p><p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/6.34rl6www7u60.webp" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/7.2c9aqnxv2gsg.webp" style="zoom:80%;" /></p><p>  还得是看这张表，数值取反后加 1 就是对应的负数了。  最后得到的式子为：return ~x + 1 ;</p><h1 id="6isasciidigit"><a class="markdownIt-Anchor" href="#6isasciidigit">#</a> <strong>6.isAsciiDigit</strong></h1><p>  这道题也是挺简单的，题目大致意思是输入的 x 如果大于 0x30 且小于 0x39，则输出 1，反之输出 0，并且有提示这个范围就是‘0’到‘9’的 ASCII 码值。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/8.1w1stnrmxdk0.webp" alt=""><br>  因为计算机在比较大小的时候，是做减法，两数相减，然后判断结果是否为正数，因此我们可以将 x 与范围边界进行减法，而减法又可以转换为加法，所以就是 x + (~48 + 1) 和 (~x + 1) + 57，48 和 57 是‘0’和‘9’对应的 ASCII 值，又因为计算机中的数由补码表示，正数的符号位为 0，负数的符号位为 1，故我们可以将前面两个算式得到的结果进行移位，假设 x 在范围里面，那么那两个算式的结果移位之后都应该为 0，两个结果都加上 1，然后进行与运算，就能得到返回值为 1，如果 x 不在范围内，返回值就是 0。<br>  最后得到的返回式子为 return (((x + (~48 + 1))&gt;&gt;31)+1) &amp; ((((~x + 1) + 57)&gt;&gt;31)+1);</p><h1 id="7conditional"><a class="markdownIt-Anchor" href="#7conditional">#</a> <strong>7.conditional</strong></h1><p>  这道题的大致意思就是用逻辑运算和取反、位移等实现 x ? y : z。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/9.1kg7qeqcoetc.webp" alt=""><br>  x ? y : z 的原理就是:<br>   （1）判断 x 的真假；<br>   （2）如果 x 为真，那么就输出 y；<br>   （3）如果 x 为假，那么输出 z。<br>  那么这道题也就很好理解了，思路首先就是判断 x 的真假，然后选择输出 y 还是 z。判断 x 真假很好办，两次 “非” 运算就能得出真假。之后，将上一步结果取反加 1，也就是换算成结果的负数，如果结果为 1（真），那么转换成 - 1，再与 y 进行与运算，就可以保留 y。然后就是 z，z 与第一步结果的取反进行与运算，如果第一步结果为 1，那么取反之后就是 0，这样就可以消掉 z。最后总结，x 为真：保留 y、消掉 z；x 为假：消掉 y，保留 z。   根据上述描述得到的式子：return ((~A + 1) &amp; y) + (<sub>(</sub>A + 1) &amp; z);</p><h1 id="8islessorequal"><a class="markdownIt-Anchor" href="#8islessorequal">#</a> <strong>8.isLessOrEqual</strong></h1><p>  这道题的大致意思就是使用基本运算实现 “x&lt;=y”，还是有一定难度的。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/10.db1kj4asbuw.webp" alt=""><br>  计算机在比较两个数的大小的时候会先进行减法运算，然后判断正负，所以我们可以按照这个思路来解题，但是用减法的话需要考虑溢出，所以首先判断两个数的符号，c1 是 x+，y-，c2 是 x-,y+。因为我们是用 y 减 x，所以当 c1 为真且 d 为假的时候就发生了溢出，这时候计算得到的结果就与实际情况相反，所以要避免。在 c2 成立的时候，因为是负数和正数进行比较，所以整个运算就直接成立。  最后得到的返回运算式就是 return (!d &amp; !c1) | c2;</p><h1 id="9logicalneg"><a class="markdownIt-Anchor" href="#9logicalneg">#</a> <strong>9.logicalNeg</strong></h1><p>  这道题的大致意思就是实现非运算（!），还是很有难度的。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/11.v6b4eso67ts.webp" alt=""><br>  非运算就是非 0 为 1，非 1 为 0，除了 0 这种特殊情况，其它数取反加 1 都是原来的数的相反数，相反数与原来的数进行位或运算得到的结果符号位都为 1，然后再进行位移 31 位再加 1，得到的结果就是 0。对于 0 来说，取反加 1 再位或得到的结果仍然为 0，右移 31 位再加 1 就是 1。</p><h1 id="10howmanybits"><a class="markdownIt-Anchor" href="#10howmanybits">#</a> <strong>10.howManyBits</strong></h1><p>  这道题的大致意思就是一个数的补码最少可以用多少位来表示。比如 12，二进制形式 0x1100，再加上一位符号位，就是 5 位，再看 0，用二进制表示就是 0x0，只有一位，-1 用二进制表示，是 1，也只有一位。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/12.59q9mec5pt80.webp" alt=""><br>  这道题我自己做是没有任何思路，看着别人的 wp 我才能搞懂。  大致分为 3 种情况：0、-1 和其它数。  0 只用一个符号位就能够表示，-1 和 0 一样，-1 的二进制补码是全 1，取反之后就是 0，所以也能用一个符号位表示。  我们主要考虑一般的数，一般的数取反之后和取反之前都可以用相同的符号位进行表示。  对于传输进去的负数，进行取反，正数就不用管。  然后是判断高 16 位有没有 1，接着判断 8 位，然后是 4 位、2 位、1 位。</p><h1 id="11floatscale2"><a class="markdownIt-Anchor" href="#11floatscale2">#</a> <strong>11.floatScale2</strong></h1><p>  这道题是求浮点数乘以 2。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/13.1xmf11aubrcw.webp" alt=""><br>  对于一般的浮点数乘以二来说，是阶码加一，因为不同类型的数相乘是转化成同一种类型的，浮点数相乘是尾数相乘除、阶码相加减，2 的阶码是 1，尾数为 0。<br>  因此我们只需要考虑特殊情况就可以了：<br>  （1）0 乘以 2<br>  （2）无穷大或 NaN（非数）乘以 2；<br>  （3) 非规格化数乘以 2；<br>  我们看上述的代码，首先提取出阶码部分和尾数部分，然后再判断 uf 是否为 0 或无穷大或 NaN 或非规格化数，如果 uf 为无穷大或 NaN 就直接返回，乘以二之后依旧是原数。为 0 和非规格化数时，尾数只需左移一位，0 左移还是 0，非规格化数左移一位后阶码加 1，变成了规格化数。</p><h1 id="12floatfloat2int"><a class="markdownIt-Anchor" href="#12floatfloat2int">#</a> <strong>12.floatFloat2Int</strong></h1><p>  这道题是将浮点数转化成整形。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/14.1yt1vvu91fgg.webp" alt=""><br>  将浮点型转化为整形，会舍去小数，但是浮点型所表示的范围要比整形所表示的范围大，所以某些浮点型的值超过了整形所能表示的范围，根据题目要求，就需要返回 0x80000000 了，并且当浮点型小于 1 时，转化成整形就是 0。和上一道题目类似，首先提取出阶码和尾数，并且还要判断 uf 的符号位。如果阶码超过整形所能返回的最大值，则返回题目所要求的数值，如果阶码小于 127，也就是 uf 小于 1，则返回 0。如果是一般范围内的浮点数，则去掉小数转换成整形。</p><h1 id="13floatpower2"><a class="markdownIt-Anchor" href="#13floatpower2">#</a> <strong>13.floatPower2</strong></h1><p>  这道题是求 2 的 x 次方，并以浮点数的形式输出。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/15.62dhb4518yg0.webp" alt=""><br>  这个很好理解，阶码的范围就是 - 126~127，小于 - 126 返回 0，大于 127 返回无穷大，如果是正确范围内的，则返回 x 加上偏移量后再左移 23 位，得到这个以浮点数形式输出的 2 的 x 次方。</p><p>最后附上测试表：<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/16.hikvbikrfzs.webp" alt=""><br>  我的 csapp 实验一的旅程到此就结束了，我最深的感触就是这门学科真的很有难度，但是也带给我很大的精神愉悦，特别是在做实验的时候，每做出一道题并且通过测试之后，我真的很开心，比我打一把游戏胜利之后都要开心，因为我确实是看到了自己的进步。但是它也使我认识到了和别人的差距，不努力是真的不行，和别人的差距只会越来越大。并且，这次实验我的理解还不够深，特别是最后四道题，我看着别人写的 wp 一步一步来的，学的不精是我的问题，以后更是不能放弃，学得更多之后，还要回过头来再把这个实验刷几遍，必须学得透彻之后我才能走的更远。<br>  以后会持续更新 csapp 的，还有更多的实验等着我呢！</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> csapp datelab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编基础-菜鸟的入门之路</title>
      <link href="/2022/02/23/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80-%E8%8F%9C%E9%B8%9F%E7%9A%84%E5%85%A5%E9%97%A8%E4%B9%8B%E8%B7%AF/"/>
      <url>/2022/02/23/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80-%E8%8F%9C%E9%B8%9F%E7%9A%84%E5%85%A5%E9%97%A8%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​初学汇编，本篇文章的内容主要包含一些基础的汇编知识以及个人的见解，难免会有出错的地方，望各位师傅多多包涵。</p><h2 id="一-进制和进制运算"><a class="markdownIt-Anchor" href="#一-进制和进制运算">#</a> 一、进制和进制运算</h2><p>​1. 每一种进制都是完美的，想要学好进制首先要忘掉十进制，也要忘掉进制之间的转化。<br>​2. 进制的定义：<br>​（1）八进制：由八个符号组成，分别是 01234567，逢八进一。<br>​（2）十进制：由十个符号组成，分别是 0123456789，逢十进一。<br>​（3）N 进制：由 N 个符号组成，逢 N 进一。<br>​3. 进制的运算<br>​进制的运算的本质就是查数。<br>​十进制运算用十进制运算表，那八进制就用八进制的运算表。<br>​每一种进制自身都是一个完整的体系，可以直接做各种运算。</p><h2 id="二-二进制简写形式"><a class="markdownIt-Anchor" href="#二-二进制简写形式">#</a> 二、二进制简写形式</h2><p>​1. 计算机为什么要使用二进制<br>​（1）计算机是需要用电的，电路只有两种状态：<br>​                               1      真（通电）<br>​                               0      假（未通电）<br>​          计算机中存储的任何文件，接收的任何指令，都是由 0 和 1 组成的。<br>​（2）16 进制在计算机中可以看成二进制的简写形式</p><p>​二进制         十六进制                   二进制                  十六进制</p><p>​0000             0                             1001                        9</p><p>​0001             1                             1010                        A</p><p>​0010             2                             1011                        B</p><p>​0011             3                              1100                       C</p><p>​0100             4                              1101                       D</p><p>​0101             5                              1110                       E</p><p>​0110             6                               1111                       F</p><p>​0111              7</p><p>​1000             8<br>​这些转换是需要记住的，对以后的学习会有很大的帮助</p><h2 id="三-数据宽度"><a class="markdownIt-Anchor" href="#三-数据宽度">#</a> 三、数据宽度</h2><p>​数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的限制，数据都是有长度限制的，我们称之为数据宽度，超过最多宽度的数据会被丢掉。</p><p>​在计算机中常见的数据宽度：<br>​首先就是位（bit），然后是字节（byte），1 字节 = 8 位，再者就是字（word），1 字 = 16 位，双字（Doubleword）=32 位。</p><p>​存储范围<br>​在计算机中，每个位能存一个 0 或 1，另外，在二进制中四位 1 等于十六进制中的一个 F，那么我们就能根据这些能够知道每个宽度所能存储的范围，<br>​字节：0~0xFF<br>​字：0~0xFFFF<br>​双字：0~0xFFFFFFFF</p><h2 id="四-有符号数和无符号数"><a class="markdownIt-Anchor" href="#四-有符号数和无符号数">#</a> 四、有符号数和无符号数</h2><p>​在计算机中，所有东西都是用二进制的 0 和 1 来进行存储的，比如说一个逗号、一个程序、一个有符号数，一个无符号数等等，都是用 0 和 1 进行存储的。所以在进行编码的时候，会按照相应的编码规则进行编码，有符号数按有符号数的编码规则，无符号数按无符号数的编码规则，所以说给你一串数字：1 0 0 1 1 1 0 1 0，告诉你他是个文本，那么他可能就代表 0 一个逗号。不谈这个文本，如果它是一个无符号数，我们就需要按照无符号数的编码规则去进行编码，既然是无符号，顾名思义，可以直接转换成十六进制数，或者是十进制数，转换成 16 进制就是 0x9A   十进制就是 154。<br>​但如果是有符号数的话，因为是有正数和负数之分的，所以编码规则相对不同，即正数和负数的编码不同。<br>​有符号数，拿上面的一串数字来说：0 0 0 1 1 0 1 0，最高位是 1，这个数就是负数，最高数是 0，这个数就是正数，那么很显然这个是正数。至于有、无符号数是怎么进行编码的，就需要了解到原码、补码和反码了。</p><h2 id="五-原码-补码和反码"><a class="markdownIt-Anchor" href="#五-原码-补码和反码">#</a> 五、原码、补码和反码</h2><p>​1. 编码规则<br>​首先在计算机中，靠二进制数 0 和 1 存储信息，例如 0 1 0 1 0 1 0 1，不同的文件有着不同的编码规则，也就是说这些 0 和 1 按照编码规则，解析成文本，视频，音乐等等。</p><p>​2. 原码、反码和补码<br>​原码：最高位为符号位，其余各位为数值本身的绝对值</p><p>​反码：<br>​正数：反码与原码相同<br>​负数：符号位为 1，其余位对原码取反</p><p>​补码：<br>​正数：补码与原码相同<br>​负数：符号位为 1，其余位对原码取反加 1</p><p>​了解到原码、反码和补码之后，我们也就能够轻松地理解有、无符号数是怎样进行编码的了。</p><h2 id="六-计算机做的运算"><a class="markdownIt-Anchor" href="#六-计算机做的运算">#</a> 六、计算机做的运算</h2><p>​1. 与运算（and&amp;）<br>​       两个位都为 1 时，结果才为 1</p><p>​2. 或运算（or|）<br>​      只要有一个为 1 就是 1</p><p>​3. 异或运算（xor^）<br>不一样的时候是 1</p><p>​4. 非运算（not~）<br>​      0 就是 1    1 就是 0</p><p>​5. 移位运算<br>​左移（shl &lt;&lt;）<br>​各二进位全部左移若干位，高位丢弃，低位补 0<br>​eg：1101 1000    左移 2 位为：0110 0000</p><p>​右移（shr    sar    &gt;&gt;）<br>​各二进位全部右移若干位，低位丢弃，高位补 0 或者补符号位<br>​注：右移是分两种情况的，就是高位补 0 和补符号位</p><p>​shr   1101 0101        右移    0011 0101<br>​对应 C 语言（&gt;&gt;）<br>​unsigned int a= 10；<br>​printf(&quot;%d\n&quot;,a&gt;&gt;2);</p><p>​sar   1101 0101        右移    1111 0101<br>​对应 C 语言（&gt;&gt;）<br>​int a=10;<br>​printf(&quot;%d\n&quot;,a&gt;&gt;2):</p><p>​C 语言中，有符号的右移是补符号位，无符号位的右移是补 0。上述字母代表的是汇编中对应的指令，符号代表的是 C 语言中对应的指令。所以说计算机做的所有运算归根到底都是位运算。</p><h2 id="七-位运算加减乘除用位运算来实现四则运算"><a class="markdownIt-Anchor" href="#七-位运算加减乘除用位运算来实现四则运算">#</a> 七、位运算加减乘除（用位运算来实现四则运算）</h2><p>​不考虑进位的情况下，异或的结果和加结果一样。所以计算机在进行加法的时候的大致过程是这样的：<br>​举个例子：4+5=？<br>​（1）首先，两个二进制数进行异或<br>​0000  0100<br>​0000  0101   异或<br>​————————<br>​0000  0001<br>​（2）其次，两个数进行与运算<br>​0000  0100<br>​0000  0101   与<br>​————————<br>​0000  0100<br>​（3）因为与运算是计算机能够判断在进行加法时是否发生了进位的运算，所如果发生了进位，那么就会再次进行异或运算，如果没有进位，第一次进行的异或运算的结果就是真实的结果，以下是发生了进位之后的异或运算<br>​0000 0001                 —&gt; 第一次异或的结果<br>​0000 1000   异或        —&gt; 上次与运算的结果左移一位之后<br>​————————<br>​0000  1001<br>​（4）再次进行与运算，判断上次异或是否发生进位，没有进位，直接出结果，进位了，继续进行异或运算<br>​0000  0001<br>​0000  1000     与<br>​————————<br>​0000  0000</p><p>​注：（1）与运算结果有 1 的地方就是发生了进位，如果没有发生进位，那么结果就应该全部为 0<br>​      （2）第二次异或之所以要加左移一位的结果是因为与运算结果为 1 的地方本应该是要进一位的</p><p>​其他运算的运算过程<br>​4-5=4+（-5）<br>​减法就是加法，所以运算的过程和加法基本是一致的，<br>​至于乘法，乘法就是加法，x*y 的本质就是 x 个 y 相加，<br>​除法的本质就是减法，X/Y 其实就是 X 能减去多少个 Y，<br>​归根结底，四则运算就是加法的运算，用计算机的位运算进行运算，本质都是一样的。<br>​所以说计算机可以通过位运算来进行最基本的四则运算，那么也就可以以此进行一些更复杂的运算。</p><h2 id="八-汇编环境搭建"><a class="markdownIt-Anchor" href="#八-汇编环境搭建">#</a> 八、汇编环境搭建</h2><p>​汇编环境搭建<br>​1. 学汇编不是为了写代码<br>​学汇编对学习应用开发和安全相关方面都有帮助<br>​2. 环境配置<br>​下载 DTDebug，在滴水官网下载，下载完成之后进行简单配置，在 options—&gt;Appearance—&gt;Directories 中，将 UDD 和 Plugin 的路径指向对应名称的目录中。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 菜鸟入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈博客搭建</title>
      <link href="/2022/02/18/%E6%B5%85%E8%B0%88%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/02/18/%E6%B5%85%E8%B0%88%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第一次接触博客，不知道说啥，好紧张。<br>年前花了几天时间在网上找课程，搭建最基础的博客，然后就是漫长的主题美化，中间一直耽搁着，直到今天才顺利的把主题美化好，各种该有的全部添了上去，不该有的也弄了个七七八八。<br>我用的是 butterfly 主题，当时满世界的找主题，唯有这款主题深深的吸引了我，但是这个主题对于新手十分的不友好，我差点就删档重新来过，好在经历了各种错误之后，还是将美化给做完了。<br>还有就是我要开始写博客了，学习怎样写博客，也不失为一种乐趣，这也是最最基本的事情了。就目前看来，Sublime Text 确实用的不是很习惯。<br>不说了，我要去下载 Typora 了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 浅谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
