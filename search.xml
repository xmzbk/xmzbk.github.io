<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>reverse的wp</title>
      <link href="/2022/06/18/reverse%E7%9A%84wp/"/>
      <url>/2022/06/18/reverse%E7%9A%84wp/</url>
      
        <content type="html"><![CDATA[<h1 id="一-bobs-code"><a class="markdownIt-Anchor" href="#一-bobs-code">#</a> 一、Bob‘s Code</h1><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618164821624.png" alt=""><br> 首先，1 是给定的字符串，然后我们看 2 和 3，这两个都属于 base64 解密，但是其中一个 base 换了表。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618165248386.png" alt=""><br> 再看 4,4 的作用是将字符串的开头和结尾加上一个 &quot;.&quot;。</p><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618165639761.png" alt=""><br> 然后观察第 5 个函数，这个函数是一个爆破，可以写一个脚本逆一下。也就是遍历字符串对应的 ascII 可见字符串。<br>逆过来后是这样的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.U1ZorfEzdEZomVZkTXPOb.U5TmVLHaKP6VLZvmK5DmDBsaKUwULdZnVLYmD0.</span><br></pre></td></tr></table></figure><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618165521925.png" alt=""><br> 然后将逆过来的字符串去点，再进行 base 解码和换表解码。<br> base64 换表网上找的脚本可以用一下，然后正常的 base64 解码找个网站解。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import base64</span><br><span class="line">import string</span><br><span class="line">str1 = &quot;U1ZorfEzdEZomVZkTXPOb.U5TmVLHaKP6VLZvmK5DmDBsaKUwULdZnVLYmD0====&quot;</span><br><span class="line">string1 = &quot;ABCDEfghijklmnopqrsTUVWXYZabcdeFGHIJKLMNOPQRStuvwxyz0123456789-_&quot;</span><br><span class="line">string2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span><br><span class="line">print (base64.b64decode(str1.translate(str.maketrans(string1,string2))))</span><br></pre></td></tr></table></figure><p E7UI38f5-Xj2sUZ64-4F14Ef9a=""> Flag：ISCC</p><h1 id="二-经典base"><a class="markdownIt-Anchor" href="#二-经典base">#</a> 二、经典 base</h1><p gA6JawpVMZdVL=""><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618160430174.png" alt=""><br> 根据下面那一串字符可以知道这是 base58, 编码，把上面那串字符找一个网站拖进去就可以解出来。<br> Flag：ISCC</p><h1 id="三-经典re1用x64dbug进行调试"><a class="markdownIt-Anchor" href="#三-经典re1用x64dbug进行调试">#</a> 三、经典 re1（用 x64Dbug 进行调试)</h1><p> 拖进 IDA 中无法搜到字符串，也不能看到 mian 函数的伪代码，那就拖到 x64Dbug 中调试。运行一下程序，然后直接搜索字符串。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618184409092.png" alt=""></p><h1 id="四-手动脱壳"><a class="markdownIt-Anchor" href="#四-手动脱壳">#</a> 四、手动脱壳</h1><p> 将修狗程序拖入 ollyDbug。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618200250285.png" alt=""><br> F8 运行一步，可以看到 ESP 发生变化，然后右键。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618200328565.png" alt=""><br> 选择数据窗口跟随。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618200427735.png" alt=""><br> 选择硬件写入，然后 shift+f9<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618200528957.png" alt=""><br> F8 运行几步，在 jnz 这里的下面设置一个断点，f4 执行跳过 jnz，因为 jnz 是往上跳转的，所以要跳过这里。然后执行完 jmp 来到一个新的入口。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618200817646.png" alt=""><br> 右键选择用 OllyDump 脱壳调试进程。</p><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618203916051.png" alt=""><br> 先点获取 EIP 作为 OEP，然后再点脱壳进行保存。<br> 保存的文件再用 IDA 打开就可以发现 flag 了。</p><h1 id="五-squid"><a class="markdownIt-Anchor" href="#五-squid">#</a> 五、squid</h1><p>用 IDA 打开程序，发现很多 py，可以确定这是和 python 反编译有关。<br><a href="http://xn--pyinstxtractor-9v1wl125b.py">使用 pyinstxtractor.py</a>，将文件拖入文件夹，使用以下指令，可以分出一些文件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objcopy --dump-section pydata=pydata.dump</span><br><span class="line">python pyinstxtractor.py &lt;filename&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 逆向学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆栈图</title>
      <link href="/2022/06/18/%E5%A0%86%E6%A0%88%E5%9B%BE/"/>
      <url>/2022/06/18/%E5%A0%86%E6%A0%88%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>一、堆栈图<br> 1.Windows 堆栈的特点<br> （1）先进后出<br> （2）向低地址扩展<br> Windows 中的堆栈，是一块普通的内存，主要用来存储一些临时的数据和参数等可以把 Windows 中的堆栈想象成是一个公用的书箱，函数就像是使用箱子的人函数在执行的时候，会用到这个书箱，把一些数据存到里面，但用完的时候一定要记得把书拿走，否则会乱的，也就是说，你放进去几本书，走的时候也要拿走几本书，这个就是堆栈平衡。<br>2. 函数<br> 计算机的函数，是一个固定的一个程序段，或称其为一个子程序，它在可以实现固定运算功能的同时还带有一入口和一个出口，所谓的入口，就是函数所带的各个参数，我们可以通过这个入口，把函数的参数值代入子程序，供计算机处理，所谓出口，就是指函数的计算结果，也称为返回值，在计算机求得之后，由此口带回给调用它的程序。<br>3. 汇编中的函数<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618144251704.png" alt=""><br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618144323907.png" alt=""><br> 4. 常见的操作<br>（1）CALL 指令压入栈的地址我们称作函数执行完之后的返回地址。在 OD 里面画堆栈图执行 call 函数按 F7。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220608124647230.png" alt=""></p><p>（2）这条指令的作用是将 EBP-40 的地址取出放入 EDI 寄存器中。</p><p>（3）<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220608130217339.png" alt=""><br> 这三条指令的作用是防止缓冲区溢出。</p><p>（4）<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220608131538958.png" alt=""><br> 恢复现场。<br> 堆栈平衡：调用函数前后堆栈没有变化<br>（5) return 指令相当于 pop eip<br> 二、画堆栈图<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618152056355.png" alt=""><br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618152152522.png" alt=""><br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618152243776.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 逆向学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滴水逆向（二）</title>
      <link href="/2022/06/07/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/06/07/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="一-jcc"><a class="markdownIt-Anchor" href="#一-jcc">#</a> 一、JCC</h1><p>1.JMP 指令<br> JMP 指令的作用就是修改 EIP 寄存器的值，MOV 指令不能用来修改 EIP。<br> 简写为：JMP    寄存器 / 立即数<br> 2.CALL 指令<br> PUSH   地址 B<br> 简写为：CALL  地址 A / 寄存器<br>两者的区别：JMP 只修改 EIP，CALL 指令将程序运行的下一行地址 PUSH 堆栈中，再修改 EIP。<br>需要注意：CALL 和 ret 指令一般同时出现，CALL 结束之后，再 ret 返回。<br>3.ESP 寄存器<br> ESP 寄存器就是栈指针寄存器，存储堆栈使用到的地址。<br>4.EIP 寄存器<br> EIP 存储程序运行到的位置。JMP 指令和 CALL 指令就是用来修改 EIP 的指令。<br>5.PUSH 和 POP（压栈和出栈）<br>（1）PUSH 指令<br> 将数据压入栈中。<br>（2）POP 指令<br> 将数据</p><p>6.CMP 指令</p><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220607205200559.png" alt=""></p><p> CMP 指令操作和 SUB 指令相当，但是它不会将结果保存，而是只会修改标志寄存器的值。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220607205342455.png" alt=""></p><p> TEST 指令与 CMP 指令同理。<br>7.JCC<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220607205439657.png" alt=""><br><img src="C:%5CUsers%5Ca%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220607205500689.png" alt="image-20220607205500689"><br> JCC 指令就是 JMP 指令，只不过在执行前增加了一个判断条件，并且也只会修改 EIP 寄存器的值。比如：JE 指令执行时，首先判断 ZF 位是否为 1，为 1 则执行，不为 1 则不执行。JNE 和 JE 的判断条件相反。</p>]]></content>
      
      
      <categories>
          
          <category> 逆向学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现base64编码</title>
      <link href="/2022/04/27/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0base64%E7%BC%96%E7%A0%81/"/>
      <url>/2022/04/27/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0base64%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求">#</a> 题目要求</h1><p> 使用 c/c++ 完成以下下算法:<br> 输入一个字符串，检查该字符串总 ascii 码值。如果值大于 1000 则对该字符串进行 base64 加密输出，否则该字符串与 base64 编码表进行异或输出。<br> 说实话我的 c 语言能力真的弱，这道题看着这么简单，实际上实现起来很有难度。这道题目主要是这几个部分：1. 检测字符串 ASCII 码值；2.base64 编码；3. 将字符串与 base64 编码表异或。</p><h2 id="一-检测字符串的ascii码值"><a class="markdownIt-Anchor" href="#一-检测字符串的ascii码值">#</a> 一、检测字符串的 ASCII 码值</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; chuanchuan[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        n=chuanchuan[i];</span><br><span class="line">        sum = sum +n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你的串串的长度是：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br></pre></td></tr></table></figure><p> 这段代码实现起来十分简单，使用 for 循环就可以了，采用累加的方式将所得单个字符的 ASCII 码值相加，最后得到总的 ASCII 码值。</p><h2 id="二-实现base64编码"><a class="markdownIt-Anchor" href="#二-实现base64编码">#</a> 二、实现 base64 编码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">base64</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *chuanchuan)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *base64laobiao = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line">    <span class="keyword">long</span> changdu = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *res;</span><br><span class="line">     changdu= <span class="built_in">strlen</span>(chuanchuan);</span><br><span class="line">     <span class="keyword">if</span>(changdu%<span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        len = changdu/<span class="number">3</span>*<span class="number">4</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        len = (changdu/<span class="number">3</span>+<span class="number">1</span>)*<span class="number">4</span>;</span><br><span class="line">     res = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>)*len + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//malloc()函数在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。</span></span><br><span class="line">     res[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">     <span class="keyword">int</span> i,j;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;=len<span class="number">-1</span>;j+=<span class="number">3</span>,i+=<span class="number">4</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         res[i] = base64laobiao[chuanchuan[j]&gt;&gt;<span class="number">2</span>];</span><br><span class="line">         res[i+<span class="number">1</span>] = base64laobiao[(chuanchuan[j]&amp; <span class="number">0x3</span>)&lt;&lt;<span class="number">4</span> | (chuanchuan[j+<span class="number">1</span>]&gt;&gt;<span class="number">4</span>)];</span><br><span class="line">         res[i+<span class="number">2</span>] = base64laobiao [(chuanchuan[j+<span class="number">1</span>] &amp; <span class="number">0xf</span>)&lt;&lt;<span class="number">2</span> | (chuanchuan[j+<span class="number">2</span>])&gt;&gt;<span class="number">6</span>];</span><br><span class="line">         res[i+<span class="number">3</span>] = base64laobiao[chuanchuan[j+<span class="number">2</span>]&amp;<span class="number">0x3f</span>];</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//第一个字符的前6位</span></span><br><span class="line"><span class="comment">//第一个字符的后两位与第二个字符的前四位结合</span></span><br><span class="line"><span class="comment">//第二个字符的后四位与第三个字符的前两位结合</span></span><br><span class="line"><span class="comment">//第三个字符的六位</span></span><br><span class="line">     <span class="keyword">switch</span>(changdu%<span class="number">3</span>)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        res[i - <span class="number">2</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        res[i - <span class="number">1</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">             <span class="comment">//对剩余4位的补两个“=”</span></span><br><span class="line">     <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        res[i - <span class="number">1</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">             <span class="comment">//对剩余2位的补一个“=”</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 代码有借鉴别人的成分，只有我自己我可写不出来。<br> 主要难度就在于编码部分，下面附上 base64 编码的简单讲解。<br> Base64 编码，是我们程序开发中经常使用到的编码方法。它是一种基于用 64 个可打印字符来表示二进制数据的表示方法。它通常用作存储、传输一些二进制数据编码方法！</p><p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/base64%E7%BC%96%E7%A0%81%E8%A1%A8.3uee5rdheyi0.webp" alt="base64编码表"><br> base64 其实就是用 64 个可打印的字符去表示所有的二进制数，base64 的编码原理也很简单，假如给定三个字符：M a n，然后找到他们的各自对应的 ASCII 码值，然后将这些码值换算成十六进制，接着再都换算成二进制，然后对所有二进制数重新分割再组合，将最后组合成的二进制数再对照 base64 表编码。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2022-04-27-221311.76lhq8bfrck0.webp" alt="屏幕截图-2022-04-27-221311"><br> 每个字符占八位内存，但是 base64 编码每位占 6 位内存，所以在进行转换的时候，如果源码恰好是 3 的倍数，则可以恰好转换成 base64 编码，就比如上述所举的例子，M a n，对应 24 位内存，除以 6，是四位 base64 编码，所以一般来说，源码在进行编译之后，长度都会变长，如果是 3 的倍数，在编码过后的长度就是源码的 4/3 倍。<br> 但是，如果不是三的倍数的时候，进行编码的时候就会出现位数不足的情况，这种情况下，base64 另有一套解决方案，编码位数不足的时候补 0，并且还要满足凑出的位数是 8 的倍数，因为编码位数的特殊，所以剩余位数不是 2 位就是 4 位，因此当剩余二位的时候，补一个特殊的 6 位符号 “=”，当剩余 4 位的时候，补两个 “=”。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2022-04-27-223118.3x4yepw2t5m0.webp" alt="屏幕截图-2022-04-27-223118"></p><h3 id="三-实现字符串与base64异或运算"><a class="markdownIt-Anchor" href="#三-实现字符串与base64异或运算">#</a> 三、实现字符串与 base64 异或运算</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *n = chuanchuan;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你的串串太短了，接下来将你的串串和base64编码表进行异或：\n&quot;</span>);</span><br><span class="line">        <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; chuanchuan[i]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m= chuanchuan[i]^base64laobiao[i];</span><br><span class="line">            <span class="built_in">sprintf</span> (str, <span class="string">&quot;%c&quot;</span>, m);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, m);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p> 实现这段代码的时候用了好久，主要是没明白计算机怎样计算字符串之间的异或运算，我在尝试了一番之后，我认为的是计算机计算字符串的异或，字符串转十六进制，再异或，最后得到的结果类型可以是整形，我将整形转换成字符串类型，然后再输出。<br>结尾附上源代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _BASE64_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BASE64_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _BASE64_H</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">base64</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *chuanchuan)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">haoduan</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *chuanchuan)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *base64laobiao = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> chuanchuan[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你的串串：\n&quot;</span>);</span><br><span class="line">    gets(chuanchuan);</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; chuanchuan[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        n=chuanchuan[i];</span><br><span class="line">        sum = sum +n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你的串串的长度是：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">if</span>(sum&gt;<span class="number">1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;你的串串有点长，接下来进行base64加密：\n&quot;</span>);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, base64(chuanchuan));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> *n = chuanchuan;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你的串串太短了，接下来将你的串串和base64编码表进行异或：\n&quot;</span>);</span><br><span class="line">        <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; chuanchuan[i]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m= chuanchuan[i]^base64laobiao[i];</span><br><span class="line">            <span class="built_in">sprintf</span> (str, <span class="string">&quot;%c&quot;</span>, m);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">base64</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *chuanchuan)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *base64laobiao = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line">    <span class="keyword">long</span> changdu = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *res;</span><br><span class="line">     changdu= <span class="built_in">strlen</span>(chuanchuan);</span><br><span class="line">     <span class="keyword">if</span>(changdu%<span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        len = changdu/<span class="number">3</span>*<span class="number">4</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        len = (changdu/<span class="number">3</span>+<span class="number">1</span>)*<span class="number">4</span>;</span><br><span class="line">     res = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>)*len + <span class="number">1</span>);</span><br><span class="line">     res[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">     <span class="keyword">int</span> i,j;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;=len<span class="number">-1</span>;j+=<span class="number">3</span>,i+=<span class="number">4</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         res[i] = base64laobiao[chuanchuan[j]&gt;&gt;<span class="number">2</span>];</span><br><span class="line">         res[i+<span class="number">1</span>] = base64laobiao[(chuanchuan[j]&amp; <span class="number">0x3</span>)&lt;&lt;<span class="number">4</span> | (chuanchuan[j+<span class="number">1</span>]&gt;&gt;<span class="number">4</span>)];</span><br><span class="line">         res[i+<span class="number">2</span>] = base64laobiao [(chuanchuan[j+<span class="number">1</span>] &amp; <span class="number">0xf</span>)&lt;&lt;<span class="number">2</span> | (chuanchuan[j+<span class="number">2</span>])&gt;&gt;<span class="number">6</span>];</span><br><span class="line">         res[i+<span class="number">3</span>] = base64laobiao[chuanchuan[j+<span class="number">2</span>]&amp;<span class="number">0x3f</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">switch</span>(changdu%<span class="number">3</span>)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        res[i - <span class="number">2</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        res[i - <span class="number">1</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        res[i - <span class="number">1</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> c语言代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滴水逆向（一）</title>
      <link href="/2022/04/07/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/04/07/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="数据宽度与逻辑运算"><a class="markdownIt-Anchor" href="#数据宽度与逻辑运算">#</a> 数据宽度与逻辑运算</h1><p>  数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的制约，数据都是有长度限制的（我们称为超过最多宽度的数据会被丢弃，也就是说存不下的超出限制的那些数据直接被抛弃了、不存了）。</p><h2 id="一-数据宽度的表示"><a class="markdownIt-Anchor" href="#一-数据宽度的表示">#</a> 一、数据宽度的表示</h2><p>  1.4 位宽度表示：假设计算机只能存储 4 位 2 进制数<br>  存储无符号数，那么从 0 到 F，再往后还是从零开始。<br>  存储正数和负数，那么正数是 0,1,2,3,4,5,6,7（在计算机里把 0 看做正数），负数是 - 1，-2，-3，-4，-5，-6，-7，-8，对应 F,E，D，C，B，A,9,8, 并且，二进制数 1 开头的都是负数，0 开头的都是正数。<br><img src="https://img-blog.csdnimg.cn/7a6a3da130044aa18779a5f8098fab7b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGwyNjU1ODk0NTIw,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p>  2.8 位宽度表示：假设计算机只能存储 8 位 2 进制数<br><img src="https://img-blog.csdnimg.cn/995858070d7e41bb906a8caf8da0cd3d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGwyNjU1ODk0NTIw,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p>  3.16 位宽度表示：假设计算机只能存储 16 位 2 进制数<br><img src="https://img-blog.csdnimg.cn/508b17abfc7543e08520e3a45006008c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGwyNjU1ODk0NTIw,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p>  4.32 位宽度表示：假设计算机只能存储 32 位 2 进制数<br><img src="https://img-blog.csdnimg.cn/c1cf763a4c9c4825a90b5b9552722401.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGwyNjU1ODk0NTIw,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p>  注：有符号、无符号什么的都是自己定义的。</p><h2 id="二-几个重要的计量单位"><a class="markdownIt-Anchor" href="#二-几个重要的计量单位">#</a> 二、几个重要的计量单位</h2><p>  BYTE      字节       8BIT<br>  WORD     字        16BIT     2 字节<br>  DWORD   双字     32BIT    4 字节</p><h2 id="三-二进制的逻辑运算"><a class="markdownIt-Anchor" href="#三-二进制的逻辑运算">#</a> 三、二进制的逻辑运算</h2><p>  1. 逻辑运算：或（or    |  ）只要有一个为 1 就是 1<br><img src="https://img-blog.csdnimg.cn/fa4c890ad712426eb8f30f80d83ff1d6.png" alt=""></p><p>  在这个电路图中，只要有一个开关闭上，灯泡就亮，然后就为 1，所以或运算只要有一个为 1 就是 1。<br>  2. 逻辑运算：与（and   &amp;  ）两个都为 1 才是 1</p><p><img src="https://img-blog.csdnimg.cn/de08c7de76094741a3ab2c8cfa583484.png" alt=""><br>  在这个电路图中，两个开关都闭上才为 1，<br>  3. 逻辑运算：异或（xor   ^   ) 不一样为 1<br><img src="https://img-blog.csdnimg.cn/9cb90835a6b8498fb2ae16ff93591d47.png" alt=""></p><p>  4. 逻辑运算：非（not     ！ ）1 是 0    0 是 1<br><img src="https://img-blog.csdnimg.cn/514f8aa407ec406293b7341457a900b7.png" alt=""></p><h2 id="四-32位通用寄存器"><a class="markdownIt-Anchor" href="#四-32位通用寄存器">#</a> 四、32 位通用寄存器</h2><p>  32 位意思是能存 32 个 0 或 1，这些寄存器能存 0 到 8 个 F<br><img src="https://img-blog.csdnimg.cn/6de7862a41444a8ab9ae088556ab9059.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGwyNjU1ODk0NTIw,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""><br>  学好这些内容的前提要求：要把二进制与十六进制的映射记到无比熟练的地步。</p><h1 id="通用寄存器内存读写"><a class="markdownIt-Anchor" href="#通用寄存器内存读写">#</a> 通用寄存器 —— 内存读写</h1><p>一、通用寄存器<br><img src="https://img-blog.csdnimg.cn/086eebf3e7d140839772185aafe1193e.png" alt=""><br><img src="https://img-blog.csdnimg.cn/b690fa40ba664d44ad65c77560086800.png" alt=""></p><p>  32 位寄存器从中间分开，其中一半形成了 16 位寄存器，16 位寄存器前四个再从中间分开，形成 8 个 8 位的寄存器，并不是说 32 位、16 位、8 位寄存器是分开来算的，而是包含关系，我只需要 8 位，那就只用到 8 位，我需要 32 位的，那我就用到 32 位。<br>二、汇编代码<br>  所要学的内容：<br>  1.MOV 指令<br>  2.ADD 指令<br>  3.SUB 指令<br>  4.AND 指令<br>  5.OR 指令<br>  6.XOR 指令<br>  7.NOT 指令<br>  各指令所在网址：<a href="https://www.bcdaren.com/video/videoPlay/330285640321339392">https://www.bcdaren.com/video/videoPlay/330285640321339392</a><br>1.MOV 指令<br>  操作码 目标操作数  源操作数<br>  MOV   EAX，OxAAAAAAAA<br>  MOV   AX，OxBBBB<br>  MOV   AH,OxCC<br>  MOV   AL,OxDD</p><p>  MOV 的作用：拷贝源操作数到目标操作数（也就是将源操作数复制到目标操作数中）。<br>  （1）源操作数可以是立即数、通用寄存数、段寄存器、或者内存单元。<br>  （2）目标操作数可以是通用寄存器、段寄存器或者内存单元。<br>  （3）操作数的宽度必须一样。<br>  （4）源操作数和目标操作数不能同时为内存单元。<br>MOV 指令：<br><img src="https://img-blog.csdnimg.cn/6a6bdab14d8f43298ff514d68a628f51.png" alt=""><br>MOV 的语法：<br><img src="https://img-blog.csdnimg.cn/b92b0fe9d99f45f3bebdc74c18b0beb8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGwyNjU1ODk0NTIw,size_11,color_FFFFFF,t_70,g_se,x_16" alt=""><br>三、内存读写</p><p>1. 寄存器与内存的区别<br>  （1）寄存器位于 CPU 内部，执行速度快，但比较贵<br>  （2）内存速度相对较慢，但成本低，所以可以做的很大<br>  （3）寄存器和内存没有本质区别，都是用于存储数据的容器，都是定宽的（即都是有边界的）。<br>  （4）寄存器常用的有 8 个：EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI。<br>  （5）计算机中的几个常用计量单位：BYTE,WORD,DWORD。</p><p>  BYTE      字节    =   8BIT<br>  WORD     字     =  16（BIT）<br>  DWORD   双字     32（BIT）</p><p>  1KB = 1024BYTE<br>  1MB = 1024KB<br>  1GB = 1024MB</p><p>  2. 内存的数量特别庞大，无法每个内存单元都起一个名字，所以用编号来代替，我们称计算机 CPU 是 32 位或者 64 位，有很多书上说之所以叫 32 位计算机是因为寄存器的宽度是 32 位，是不准确的，因为还有很多寄存器是大于 32 位的。<br>计算机内存的每一个字节会有一个编号（即内存编号的单位是字节），如下图：</p><p>  3. 内存格式<br><img src="https://img-blog.csdnimg.cn/3b742423b1f14a70ae1653ed9ea4cb28.png" alt="">  只要涉及内存读写的，一定要指定它的宽度</p><p>  4. 从指定内存中写入 / 读取数据<br><img src="https://img-blog.csdnimg.cn/c0a68e95d5db47878e8e1f028244fa55.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGwyNjU1ODk0NTIw,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h1 id="内存地址堆栈"><a class="markdownIt-Anchor" href="#内存地址堆栈">#</a> 内存地址 —— 堆栈</h1><p>1. 关于 32 位、16 位、8 位通用寄存器<br>  这几个寄存器的关系可以说是包含的关系，32 位寄存器分为上位和下位的话，16 位寄存器就是 32 位寄存器的下位，这几个寄存器不是分开来算的，8 位寄存器发生变化，16 位、32 位寄存器也可能发生变化。</p><p>2. 寄存器的结构：EAX-AX-AH-AL 的对应关系</p><pre><code>这几个寄存器是包含关系</code></pre><p>3. 为什么 8 位寄存器只能存放 2 个十六进制的数？<br>  因为 8 位寄存器只能存 8 位，而一位的十六进制数对应四位二进制数，所以两个 16 进制数换算成 2 进制数正好占 8 位，</p><p>4. 内存单元：字节。<br>  每个字节有个编号，称为内存地址，一个字节等于 8 比特位，也就是一字节等于 8 位。<br>  每个编号对应一块内存，这个内存就是一个字节<br>  内存中的最小单元就是字节</p><pre><code>    内存单元的换算：    1GB=1024MB    1MB=1024KB    1KB=1024B    1B（字节）=8b yte（位）    BYTE      字节    =   8BIT          一个字节    WORD     字     =  16（BIT）   两个字节    DWORD   双字     32（BIT）    四个字节</code></pre><p>5. 数据窗口的使用、数据窗口与堆栈窗口的显示方式<br>反汇编窗口<br>  程序是怎么跑的，汇编的执行都在这个窗口<br><img src="https://img-blog.csdnimg.cn/d1224f538b7b4da1b0ee1803929d7107.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p-Q5Lq65LiN5Lya5pWy5Luj56CB,size_11,color_FFFFFF,t_70,g_se,x_16" alt=""><br>寄存器窗口<br>  8 位的、16 位的、32 位的寄存器都在这个窗口<br><img src="https://img-blog.csdnimg.cn/bd5a0f8d100642a9813275904da34768.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p-Q5Lq65LiN5Lya5pWy5Luj56CB,size_10,color_FFFFFF,t_70,g_se,x_16" alt=""> 堆栈窗口<br>   一个特殊的内存窗口<br>  这个窗口里面的编号是四个字节组成一组进行显示，四个字节换算一下就是 32 位<br><img src="https://img-blog.csdnimg.cn/22a31b34f6d248c69de62f8f9c41d97f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p-Q5Lq65LiN5Lya5pWy5Luj56CB,size_11,color_FFFFFF,t_70,g_se,x_16" alt=""><br>数据窗口<br>  在这个窗口可以了解数据<br><img src="https://img-blog.csdnimg.cn/b5851a587dc84aceb6ac74250c3297a0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p-Q5Lq65LiN5Lya5pWy5Luj56CB,size_12,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p>6. 寻址方式：<br>  寻址公式一：[立即数]<br>  读取内存的值：<br>  MOV EAX,DWORD  PTR  DS:[0x13FFC4]<br>  MOV EAX,DWORD  PTR  DS:[0x13FFC4]<br>  也就是将内存单元的数据给显示出来</p><pre><code>    向内存中写入数据：    MOV DWORD PTR DS:[0x13FFC4],eax    MOV DWORD PTR DS:[0x13FFC4],ebx    获取内存编号：    LEA EAX,DWORD PTR DS:[0X13FFC4]    LEA EAX,DWORD PTR DS:[ESP+8]    和读取内存的值不一样，这个是把内存单元的编号给显示出来的指令</code></pre><p>寻址公式二:[reg]<br>  注：reg 代表寄存器   可以是 8 个通用寄存器中的任意一个<br>  读取内存的值：<br>  MOV ECX,0x13FFD0<br>  MOV EAX,DWORD PTR DS:[ECX]<br>  把地址编号放到 ECX 这个寄存器里面，然后在通过这个寄存器找到内存，再放到 EAX 里面</p><pre><code>    向内存中写入数据：    MOV EDX,0x13FFD8    MOV DWORD PTR DS:[EDX],0x87654321    获取内存编号：    LEA EAX,DWORD PTR DS:[EDX]    MOV EAX,DWORD PTR DS:[EDX]</code></pre><p>寻址公式三:[reg + 立即数]<br>  读取内存的值:<br>  MOV ECX,0x13FFD0<br>  MOV EAX,DWORD PTR DS:[ECX+4]</p><pre><code>    向内存中写入数据:    MOV EDX,0x13FFD8    MOV DWORD PTR DS:[EDX+0xC],0x87654321    获取内存编号:    LEA EAX,DWORD PTR DS:[EDX+4]    MOV EAX,DWORD PTR DS:[EDX+4]</code></pre><p>寻址公式四:[reg+reg*{1,2,4,8}]<br>  读取内存的值<br>  MOV EAX,13FFC4<br>  MOV ECX,2<br>  MOV EDX,DWORD PTR DS:[EAX+ECX*4]<br>  注：1,2,4,8 是固定不变的，不要随意改</p><pre><code>    向内存中写入数据:    MOV EAX,13FFC4    MOV ECX,2    MOV DWORD PTR DS:[EAX+ECX*4],87654321    获取内存编号:    LEA EAX,DWORD PTR DS:[EAX+ECX*4]</code></pre><p>寻址公式五:[reg+reg*{1,2,4,8}+ 立即数]<br>  和寻址公式四同样的道理<br> 7. 堆栈</p><pre><code>    1.什么是堆栈    2.堆栈操作</code></pre><p>思考：<br>  假设我们需要一块内存，有如下的要求：<br>  1. 主要用于临时存储一些数据，如果数量很少就放到寄存器中<br>  2. 能够记录存了多少数据<br> 3. 能够非常快速的找到某个数据<br>那么堆栈的原理可以理解为：</p><pre><code>    1.BASE,TOP是2个32位的通用寄存器，里面存储的是内存单元编号（内存地址）    2.BASE里面存储了一个地址，记录的起始地址    3.TOP里面也存储了一个地址，记录的是结束的地址    4.存入数据的时候，TOP的值减4（为方便演示，每次存取都是4个字节）    5.释放数据的时候，TOP的值加4（为方便演示，每次存取都是4个字节）    6.如果要读取中间的某个数据的时候可以通过TOP或者BASE加上偏移的方式去读取    7.这个内存的读取方式有个学名：堆栈    堆栈的优点：临时存储大量的数据，便于查找。</code></pre><h1 id="标志寄存器"><a class="markdownIt-Anchor" href="#标志寄存器">#</a> 标志寄存器</h1><p>1.push 指令：<br>  PUSH r32<br>  PUSH r16<br>  PUSH m16<br>  PUSH m32<br>  PUSH imm8/imm16/imm32<br>2.POP 指令<br>  把堆栈里面的值取出来放到一个容器里<br>  POP r16<br>  POP r32<br>  POP m16<br>  POP m32<br>  PUSHAD、POPAD 这两个指令稍作了解即可<br> 3.EFLAGS 寄存器<br><img src="https://img-blog.csdnimg.cn/8cf8ce13d4d84ca89fb6898eb3455455.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p-Q5Lq65LiN5Lya5pWy5Luj56CB,size_14,color_FFFFFF,t_70,g_se,x_16" alt=""><br>  查看 DTDBUG 中的 EFLAGS 的值，然后转换成二进制的形式，并取出 CF/PF/AF/ZF/SF/OF 的值<br>记住这几个寄存器的位置和名称<br>  （1）进位标志 CF（Carry Flag）：如果运算结果的最高位产生了一个进位或借位，那么，其值为 1，否则其值为 0。<br>  MOV AL,0xEF<br>  MOV AL,0xFE<br>  ADD AL,2<br>  ADD AL,2<br>  （2）奇偶标志 PF（Parity Flag)：奇偶标志 PF 用于反映运算结果中 “1” 的个数的奇偶性。如果 “1” 的个数为偶数，则 PF 的值为 1，否则其值为 0。<br>  MOV AL,3<br>  MOV AL,3<br>  MOV AL,2</p><p>  （3）辅助进位标志 AF（Auxiliary Carry Flag）:<br> 在发生下列情况是，辅助进位标志 AF 的值被设置为 1，否则其值为 0：<br>  在字操作时，发生低字节向高字节进位或借位时；<br>  在字节操作时，发生低 4 位向高 4 位进位或借位时。<br>MOV EAX,0x55EEFFFF    MOV AX,5EFE    MOV AL,4E<br>ADD EAX,2         ADD AX,2      ADD AL,2</p><p>  （4）零标志 ZF（Zero Flag），零标志 ZF 用来反映运算是否为 0。如果运算结果为 0，则其值为 1，否则为 0。在判断运算结果是否为 0 时，可使用此标志位。<br>  XOR EAX,EAX<br>  MOV EAX,2<br>  SUB EAX,2<br>  （5）符号标志 SF（Sign Flag）：符号标志 SF 用来反映运算结果的符号位，它与运算结果的最高位相同。<br>  MOV AL,7F<br>  ADD AL,2</p><p>  （6）溢出标志 OF（Overflow Flag）：溢出标志 OF 用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF 的值被置为 1，否则，OF 的值被清为 0</p><p>4.ADC 指令：带进位加法<br>  格式：ADC  R/M,R/M/IMM   两边不能同时为内存   宽度要一样<br>  ADC AL,CL<br>  ADC BYTE PTR DS:[12FFC4],2<br>  ADC BYTE PTR DS:[12FFC4],AL</p><p>SBB 指令：带借位减法<br>  格式：SBB  R/M,R/M  两边不能同时为内存  宽度要一样<br>  SBB AL,CL<br>  SBB BYTE PTR DS:[12FFC4],2<br>  SBB BYTE PTR DS:[12FFC4],AL</p><p>XCHG 指令：交换数据<br>  格式：XCGH  R/M,R/M   两边不能同时为内存，宽度要一样<br>  XCGH AL,CL<br>  XCGH DWORD PTR DS:[12FFC4],EAX<br>  XCGH BYTE PTR DS:[12FFC4],AL</p><p>MOVS 指令：移动数据  内存 - 内存<br>  BYTE/WORD/DWORD<br>  MOVS BYTE PTR ES:[EDI],BYTE PTR DS:[ESI]  简写为：MOVSB<br>  MOVS WORD PTR ES:[EDI],BYTE PTR DS:[ESI]  简写为：MOVSW<br>  MOVS DWORD PTR ES:[EDI],BYTE PTR DS:[ESI] 简写为：MOVSD</p><p>5.STOS 指令：将 AI/AX/EAX 的值存储到 [EDI] 指定的内存单元<br>  STOS BYTE PTR ES:[EDI]   简写为 STOSB<br>  STOS WORD PTR ES:[EDI]   简写为 STOSW<br>  STOS DWORD PTR ES:[EDI]   简写为 STOSD</p><p>6.REP 指令：按计数寄存器（ECX）中指定的次数重复执行字符串指令<br>  MOV ECX,10<br>  REP MOVSD<br>  REP STOSD</p><p>本文图片取自我自己的 CSDN 博客的文章。</p>]]></content>
      
      
      <categories>
          
          <category> 逆向学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp datelab详解</title>
      <link href="/2022/04/05/csapp%20datelab%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/04/05/csapp%20datelab%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>  环境搭建用了我好久的时间，这个电脑我是真的服气，进入 vm 卡半天，刚搭建好的 Ubuntu 又遇到一些问题，直接寄了。没办法，只能再耗费一些时间重新搭建 Ubuntu， 结果又因为网卡，下载镜像就下了两天，搭建环境是真滴累。好在是经过一番努力终于将环境搞定，可以开始实验了。</p><h1 id="1bitxor"><a class="markdownIt-Anchor" href="#1bitxor">#</a> 1.bitXor</h1><p>  这道题的目的大致就是用于运算和非运算实现实现异或运算，难度还可以。  逻辑运算有三种基本运算：与、或、非，其他复杂的运算可以用这三种运算实现。</p><p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/1.363n09yqcnk0.webp" alt=""><br>  我推了几遍只推出一个公式，也就是 return (~x &amp; y)|(x &amp; ~y); 大致过程就是先画出真值表，然后推导公式，最后是画逻辑电路图，不过这一步就没必要了。但是这显然不符合题目要求，题目要求只用与和非，所以进一步推导的公式就是 return <sub>(</sub>x &amp; ~y) &amp; ~(x &amp; y); 后面这个式子我是从网上找的。</p><h1 id="2tmin"><a class="markdownIt-Anchor" href="#2tmin">#</a> <strong>2.tmin</strong></h1><p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/2.66yb55z398w0.webp" alt=""><br>  题目大致意思就是返回 32 位二进制补码的最小整数。<br>  首先要知道位移符的作用，对于一个 n 位的操作数 x，x&lt;&lt;k 操作会生成一个值：x 向左移动 k 位，丢弃最高的 k 位，并在右端补 k 个 0。位移量应该是一个 0~n-1 之间的值。计算机中的数都是用补码进行表示的，并且最高位是符号位，应用的运算系统是模运算。</p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/3.6bnxv13upo0.webp" style="zoom:80%;" />&emsp;&emsp;我们可以以这个图位例，使用的是4位二进制数，一共有16个机器数，因为最高位是符号位，所以0111是最大的正数，1000是最小的负数，而在模运算系统中，一个负数的补码等于模减该负数的绝对值，所以1000就是该4位二进制补码的最小整数。因此，对于32位二进制补码来说，最小整数就是0x80000000，1左移31位就得到了答案。<h1 id="3istmax"><a class="markdownIt-Anchor" href="#3istmax">#</a> <strong>3.isTmax</strong></h1><p>  这个题目的大意是：输入的 x 如果是最大值就返回 1，否则返回 0。</p><p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/4.786lnmp907s0.webp" alt=""><br>  我们知道 32 位二进制数的最大值是 0x7FFFFFFF, 则 x+1 就是超出了 int 的这个范围，因此 x 与 x+1 进行比较，x 就是最大值，那么返回值就是应该是 1。所以我们需要做的就是通过逻辑运算让返回值为 1。x+1 是 0x80000000，取反的话就和原来的最大值相同，又因为两个相同的值进行异或得到的结果为 0，所以异或结果再非运算就能得到结果为 1，写成式子就是：!(x<sup>~(x+1))。但是这个式子依然不能涵盖所有结果，还有一种特殊情况，那就是 x=-1 的时候，即 x=0xFFFFFFFF，x+1=0x00000000，取反结果和 x 一样，因此按上述方法运算得到的结果也是 1，但实际上 x=-1 是最小值，输出应该为 0，所以我们应该排除 - 1 这种情况，因此使用与运算就是！(x</sup>~(x+1))&amp;!!(x+1), 在 x+1 前面加上两个非，这样就可以避免 - 1 这种特殊情况了。</p><h1 id="4all0ddbits"><a class="markdownIt-Anchor" href="#4all0ddbits">#</a> <strong>4.ALL0ddBits</strong></h1><p>  这道题的大致意思就是 x 的奇数位上如果都是 1，则返回 1，反之则返回 0。</p><p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/5.6mb6nnvd7vk0.webp" alt=""><br>  那么关键就是判定奇数位上是否都为 1，只要有一个不为 1，那么这个数字就不符合要求了，那么判断它是不是 1，只需要和 1 进行与运算就行了，为 1 则得出 1，为 0 则得出 0，因此 0xAAAAAAAA 恰好符合条件，拿 0xAAAAAAAA 和 x 进行与运算，如果 x 符合条件，那么输出的结果依然是 0xAAAAAAAA，然后让结果继续和 0xAAAAAAAA 进行异或运算，一个值与它自身异或得到的结果为 0，最后！0 即为 1，如果 x 不符合条件，那么最后输出的结果就是 0。最后得到的式子就是：return !((0xAAAAAAAA &amp; x) ^ 0xAAAAAAAA);</p><h1 id="5negate"><a class="markdownIt-Anchor" href="#5negate">#</a> <strong>5.negate</strong></h1><p>  这道题的大致意思就是返回一个值的负数，这绝对是最简单的题，那就短话短说。</p><p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/6.34rl6www7u60.webp" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/7.2c9aqnxv2gsg.webp" style="zoom:80%;" /></p><p>  还得是看这张表，数值取反后加 1 就是对应的负数了。  最后得到的式子为：return ~x + 1 ;</p><h1 id="6isasciidigit"><a class="markdownIt-Anchor" href="#6isasciidigit">#</a> <strong>6.isAsciiDigit</strong></h1><p>  这道题也是挺简单的，题目大致意思是输入的 x 如果大于 0x30 且小于 0x39，则输出 1，反之输出 0，并且有提示这个范围就是‘0’到‘9’的 ASCII 码值。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/8.1w1stnrmxdk0.webp" alt=""><br>  因为计算机在比较大小的时候，是做减法，两数相减，然后判断结果是否为正数，因此我们可以将 x 与范围边界进行减法，而减法又可以转换为加法，所以就是 x + (~48 + 1) 和 (~x + 1) + 57，48 和 57 是‘0’和‘9’对应的 ASCII 值，又因为计算机中的数由补码表示，正数的符号位为 0，负数的符号位为 1，故我们可以将前面两个算式得到的结果进行移位，假设 x 在范围里面，那么那两个算式的结果移位之后都应该为 0，两个结果都加上 1，然后进行与运算，就能得到返回值为 1，如果 x 不在范围内，返回值就是 0。<br>  最后得到的返回式子为 return (((x + (~48 + 1))&gt;&gt;31)+1) &amp; ((((~x + 1) + 57)&gt;&gt;31)+1);</p><h1 id="7conditional"><a class="markdownIt-Anchor" href="#7conditional">#</a> <strong>7.conditional</strong></h1><p>  这道题的大致意思就是用逻辑运算和取反、位移等实现 x ? y : z。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/9.1kg7qeqcoetc.webp" alt=""><br>  x ? y : z 的原理就是:<br>   （1）判断 x 的真假；<br>   （2）如果 x 为真，那么就输出 y；<br>   （3）如果 x 为假，那么输出 z。<br>  那么这道题也就很好理解了，思路首先就是判断 x 的真假，然后选择输出 y 还是 z。判断 x 真假很好办，两次 “非” 运算就能得出真假。之后，将上一步结果取反加 1，也就是换算成结果的负数，如果结果为 1（真），那么转换成 - 1，再与 y 进行与运算，就可以保留 y。然后就是 z，z 与第一步结果的取反进行与运算，如果第一步结果为 1，那么取反之后就是 0，这样就可以消掉 z。最后总结，x 为真：保留 y、消掉 z；x 为假：消掉 y，保留 z。   根据上述描述得到的式子：return ((~A + 1) &amp; y) + (<sub>(</sub>A + 1) &amp; z);</p><h1 id="8islessorequal"><a class="markdownIt-Anchor" href="#8islessorequal">#</a> <strong>8.isLessOrEqual</strong></h1><p>  这道题的大致意思就是使用基本运算实现 “x&lt;=y”，还是有一定难度的。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/10.db1kj4asbuw.webp" alt=""><br>  计算机在比较两个数的大小的时候会先进行减法运算，然后判断正负，所以我们可以按照这个思路来解题，但是用减法的话需要考虑溢出，所以首先判断两个数的符号，c1 是 x+，y-，c2 是 x-,y+。因为我们是用 y 减 x，所以当 c1 为真且 d 为假的时候就发生了溢出，这时候计算得到的结果就与实际情况相反，所以要避免。在 c2 成立的时候，因为是负数和正数进行比较，所以整个运算就直接成立。  最后得到的返回运算式就是 return (!d &amp; !c1) | c2;</p><h1 id="9logicalneg"><a class="markdownIt-Anchor" href="#9logicalneg">#</a> <strong>9.logicalNeg</strong></h1><p>  这道题的大致意思就是实现非运算（!），还是很有难度的。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/11.v6b4eso67ts.webp" alt=""><br>  非运算就是非 0 为 1，非 1 为 0，除了 0 这种特殊情况，其它数取反加 1 都是原来的数的相反数，相反数与原来的数进行位或运算得到的结果符号位都为 1，然后再进行位移 31 位再加 1，得到的结果就是 0。对于 0 来说，取反加 1 再位或得到的结果仍然为 0，右移 31 位再加 1 就是 1。</p><h1 id="10howmanybits"><a class="markdownIt-Anchor" href="#10howmanybits">#</a> <strong>10.howManyBits</strong></h1><p>  这道题的大致意思就是一个数的补码最少可以用多少位来表示。比如 12，二进制形式 0x1100，再加上一位符号位，就是 5 位，再看 0，用二进制表示就是 0x0，只有一位，-1 用二进制表示，是 1，也只有一位。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/12.59q9mec5pt80.webp" alt=""><br>  这道题我自己做是没有任何思路，看着别人的 wp 我才能搞懂。  大致分为 3 种情况：0、-1 和其它数。  0 只用一个符号位就能够表示，-1 和 0 一样，-1 的二进制补码是全 1，取反之后就是 0，所以也能用一个符号位表示。  我们主要考虑一般的数，一般的数取反之后和取反之前都可以用相同的符号位进行表示。  对于传输进去的负数，进行取反，正数就不用管。  然后是判断高 16 位有没有 1，接着判断 8 位，然后是 4 位、2 位、1 位。</p><h1 id="11floatscale2"><a class="markdownIt-Anchor" href="#11floatscale2">#</a> <strong>11.floatScale2</strong></h1><p>  这道题是求浮点数乘以 2。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/13.1xmf11aubrcw.webp" alt=""><br>  对于一般的浮点数乘以二来说，是阶码加一，因为不同类型的数相乘是转化成同一种类型的，浮点数相乘是尾数相乘除、阶码相加减，2 的阶码是 1，尾数为 0。<br>  因此我们只需要考虑特殊情况就可以了：<br>  （1）0 乘以 2<br>  （2）无穷大或 NaN（非数）乘以 2；<br>  （3) 非规格化数乘以 2；<br>  我们看上述的代码，首先提取出阶码部分和尾数部分，然后再判断 uf 是否为 0 或无穷大或 NaN 或非规格化数，如果 uf 为无穷大或 NaN 就直接返回，乘以二之后依旧是原数。为 0 和非规格化数时，尾数只需左移一位，0 左移还是 0，非规格化数左移一位后阶码加 1，变成了规格化数。</p><h1 id="12floatfloat2int"><a class="markdownIt-Anchor" href="#12floatfloat2int">#</a> <strong>12.floatFloat2Int</strong></h1><p>  这道题是将浮点数转化成整形。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/14.1yt1vvu91fgg.webp" alt=""><br>  将浮点型转化为整形，会舍去小数，但是浮点型所表示的范围要比整形所表示的范围大，所以某些浮点型的值超过了整形所能表示的范围，根据题目要求，就需要返回 0x80000000 了，并且当浮点型小于 1 时，转化成整形就是 0。和上一道题目类似，首先提取出阶码和尾数，并且还要判断 uf 的符号位。如果阶码超过整形所能返回的最大值，则返回题目所要求的数值，如果阶码小于 127，也就是 uf 小于 1，则返回 0。如果是一般范围内的浮点数，则去掉小数转换成整形。</p><h1 id="13floatpower2"><a class="markdownIt-Anchor" href="#13floatpower2">#</a> <strong>13.floatPower2</strong></h1><p>  这道题是求 2 的 x 次方，并以浮点数的形式输出。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/15.62dhb4518yg0.webp" alt=""><br>  这个很好理解，阶码的范围就是 - 126~127，小于 - 126 返回 0，大于 127 返回无穷大，如果是正确范围内的，则返回 x 加上偏移量后再左移 23 位，得到这个以浮点数形式输出的 2 的 x 次方。</p><p>最后附上测试表：<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/16.hikvbikrfzs.webp" alt=""><br>  我的 csapp 实验一的旅程到此就结束了，我最深的感触就是这门学科真的很有难度，但是也带给我很大的精神愉悦，特别是在做实验的时候，每做出一道题并且通过测试之后，我真的很开心，比我打一把游戏胜利之后都要开心，因为我确实是看到了自己的进步。但是它也使我认识到了和别人的差距，不努力是真的不行，和别人的差距只会越来越大。并且，这次实验我的理解还不够深，特别是最后四道题，我看着别人写的 wp 一步一步来的，学的不精是我的问题，以后更是不能放弃，学得更多之后，还要回过头来再把这个实验刷几遍，必须学得透彻之后我才能走的更远。<br>  以后会持续更新 csapp 的，还有更多的实验等着我呢！</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> csapp datelab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编基础-菜鸟的入门之路</title>
      <link href="/2022/02/23/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80-%E8%8F%9C%E9%B8%9F%E7%9A%84%E5%85%A5%E9%97%A8%E4%B9%8B%E8%B7%AF/"/>
      <url>/2022/02/23/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80-%E8%8F%9C%E9%B8%9F%E7%9A%84%E5%85%A5%E9%97%A8%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>​初学汇编，本篇文章的内容主要包含一些基础的汇编知识以及个人的见解，难免会有出错的地方，望各位师傅多多包涵。</p><h2 id="一-进制和进制运算"><a class="markdownIt-Anchor" href="#一-进制和进制运算">#</a> 一、进制和进制运算</h2><p>​1. 每一种进制都是完美的，想要学好进制首先要忘掉十进制，也要忘掉进制之间的转化。<br>​2. 进制的定义：<br>​（1）八进制：由八个符号组成，分别是 01234567，逢八进一。<br>​（2）十进制：由十个符号组成，分别是 0123456789，逢十进一。<br>​（3）N 进制：由 N 个符号组成，逢 N 进一。<br>​3. 进制的运算<br>​进制的运算的本质就是查数。<br>​十进制运算用十进制运算表，那八进制就用八进制的运算表。<br>​每一种进制自身都是一个完整的体系，可以直接做各种运算。</p><h2 id="二-二进制简写形式"><a class="markdownIt-Anchor" href="#二-二进制简写形式">#</a> 二、二进制简写形式</h2><p>​1. 计算机为什么要使用二进制<br>​（1）计算机是需要用电的，电路只有两种状态：<br>​                               1      真（通电）<br>​                               0      假（未通电）<br>​          计算机中存储的任何文件，接收的任何指令，都是由 0 和 1 组成的。<br>​（2）16 进制在计算机中可以看成二进制的简写形式</p><p>​二进制         十六进制                   二进制                  十六进制</p><p>​0000             0                             1001                        9</p><p>​0001             1                             1010                        A</p><p>​0010             2                             1011                        B</p><p>​0011             3                              1100                       C</p><p>​0100             4                              1101                       D</p><p>​0101             5                              1110                       E</p><p>​0110             6                               1111                       F</p><p>​0111              7</p><p>​1000             8<br>​这些转换是需要记住的，对以后的学习会有很大的帮助</p><h2 id="三-数据宽度"><a class="markdownIt-Anchor" href="#三-数据宽度">#</a> 三、数据宽度</h2><p>​数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的限制，数据都是有长度限制的，我们称之为数据宽度，超过最多宽度的数据会被丢掉。</p><p>​在计算机中常见的数据宽度：<br>​首先就是位（bit），然后是字节（byte），1 字节 = 8 位，再者就是字（word），1 字 = 16 位，双字（Doubleword）=32 位。</p><p>​存储范围<br>​在计算机中，每个位能存一个 0 或 1，另外，在二进制中四位 1 等于十六进制中的一个 F，那么我们就能根据这些能够知道每个宽度所能存储的范围，<br>​字节：0~0xFF<br>​字：0~0xFFFF<br>​双字：0~0xFFFFFFFF</p><h2 id="四-有符号数和无符号数"><a class="markdownIt-Anchor" href="#四-有符号数和无符号数">#</a> 四、有符号数和无符号数</h2><p>​在计算机中，所有东西都是用二进制的 0 和 1 来进行存储的，比如说一个逗号、一个程序、一个有符号数，一个无符号数等等，都是用 0 和 1 进行存储的。所以在进行编码的时候，会按照相应的编码规则进行编码，有符号数按有符号数的编码规则，无符号数按无符号数的编码规则，所以说给你一串数字：1 0 0 1 1 1 0 1 0，告诉你他是个文本，那么他可能就代表 0 一个逗号。不谈这个文本，如果它是一个无符号数，我们就需要按照无符号数的编码规则去进行编码，既然是无符号，顾名思义，可以直接转换成十六进制数，或者是十进制数，转换成 16 进制就是 0x9A   十进制就是 154。<br>​但如果是有符号数的话，因为是有正数和负数之分的，所以编码规则相对不同，即正数和负数的编码不同。<br>​有符号数，拿上面的一串数字来说：0 0 0 1 1 0 1 0，最高位是 1，这个数就是负数，最高数是 0，这个数就是正数，那么很显然这个是正数。至于有、无符号数是怎么进行编码的，就需要了解到原码、补码和反码了。</p><h2 id="五-原码-补码和反码"><a class="markdownIt-Anchor" href="#五-原码-补码和反码">#</a> 五、原码、补码和反码</h2><p>​1. 编码规则<br>​首先在计算机中，靠二进制数 0 和 1 存储信息，例如 0 1 0 1 0 1 0 1，不同的文件有着不同的编码规则，也就是说这些 0 和 1 按照编码规则，解析成文本，视频，音乐等等。</p><p>​2. 原码、反码和补码<br>​原码：最高位为符号位，其余各位为数值本身的绝对值</p><p>​反码：<br>​正数：反码与原码相同<br>​负数：符号位为 1，其余位对原码取反</p><p>​补码：<br>​正数：补码与原码相同<br>​负数：符号位为 1，其余位对原码取反加 1</p><p>​了解到原码、反码和补码之后，我们也就能够轻松地理解有、无符号数是怎样进行编码的了。</p><h2 id="六-计算机做的运算"><a class="markdownIt-Anchor" href="#六-计算机做的运算">#</a> 六、计算机做的运算</h2><p>​1. 与运算（and&amp;）<br>​       两个位都为 1 时，结果才为 1</p><p>​2. 或运算（or|）<br>​      只要有一个为 1 就是 1</p><p>​3. 异或运算（xor^）<br>不一样的时候是 1</p><p>​4. 非运算（not~）<br>​      0 就是 1    1 就是 0</p><p>​5. 移位运算<br>​左移（shl &lt;&lt;）<br>​各二进位全部左移若干位，高位丢弃，低位补 0<br>​eg：1101 1000    左移 2 位为：0110 0000</p><p>​右移（shr    sar    &gt;&gt;）<br>​各二进位全部右移若干位，低位丢弃，高位补 0 或者补符号位<br>​注：右移是分两种情况的，就是高位补 0 和补符号位</p><p>​shr   1101 0101        右移    0011 0101<br>​对应 C 语言（&gt;&gt;）<br>​unsigned int a= 10；<br>​printf(&quot;%d\n&quot;,a&gt;&gt;2);</p><p>​sar   1101 0101        右移    1111 0101<br>​对应 C 语言（&gt;&gt;）<br>​int a=10;<br>​printf(&quot;%d\n&quot;,a&gt;&gt;2):</p><p>​C 语言中，有符号的右移是补符号位，无符号位的右移是补 0。上述字母代表的是汇编中对应的指令，符号代表的是 C 语言中对应的指令。所以说计算机做的所有运算归根到底都是位运算。</p><h2 id="七-位运算加减乘除用位运算来实现四则运算"><a class="markdownIt-Anchor" href="#七-位运算加减乘除用位运算来实现四则运算">#</a> 七、位运算加减乘除（用位运算来实现四则运算）</h2><p>​不考虑进位的情况下，异或的结果和加结果一样。所以计算机在进行加法的时候的大致过程是这样的：<br>​举个例子：4+5=？<br>​（1）首先，两个二进制数进行异或<br>​0000  0100<br>​0000  0101   异或<br>​————————<br>​0000  0001<br>​（2）其次，两个数进行与运算<br>​0000  0100<br>​0000  0101   与<br>​————————<br>​0000  0100<br>​（3）因为与运算是计算机能够判断在进行加法时是否发生了进位的运算，所如果发生了进位，那么就会再次进行异或运算，如果没有进位，第一次进行的异或运算的结果就是真实的结果，以下是发生了进位之后的异或运算<br>​0000 0001                 —&gt; 第一次异或的结果<br>​0000 1000   异或        —&gt; 上次与运算的结果左移一位之后<br>​————————<br>​0000  1001<br>​（4）再次进行与运算，判断上次异或是否发生进位，没有进位，直接出结果，进位了，继续进行异或运算<br>​0000  0001<br>​0000  1000     与<br>​————————<br>​0000  0000</p><p>​注：（1）与运算结果有 1 的地方就是发生了进位，如果没有发生进位，那么结果就应该全部为 0<br>​      （2）第二次异或之所以要加左移一位的结果是因为与运算结果为 1 的地方本应该是要进一位的</p><p>​其他运算的运算过程<br>​4-5=4+（-5）<br>​减法就是加法，所以运算的过程和加法基本是一致的，<br>​至于乘法，乘法就是加法，x*y 的本质就是 x 个 y 相加，<br>​除法的本质就是减法，X/Y 其实就是 X 能减去多少个 Y，<br>​归根结底，四则运算就是加法的运算，用计算机的位运算进行运算，本质都是一样的。<br>​所以说计算机可以通过位运算来进行最基本的四则运算，那么也就可以以此进行一些更复杂的运算。</p><h2 id="八-汇编环境搭建"><a class="markdownIt-Anchor" href="#八-汇编环境搭建">#</a> 八、汇编环境搭建</h2><p>​汇编环境搭建<br>​1. 学汇编不是为了写代码<br>​学汇编对学习应用开发和安全相关方面都有帮助<br>​2. 环境配置<br>​下载 DTDebug，在滴水官网下载，下载完成之后进行简单配置，在 options—&gt;Appearance—&gt;Directories 中，将 UDD 和 Plugin 的路径指向对应名称的目录中。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 菜鸟入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈博客搭建</title>
      <link href="/2022/02/18/%E6%B5%85%E8%B0%88%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/02/18/%E6%B5%85%E8%B0%88%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>第一次接触博客，不知道说啥，好紧张。<br>年前花了几天时间在网上找课程，搭建最基础的博客，然后就是漫长的主题美化，中间一直耽搁着，直到今天才顺利的把主题美化好，各种该有的全部添了上去，不该有的也弄了个七七八八。<br>我用的是 butterfly 主题，当时满世界的找主题，唯有这款主题深深的吸引了我，但是这个主题对于新手十分的不友好，我差点就删档重新来过，好在经历了各种错误之后，还是将美化给做完了。<br>还有就是我要开始写博客了，学习怎样写博客，也不失为一种乐趣，这也是最最基本的事情了。就目前看来，Sublime Text 确实用的不是很习惯。<br>不说了，我要去下载 Typora 了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 浅谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
