<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>csapp datelab详解</title>
      <link href="/2022/04/05/csapp%20datelab%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/04/05/csapp%20datelab%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>环境搭建用了我好久的时间，这个电脑我是真的服气，进入 vm 卡半天，刚搭建好的 Ubuntu 又遇到一些问题，直接寄了。没办法，只能再耗费一些时间重新搭建 Ubuntu， 结果又因为网卡，下载镜像就下了两天，搭建环境是真滴累。好在是经过一番努力终于将环境搞定，可以开始实验了。</p><h1 id="1bitxor"><a class="markdownIt-Anchor" href="#1bitxor">#</a> <strong>1.bitXor</strong></h1><p>这道题的目的大致就是用于运算和非运算实现实现异或运算，难度还可以。  逻辑运算有三种基本运算：与、或、非，其他复杂的运算可以用这三种运算实现。</p><p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/1.363n09yqcnk0.webp" alt=""><br>  我推了几遍只推出一个公式，也就是 return (~x &amp; y)|(x &amp; ~y); 大致过程就是先画出真值表，然后推导公式，最后是画逻辑电路图，不过这一步就没必要了。但是这显然不符合题目要求，题目要求只用与和非，所以进一步推导的公式就是 return <sub>(</sub>x &amp; ~y) &amp; ~(x &amp; y); 后面这个式子我是从网上找的。</p><h1 id="2tmin"><a class="markdownIt-Anchor" href="#2tmin">#</a> <strong>2.tmin</strong></h1><p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/2.66yb55z398w0.webp" alt=""><br>  题目大致意思就是返回 32 位二进制补码的最小整数。<br>  首先要知道位移符的作用，对于一个 n 位的操作数 x，x&lt;&lt;k 操作会生成一个值：x 向左移动 k 位，丢弃最高的 k 位，并在右端补 k 个 0。位移量应该是一个 0~n-1 之间的值。计算机中的数都是用补码进行表示的，并且最高位是符号位，应用的运算系统是模运算。</p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/3.6bnxv13upo0.webp" style="zoom:80%;" />&emsp;&emsp;我们可以以这个图位例，使用的是4位二进制数，一共有16个机器数，因为最高位是符号位，所以0111是最大的正数，1000是最小的负数，而在模运算系统中，一个负数的补码等于模减该负数的绝对值，所以1000就是该4位二进制补码的最小整数。因此，对于32位二进制补码来说，最小整数就是0x80000000，1左移31位就得到了答案。<h1 id="3istmax"><a class="markdownIt-Anchor" href="#3istmax">#</a> <strong>3.isTmax</strong></h1><p>这个题目的大意是：输入的 x 如果是最大值就返回 1，否则返回 0。</p><p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/4.786lnmp907s0.webp" alt=""><br>  我们知道 32 位二进制数的最大值是 0x7FFFFFFF, 则 x+1 就是超出了 int 的这个范围，因此 x 与 x+1 进行比较，x 就是最大值，那么返回值就是应该是 1。所以我们需要做的就是通过逻辑运算让返回值为 1。x+1 是 0x80000000，取反的话就和原来的最大值相同，又因为两个相同的值进行异或得到的结果为 0，所以异或结果再非运算就能得到结果为 1，写成式子就是：!(x<sup>~(x+1))。但是这个式子依然不能涵盖所有结果，还有一种特殊情况，那就是 x=-1 的时候，即 x=0xFFFFFFFF，x+1=0x00000000，取反结果和 x 一样，因此按上述方法运算得到的结果也是 1，但实际上 x=-1 是最小值，输出应该为 0，所以我们应该排除 - 1 这种情况，因此使用与运算就是！(x</sup>~(x+1))&amp;!!(x+1), 在 x+1 前面加上两个非，这样就可以避免 - 1 这种特殊情况了。</p><h1 id="4all0ddbits"><a class="markdownIt-Anchor" href="#4all0ddbits">#</a> <strong>4.ALL0ddBits</strong></h1><p>这道题的大致意思就是 x 的奇数位上如果都是 1，则返回 1，反之则返回 0。</p><p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/5.6mb6nnvd7vk0.webp" alt=""><br>  那么关键就是判定奇数位上是否都为 1，只要有一个不为 1，那么这个数字就不符合要求了，那么判断它是不是 1，只需要和 1 进行与运算就行了，为 1 则得出 1，为 0 则得出 0，因此 0xAAAAAAAA 恰好符合条件，拿 0xAAAAAAAA 和 x 进行与运算，如果 x 符合条件，那么输出的结果依然是 0xAAAAAAAA，然后让结果继续和 0xAAAAAAAA 进行异或运算，一个值与它自身异或得到的结果为 0，最后！0 即为 1，如果 x 不符合条件，那么最后输出的结果就是 0。最后得到的式子就是：return !((0xAAAAAAAA &amp; x) ^ 0xAAAAAAAA);</p><h1 id="5negate"><a class="markdownIt-Anchor" href="#5negate">#</a> <strong>5.negate</strong></h1><p>这道题的大致意思就是返回一个值的负数，这绝对是最简单的题，那就短话短说。</p><p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/6.34rl6www7u60.webp" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/7.2c9aqnxv2gsg.webp" style="zoom:80%;" /></p><p>还得是看这张表，数值取反后加 1 就是对应的负数了。  最后得到的式子为：return ~x + 1 ;</p><h1 id="6isasciidigit"><a class="markdownIt-Anchor" href="#6isasciidigit">#</a> <strong>6.isAsciiDigit</strong></h1><p>这道题也是挺简单的，题目大致意思是输入的 x 如果大于 0x30 且小于 0x39，则输出 1，反之输出 0，并且有提示这个范围就是‘0’到‘9’的 ASCII 码值。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/8.1w1stnrmxdk0.webp" alt=""><br>  因为计算机在比较大小的时候，是做减法，两数相减，然后判断结果是否为正数，因此我们可以将 x 与范围边界进行减法，而减法又可以转换为加法，所以就是 x + (~48 + 1) 和 (~x + 1) + 57，48 和 57 是‘0’和‘9’对应的 ASCII 值，又因为计算机中的数由补码表示，正数的符号位为 0，负数的符号位为 1，故我们可以将前面两个算式得到的结果进行移位，假设 x 在范围里面，那么那两个算式的结果移位之后都应该为 0，两个结果都加上 1，然后进行与运算，就能得到返回值为 1，如果 x 不在范围内，返回值就是 0。<br>  最后得到的返回式子为 return (((x + (~48 + 1))&gt;&gt;31)+1) &amp; ((((~x + 1) + 57)&gt;&gt;31)+1);</p><h1 id="7conditional"><a class="markdownIt-Anchor" href="#7conditional">#</a> <strong>7.conditional</strong></h1><p>这道题的大致意思就是用逻辑运算和取反、位移等实现 x ? y : z。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/9.1kg7qeqcoetc.webp" alt=""><br>  x ? y : z 的原理就是:<br>   （1）判断 x 的真假；<br>   （2）如果 x 为真，那么就输出 y；<br>   （3）如果 x 为假，那么输出 z。<br>  那么这道题也就很好理解了，思路首先就是判断 x 的真假，然后选择输出 y 还是 z。判断 x 真假很好办，两次 “非” 运算就能得出真假。之后，将上一步结果取反加 1，也就是换算成结果的负数，如果结果为 1（真），那么转换成 - 1，再与 y 进行与运算，就可以保留 y。然后就是 z，z 与第一步结果的取反进行与运算，如果第一步结果为 1，那么取反之后就是 0，这样就可以消掉 z。最后总结，x 为真：保留 y、消掉 z；x 为假：消掉 y，保留 z。   根据上述描述得到的式子：return ((~A + 1) &amp; y) + (<sub>(</sub>A + 1) &amp; z);</p><h1 id="8islessorequal"><a class="markdownIt-Anchor" href="#8islessorequal">#</a> <strong>8.isLessOrEqual</strong></h1><p>这道题的大致意思就是使用基本运算实现 “x&lt;=y”，还是有一定难度的。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/10.db1kj4asbuw.webp" alt=""><br>  计算机在比较两个数的大小的时候会先进行减法运算，然后判断正负，所以我们可以按照这个思路来解题，但是用减法的话需要考虑溢出，所以首先判断两个数的符号，c1 是 x+，y-，c2 是 x-,y+。因为我们是用 y 减 x，所以当 c1 为真且 d 为假的时候就发生了溢出，这时候计算得到的结果就与实际情况相反，所以要避免。在 c2 成立的时候，因为是负数和正数进行比较，所以整个运算就直接成立。  最后得到的返回运算式就是 return (!d &amp; !c1) | c2;</p><h1 id="9logicalneg"><a class="markdownIt-Anchor" href="#9logicalneg">#</a> <strong>9.logicalNeg</strong></h1><p>  这道题的大致意思就是实现非运算（!），还是很有难度的。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/11.v6b4eso67ts.webp" alt=""><br>  非运算就是非 0 为 1，非 1 为 0，除了 0 这种特殊情况，其它数取反加 1 都是原来的数的相反数，相反数与原来的数进行位或运算得到的结果符号位都为 1，然后再进行位移 31 位再加 1，得到的结果就是 0。对于 0 来说，取反加 1 再位或得到的结果仍然为 0，右移 31 位再加 1 就是 1。</p><h1 id="10howmanybits"><a class="markdownIt-Anchor" href="#10howmanybits">#</a> <strong>10.howManyBits</strong></h1><p>  这道题的大致意思就是一个数的补码最少可以用多少位来表示。比如 12，二进制形式 0x1100，再加上一位符号位，就是 5 位，再看 0，用二进制表示就是 0x0，只有一位，-1 用二进制表示，是 1，也只有一位。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/12.59q9mec5pt80.webp" alt=""><br>  这道题我自己做是没有任何思路，看着别人的 wp 我才能搞懂。  大致分为 3 种情况：0、-1 和其它数。  0 只用一个符号位就能够表示，-1 和 0 一样，-1 的二进制补码是全 1，取反之后就是 0，所以也能用一个符号位表示。  我们主要考虑一般的数，一般的数取反之后和取反之前都可以用相同的符号位进行表示。  对于传输进去的负数，进行取反，正数就不用管。  然后是判断高 16 位有没有 1，接着判断 8 位，然后是 4 位、2 位、1 位。</p><h1 id="11floatscale2"><a class="markdownIt-Anchor" href="#11floatscale2">#</a> <strong>11.floatScale2</strong></h1><p>这道题是求浮点数乘以 2。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/13.1xmf11aubrcw.webp" alt=""><br>  对于一般的浮点数乘以二来说，是阶码加一，因为不同类型的数相乘是转化成同一种类型的，浮点数相乘是尾数相乘除、阶码相加减，2 的阶码是 1，尾数为 0。<br>  因此我们只需要考虑特殊情况就可以了：<br>  （1）0 乘以 2<br>  （2）无穷大或 NaN（非数）乘以 2；<br>  （3) 非规格化数乘以 2；<br>  我们看上述的代码，首先提取出阶码部分和尾数部分，然后再判断 uf 是否为 0 或无穷大或 NaN 或非规格化数，如果 uf 为无穷大或 NaN 就直接返回，乘以二之后依旧是原数。为 0 和非规格化数时，尾数只需左移一位，0 左移还是 0，非规格化数左移一位后阶码加 1，变成了规格化数。</p><h1 id="12floatfloat2int"><a class="markdownIt-Anchor" href="#12floatfloat2int">#</a> <strong>12.floatFloat2Int</strong></h1><p>这道题是将浮点数转化成整形。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/14.1yt1vvu91fgg.webp" alt=""><br>  将浮点型转化为整形，会舍去小数，但是浮点型所表示的范围要比整形所表示的范围大，所以某些浮点型的值超过了整形所能表示的范围，根据题目要求，就需要返回 0x80000000 了，并且当浮点型小于 1 时，转化成整形就是 0。和上一道题目类似，首先提取出阶码和尾数，并且还要判断 uf 的符号位。如果阶码超过整形所能返回的最大值，则返回题目所要求的数值，如果阶码小于 127，也就是 uf 小于 1，则返回 0。如果是一般范围内的浮点数，则去掉小数转换成整形。</p><h1 id="13floatpower2"><a class="markdownIt-Anchor" href="#13floatpower2">#</a> <strong>13.floatPower2</strong></h1><p>这道题是求 2 的 x 次方，并以浮点数的形式输出。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/15.62dhb4518yg0.webp" alt=""><br>  这个很好理解，阶码的范围就是 - 126~127，小于 - 126 返回 0，大于 127 返回无穷大，如果是正确范围内的，则返回 x 加上偏移量后再左移 23 位，得到这个以浮点数形式输出的 2 的 x 次方。</p><p>最后附上测试表：<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/16.hikvbikrfzs.webp" alt=""><br>  我的 csapp 实验一的旅程到此就结束了，我最深的感触就是这门学科真的很有难度，但是也带给我很大的精神愉悦，特别是在做实验的时候，每做出一道题并且通过测试之后，我真的很开心，比我打一把游戏胜利之后都要开心，因为我确实是看到了自己的进步。但是它也使我认识到了和别人的差距，不努力是真的不行，和别人的差距只会越来越大。并且，这次实验我的理解还不够深，特别是最后四道题，我看着别人写的 wp 一步一步来的，学的不精是我的问题，以后更是不能放弃，学得更多之后，还要回过头来再把这个实验刷几遍，必须学得透彻之后我才能走的更远。<br>  以后会持续更新 csapp 的，还有更多的实验等着我呢！</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> csapp datelab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编基础-菜鸟的入门之路</title>
      <link href="/2022/02/23/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80-%E8%8F%9C%E9%B8%9F%E7%9A%84%E5%85%A5%E9%97%A8%E4%B9%8B%E8%B7%AF/"/>
      <url>/2022/02/23/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80-%E8%8F%9C%E9%B8%9F%E7%9A%84%E5%85%A5%E9%97%A8%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>​初学汇编，本篇文章的内容主要包含一些基础的汇编知识以及个人的见解，难免会有出错的地方，望各位师傅多多包涵。</p><h2 id="一-进制和进制运算"><a class="markdownIt-Anchor" href="#一-进制和进制运算">#</a> 一、进制和进制运算</h2><p>​1. 每一种进制都是完美的，想要学好进制首先要忘掉十进制，也要忘掉进制之间的转化。<br>​2. 进制的定义：<br>​（1）八进制：由八个符号组成，分别是 01234567，逢八进一。<br>​（2）十进制：由十个符号组成，分别是 0123456789，逢十进一。<br>​（3）N 进制：由 N 个符号组成，逢 N 进一。<br>​3. 进制的运算<br>​进制的运算的本质就是查数。<br>​十进制运算用十进制运算表，那八进制就用八进制的运算表。<br>​每一种进制自身都是一个完整的体系，可以直接做各种运算。</p><h2 id="二-二进制简写形式"><a class="markdownIt-Anchor" href="#二-二进制简写形式">#</a> 二、二进制简写形式</h2><p>​1. 计算机为什么要使用二进制<br>​（1）计算机是需要用电的，电路只有两种状态：<br>​                               1      真（通电）<br>​                               0      假（未通电）<br>​          计算机中存储的任何文件，接收的任何指令，都是由 0 和 1 组成的。<br>​（2）16 进制在计算机中可以看成二进制的简写形式</p><p>​二进制         十六进制                   二进制                  十六进制</p><p>​0000             0                             1001                        9</p><p>​0001             1                             1010                        A</p><p>​0010             2                             1011                        B</p><p>​0011             3                              1100                       C</p><p>​0100             4                              1101                       D</p><p>​0101             5                              1110                       E</p><p>​0110             6                               1111                       F</p><p>​0111              7</p><p>​1000             8<br>​这些转换是需要记住的，对以后的学习会有很大的帮助</p><h2 id="三-数据宽度"><a class="markdownIt-Anchor" href="#三-数据宽度">#</a> 三、数据宽度</h2><p>​数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的限制，数据都是有长度限制的，我们称之为数据宽度，超过最多宽度的数据会被丢掉。</p><p>​在计算机中常见的数据宽度：<br>​首先就是位（bit），然后是字节（byte），1 字节 = 8 位，再者就是字（word），1 字 = 16 位，双字（Doubleword）=32 位。</p><p>​存储范围<br>​在计算机中，每个位能存一个 0 或 1，另外，在二进制中四位 1 等于十六进制中的一个 F，那么我们就能根据这些能够知道每个宽度所能存储的范围，<br>​字节：0~0xFF<br>​字：0~0xFFFF<br>​双字：0~0xFFFFFFFF</p><h2 id="四-有符号数和无符号数"><a class="markdownIt-Anchor" href="#四-有符号数和无符号数">#</a> 四、有符号数和无符号数</h2><p>​在计算机中，所有东西都是用二进制的 0 和 1 来进行存储的，比如说一个逗号、一个程序、一个有符号数，一个无符号数等等，都是用 0 和 1 进行存储的。所以在进行编码的时候，会按照相应的编码规则进行编码，有符号数按有符号数的编码规则，无符号数按无符号数的编码规则，所以说给你一串数字：1 0 0 1 1 1 0 1 0，告诉你他是个文本，那么他可能就代表 0 一个逗号。不谈这个文本，如果它是一个无符号数，我们就需要按照无符号数的编码规则去进行编码，既然是无符号，顾名思义，可以直接转换成十六进制数，或者是十进制数，转换成 16 进制就是 0x9A   十进制就是 154。<br>​但如果是有符号数的话，因为是有正数和负数之分的，所以编码规则相对不同，即正数和负数的编码不同。<br>​有符号数，拿上面的一串数字来说：0 0 0 1 1 0 1 0，最高位是 1，这个数就是负数，最高数是 0，这个数就是正数，那么很显然这个是正数。至于有、无符号数是怎么进行编码的，就需要了解到原码、补码和反码了。</p><h2 id="五-原码-补码和反码"><a class="markdownIt-Anchor" href="#五-原码-补码和反码">#</a> 五、原码、补码和反码</h2><p>​1. 编码规则<br>​首先在计算机中，靠二进制数 0 和 1 存储信息，例如 0 1 0 1 0 1 0 1，不同的文件有着不同的编码规则，也就是说这些 0 和 1 按照编码规则，解析成文本，视频，音乐等等。</p><p>​2. 原码、反码和补码<br>​原码：最高位为符号位，其余各位为数值本身的绝对值</p><p>​反码：<br>​正数：反码与原码相同<br>​负数：符号位为 1，其余位对原码取反</p><p>​补码：<br>​正数：补码与原码相同<br>​负数：符号位为 1，其余位对原码取反加 1</p><p>​了解到原码、反码和补码之后，我们也就能够轻松地理解有、无符号数是怎样进行编码的了。</p><h2 id="六-计算机做的运算"><a class="markdownIt-Anchor" href="#六-计算机做的运算">#</a> 六、计算机做的运算</h2><p>​1. 与运算（and&amp;）<br>​       两个位都为 1 时，结果才为 1</p><p>​2. 或运算（or|）<br>​      只要有一个为 1 就是 1</p><p>​3. 异或运算（xor^）<br>不一样的时候是 1</p><p>​4. 非运算（not~）<br>​      0 就是 1    1 就是 0</p><p>​5. 移位运算<br>​左移（shl &lt;&lt;）<br>​各二进位全部左移若干位，高位丢弃，低位补 0<br>​eg：1101 1000    左移 2 位为：0110 0000</p><p>​右移（shr    sar    &gt;&gt;）<br>​各二进位全部右移若干位，低位丢弃，高位补 0 或者补符号位<br>​注：右移是分两种情况的，就是高位补 0 和补符号位</p><p>​shr   1101 0101        右移    0011 0101<br>​对应 C 语言（&gt;&gt;）<br>​unsigned int a= 10；<br>​printf(&quot;%d\n&quot;,a&gt;&gt;2);</p><p>​sar   1101 0101        右移    1111 0101<br>​对应 C 语言（&gt;&gt;）<br>​int a=10;<br>​printf(&quot;%d\n&quot;,a&gt;&gt;2):</p><p>​C 语言中，有符号的右移是补符号位，无符号位的右移是补 0。上述字母代表的是汇编中对应的指令，符号代表的是 C 语言中对应的指令。所以说计算机做的所有运算归根到底都是位运算。</p><h2 id="七-位运算加减乘除用位运算来实现四则运算"><a class="markdownIt-Anchor" href="#七-位运算加减乘除用位运算来实现四则运算">#</a> 七、位运算加减乘除（用位运算来实现四则运算）</h2><p>​不考虑进位的情况下，异或的结果和加结果一样。所以计算机在进行加法的时候的大致过程是这样的：<br>​举个例子：4+5=？<br>​（1）首先，两个二进制数进行异或<br>​0000  0100<br>​0000  0101   异或<br>​————————<br>​0000  0001<br>​（2）其次，两个数进行与运算<br>​0000  0100<br>​0000  0101   与<br>​————————<br>​0000  0100<br>​（3）因为与运算是计算机能够判断在进行加法时是否发生了进位的运算，所如果发生了进位，那么就会再次进行异或运算，如果没有进位，第一次进行的异或运算的结果就是真实的结果，以下是发生了进位之后的异或运算<br>​0000 0001                 —&gt; 第一次异或的结果<br>​0000 1000   异或        —&gt; 上次与运算的结果左移一位之后<br>​————————<br>​0000  1001<br>​（4）再次进行与运算，判断上次异或是否发生进位，没有进位，直接出结果，进位了，继续进行异或运算<br>​0000  0001<br>​0000  1000     与<br>​————————<br>​0000  0000</p><p>​注：（1）与运算结果有 1 的地方就是发生了进位，如果没有发生进位，那么结果就应该全部为 0<br>​      （2）第二次异或之所以要加左移一位的结果是因为与运算结果为 1 的地方本应该是要进一位的</p><p>​其他运算的运算过程<br>​4-5=4+（-5）<br>​减法就是加法，所以运算的过程和加法基本是一致的，<br>​至于乘法，乘法就是加法，x*y 的本质就是 x 个 y 相加，<br>​除法的本质就是减法，X/Y 其实就是 X 能减去多少个 Y，<br>​归根结底，四则运算就是加法的运算，用计算机的位运算进行运算，本质都是一样的。<br>​所以说计算机可以通过位运算来进行最基本的四则运算，那么也就可以以此进行一些更复杂的运算。</p><h2 id="八-汇编环境搭建"><a class="markdownIt-Anchor" href="#八-汇编环境搭建">#</a> 八、汇编环境搭建</h2><p>​汇编环境搭建<br>​1. 学汇编不是为了写代码<br>​学汇编对学习应用开发和安全相关方面都有帮助<br>​2. 环境配置<br>​下载 DTDebug，在滴水官网下载，下载完成之后进行简单配置，在 options—&gt;Appearance—&gt;Directories 中，将 UDD 和 Plugin 的路径指向对应名称的目录中。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 菜鸟入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈博客搭建</title>
      <link href="/2022/02/18/%E6%B5%85%E8%B0%88%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/02/18/%E6%B5%85%E8%B0%88%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>第一次接触博客，不知道说啥，好紧张。<br>年前花了几天时间在网上找课程，搭建最基础的博客，然后就是漫长的主题美化，中间一直耽搁着，直到今天才顺利的把主题美化好，各种该有的全部添了上去，不该有的也弄了个七七八八。<br>我用的是 butterfly 主题，当时满世界的找主题，唯有这款主题深深的吸引了我，但是这个主题对于新手十分的不友好，我差点就删档重新来过，好在经历了各种错误之后，还是将美化给做完了。<br>还有就是我要开始写博客了，学习怎样写博客，也不失为一种乐趣，这也是最最基本的事情了。就目前看来，Sublime Text 确实用的不是很习惯。<br>不说了，我要去下载 Typora 了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 浅谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
