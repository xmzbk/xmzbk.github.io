<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>简单程序破解和修改窗口</title>
      <link href="/2022/07/09/%E7%AE%80%E5%8D%95%E7%A0%B4%E8%A7%A3%E5%92%8C%E4%BF%AE%E6%94%B9%E7%AA%97%E5%8F%A3/"/>
      <url>/2022/07/09/%E7%AE%80%E5%8D%95%E7%A0%B4%E8%A7%A3%E5%92%8C%E4%BF%AE%E6%94%B9%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="简单的修改窗口"><a class="markdownIt-Anchor" href="#简单的修改窗口">#</a> 简单的修改窗口</h3><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709224730.png" alt=""><br> 拿到一个简单的小程序，我们要做的是把它的标题和显示的 “win32” 修改一下。<br>1. 使用 010<br> 第一种方法是用 010 修改，拖进去。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709225132.png" alt=""><br> 用这个文本搜索，搜到之后，直接改，但是要注意修改的字符长度要和原来的相同，如果不足可以用空格代替。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709225422.png" alt=""><br> 改过之后是这样的。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709225458.png" alt=""><br>2. 使用 od<br> 第二种是使用 od 修改内容。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709231026.png" alt=""><br> 使用中文搜索，直接搜索我们想要改的字符串。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709231120.png" alt=""><br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709231207.png" alt=""><br> 程序在这一行，然后数据右键窗口跟随。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709231331.png" alt=""></p><p> 我们就能找到数据窗口中文本所在位置。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709235358.png" alt="">在数据窗口选择需要改的东西然后 ctrl+E。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709235630.png" alt=""></p><p>然后进行修改。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709235544.png" alt=""><br> 我在 ASCII 写入了我爱你。修改前，关闭窗口左下角的保持大小，修改后注意尽量保证你修改的数据与原来的数据的长度相同，不然可能会出现乱码，还有尽量不要修改除文本之外的其他东西。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709231732.png" alt=""><br>再选中你改的东西，右键复制到可执行文件。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709231822.png" alt=""><br>这里选择保存文件，保存过后就完成修改了。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709234859.png" alt=""></p><h3 id="简单的程序破解"><a class="markdownIt-Anchor" href="#简单的程序破解">#</a> 简单的程序破解</h3><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709235044.png" alt=""><br> 我们拿到这样一个小程序，当你输入错误的用户名和密码时，它会提示<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709235158.png" alt=""><br> 我们可以用 od 进行简单的破解，直接绕过这个错误窗口。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709235307.png" alt=""><br> 不管你输入什么，都会提示你成功！<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709235942.png" alt=""><br> 插件选择 API 断点的常用断点设置。这个可以帮助我们下断点。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710000057.png" alt=""><br> 选择图中的那个选项，然后确定，再点击运行让程序跑起来。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710000510.png" alt=""><br> 出现这个窗口后，我们随机输入数字，然后点击 check，<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710000635.png" alt=""><br> 发现程序自动跳到断点这里，再不断地 f8 运行。直到程序跳出这个窗口<br><img src="C:%5CUsers%5Ca%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220710000827311.png" alt="image-20220710000827311"><br> 然后我们再分析一波汇编代码。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710001013.png" alt=""><br> 发现程序是到了这里停了下来，说明这里可能就是导致出现序列号错误窗口的那个点。所以我们将程序再重新运行，点左上角的两个三角的符号重新运行，我们按照和之前同样的操作不断进行，只不过需要注意的就是 je、jl 等这些跳转操作，关注右边的标志寄存器，如果有发生跳转的地方，我们就将标志寄存器的值修改一下，不断运行，不让程序发生跳转，最后我们同样是运行到了和之前错误窗口出现的那个位置。但是这次窗口不再显示错误，而是显示成功了。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710003524.png" alt=""></p><p> 说明我们已经成功了一半，接下来就是找到我们认为可疑的会进行跳转的地方，我发现了下面这几个跳转：<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710001907.png" alt=""><br>发现几个可疑的跳转，我们把它们右键全部 nop 掉，<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710002003.png" alt=""><br>然后在右键选中复制 —&gt; 全选<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710004425.png" alt=""><br>再右键复制到可执行文件 —&gt; 选择<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710004652.png" alt=""><br>再右键灰色窗口保存文件即可。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220710004614.png" alt=""><br>最后就能得到我们破解的程序了。</p>]]></content>
      
      
      <categories>
          
          <category> pj </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buuCTF题解（二）</title>
      <link href="/2022/07/03/buuCTF%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/07/03/buuCTF%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h4 id="reverse1"><a class="markdownIt-Anchor" href="#reverse1">#</a> reverse1</h4><p>程序是 64，拖进 IDA 直接分析伪代码。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706143247.png" alt=""><br> 程序的下方，if (!strncmp (Str1, Str2, v5) ) 的意思是，str2=str1，则 输出 this is the right flag!\n。二 str1 是我们要输入的字符串，所以关键点就在于 str2，我们掉进去查看一下 str2 的值。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706143532.png" alt=""><br> 发现隐藏了一个字符串，所以我们再分析上面的代码。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706143648.png" alt=""><br> 这段的意思就是将 o 替换成 0，即 {hello_world}–&gt;{hell0_w0rld}, 这就是最后的 flag 了。<br>flag：flag{hell0_w0rld}<br> 总结：strncmp（str1，str2，str3) 函数的作用是对比字符串是否相等，str3 是指定前几个字符串。</p><h4 id="reverse2"><a class="markdownIt-Anchor" href="#reverse2">#</a> reverse2</h4><p hack1ng_fo1_fun=""> 直接分析源代码。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706144831.png" alt=""><br> 图中方框中的代码表示将 flag 中 存储的字符串的中的 i 和 r 替换成 1，再看下方的代码，将 flag 和 s2 进行比较，如果相等输出 this is right flag！，s2 是我们输入的字符串，所以我们调进去查看 flag 的内容。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706145204.png" alt=""><br> 发现 hacking_for_fun，替换成 hack1ng_fo1_fun 就是我们的 flag 了。<br>flag：flag</p><h4 id="新年快乐"><a class="markdownIt-Anchor" href="#新年快乐">#</a> 新年快乐</h4><p> 这道题是加了壳的。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706161032.png" alt=""><br>将程序拖进 PE 中查看，发现是 UPX 的壳，并且将程序拖进 IDA 中发现只有两个函数，所以我们要进行脱壳。</p><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706161532.png" alt=""></p><p> 脱完之后再拖进 IDA 中就能查看函数了。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706161254.png" alt=""><br>分析代码，得到 flag。<br>flag：flag{HappyNewYear!}<br> 总结：用 UPX 脱 UPX 的壳。</p><h4 id="helloworld"><a class="markdownIt-Anchor" href="#helloworld">#</a> helloworld</h4><p 7631a988259a00816deda84afb29430a=""><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706173018.png" alt=""><br> 发现他是一个 apk 文件，所以需要用 apkIDA 打开，打开之后找到 MainActivity 查看，就能发现 flag。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706173250.png" alt=""><br>flag：flag</p><h4 id="reverse3"><a class="markdownIt-Anchor" href="#reverse3">#</a> reverse3</h4><p>程序直接拖到 IDA 中分析代码。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706174435.png" alt=""><br> 大致思路就是，输入一段字符串 Str，进行 base64 加密之后变成 Destination，Destination 的每一个字符再加上一个数，最后 Destination 与 Str2 进行比较，相同则输出 right flag！。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706174823.png" alt=""><br> v4 = (const char *) sub_4110BE (Str, v3, v14);main 函数中的这行代码进行的是 base64 加密（如图)。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706175103.png" alt=""><br> 这是 Str2 字符串的内容，e3nifIH9b_C@n@dH</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> iflag[<span class="number">40</span>]=<span class="string">&quot;e3nifIH9b_C@n@dH&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">16</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        iflag[i]-=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(iflag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p i_l0ve_you=""> 简单写一个 c 代码逆一下那个 Destination 加数，得到 e2lfbDB2ZV95b3V9。然后将这段字符串找一个 base64 解码网站解一下，就得到 flag 了。<br>flag：flag</p><h4 id="simplerev"><a class="markdownIt-Anchor" href="#simplerev">#</a> SimpleRev</h4><p>用 IDA64 打开文件，直接分析伪代码。我在代码中做了注释。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v11 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">*(_QWORD *)src = <span class="string">&#x27;SLCDN&#x27;</span>;</span><br><span class="line">v7 = <span class="number">0LL</span>;</span><br><span class="line">v8 = <span class="number">0</span>;</span><br><span class="line">v9[<span class="number">0</span>] = <span class="string">&#x27;wodah&#x27;</span>;</span><br><span class="line">v9[<span class="number">1</span>] = <span class="number">0LL</span>;</span><br><span class="line">v10 = <span class="number">0</span>;</span><br><span class="line">text = (<span class="keyword">char</span> *)((__int64 (__fastcall *)(<span class="keyword">char</span> *, __int64 *))join)(key3, v9);</span><br><span class="line"><span class="built_in">strcpy</span>(key, key1);   <span class="comment">//作用是将key1的值复制到key中</span></span><br><span class="line"><span class="built_in">strcat</span>(key, src);  <span class="comment">//作用是将src中字符串拼接到key中</span></span><br><span class="line">v2 = <span class="number">0</span>;</span><br><span class="line">v3 = <span class="number">0</span>;</span><br><span class="line">getchar();</span><br><span class="line">v5 = <span class="built_in">strlen</span>(key);   <span class="comment">//计算key的长度</span></span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v5; ++i )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( key[v3 % v5] &gt; <span class="number">64</span> &amp;&amp; key[v3 % v5] &lt;= <span class="number">90</span> )</span><br><span class="line">    key[i] = key[v3 % v5] + <span class="number">32</span>;</span><br><span class="line">  ++v3;   <span class="comment">//这里for的作用是将key中的大写字符串全部转化为小写字符串</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input your flag:&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v1 = getchar();</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">10</span> )</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">32</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    ++v2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v1 &lt;= <span class="number">96</span> || v1 &gt; <span class="number">122</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v1 &gt; <span class="number">64</span> &amp;&amp; v1 &lt;= <span class="number">90</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        str2[v2] = (v1 - <span class="number">39</span> - key[v3 % v5] + <span class="number">97</span>) % <span class="number">26</span> + <span class="number">97</span>;</span><br><span class="line">        ++v3;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      str2[v2] = (v1 - <span class="number">39</span> - key[v3 % v5] + <span class="number">97</span>) % <span class="number">26</span> + <span class="number">97</span>;</span><br><span class="line">      ++v3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !(v3 % v5) )</span><br><span class="line">      <span class="built_in">putchar</span>(<span class="number">32</span>);</span><br><span class="line">    ++v2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(text, str2) )   <span class="comment">//比较text和str2，如果相同，返回0，不相同 </span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Congratulation!\n&quot;</span>); <span class="comment">//返回1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Try again!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v11;</span><br></pre></td></tr></table></figure><p> 代码给了四个关键字符串，也就是 src、v9 [0]、key1、key3。下面是 key1 和 key3 存储的字符串：<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220708181806.png" alt=""><br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220708181845.png" alt=""></p><p> 字符串拼接完之后，是这样的：text = killshadow，key = adsfkndcls，注意第二段字符串都是倒过来，然后再拼起来的。<br> 得到这两个字符串之后，就是通过一系列运算，最后得到 str2，再与 text 进行比较，相同就输出 Congratulation!，即为正确答案。</p><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220708182520.png" alt=""></p><p> 那就写一个脚本逆一下。我写的是 c 语言脚本。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> text[<span class="number">100</span>] = <span class="string">&quot;killshadow&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> key[<span class="number">100</span>] = <span class="string">&quot;adsfkndcls&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> v1[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">128</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; <span class="string">&#x27;A&#x27;</span> || j &gt; <span class="string">&#x27;z&#x27;</span> || j &gt; <span class="string">&#x27;Z&#x27;</span> &amp;&amp; j &lt; <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">if</span>(text[i] == (j - <span class="string">&#x27;\&#x27;&#x27;</span> - key[i] + <span class="string">&#x27;a&#x27;</span>)%<span class="number">26</span> + <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,j);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 本来是想着写取余逆运算，但是发现实在太复杂，而且我实现不了，所以就在网上借鉴了别人写的脚本，大致思路就是通过 if 语句的判断来筛选出符合条件的字符串，这个思路也可以用到其他题，学到了不少。</p><h4 id="gxyctf2019luck_guy"><a class="markdownIt-Anchor" href="#gxyctf2019luck_guy">#</a> [GXYCTF2019]luck_guy</h4><p>这道题还是非常简单的，看懂伪代码就直接出来了，甚至脚本都不用写。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709131401.png" alt=""><br>F5 主函数，查看这个 patch_me（v4)<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709131510.png" alt=""><br> 再进入那个 get_flag（) 函数，就能看到我们的关键伪代码了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">get_flag</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+4h] [rbp-3Ch]</span></span><br><span class="line">  <span class="keyword">int</span> j; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  __int64 s; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v5; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v6; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v0 = time(<span class="number">0LL</span>);</span><br><span class="line">  srand(v0);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )     </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( rand() % <span class="number">200</span> )     <span class="comment">//简单的循环语句嵌套了一个switch语句</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;OK, it&#x27;s flag:&quot;</span>);</span><br><span class="line">        <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x28</span>uLL);</span><br><span class="line">        <span class="built_in">strcat</span>((<span class="keyword">char</span> *)&amp;s, f1);</span><br><span class="line">        <span class="built_in">strcat</span>((<span class="keyword">char</span> *)&amp;s, &amp;f2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;s);</span><br><span class="line">        <span class="keyword">break</span>;       <span class="comment">//这段代码的作用是将f1和f2拼接</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Solar not like you&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Solar want a girlfriend&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        s = <span class="number">0x7F666F6067756369</span>LL;</span><br><span class="line">        v5 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">strcat</span>(&amp;f2, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;s);  </span><br><span class="line">        <span class="keyword">break</span>;    <span class="comment">//这段的作用是将s的字符串复制到f2中</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">7</span>; ++j )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( j % <span class="number">2</span> == <span class="number">1</span> )</span><br><span class="line">            *(&amp;f2 + j) -= <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            --*(&amp;f2 + j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">//这段的作用是将f2的字符串按奇数减2，偶数减1</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;emmm,you can&#x27;t find flag 23333&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p do_not_hate_me=""> 本题的大致思路是，case4 将 s 的字符串复制到 f2 里面，然后 case5 将 f2 进行加减处理，最后 case1 将 f1 和 f2 拼接到一起，得到 flag。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709142851.png" alt=""><br> 这是字符串 f1 的内容，很容易就能看出这就是 flag 的前半段，因为 GXY 恰好就是题目的标题，所以我们只需要求出后半段即可，然后我们看 f2，f2 的值其实就是 s 的值，将 ASCII 码转换成字符串就是fo`guci，再带到 case5 中进行运算，case5 的作用就是将字符串的奇数位 ASCII 码减 2，偶数位减 1，最后得到} em_etah，再进行倒序就得到 hate_me}，这就是 flag 的后半段。<br>flag：flag</p><h4 id="actf新生赛2020easyre"><a class="markdownIt-Anchor" href="#actf新生赛2020easyre">#</a> [ACTF 新生赛 2020] easyre</h4><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709213233.png" alt=""><br> 拿到程序先用 PE 查壳，发现是 upx 壳，用 upx shell 脱下壳<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709213434.png" alt=""><br> 然后将程序拖到 IDA 中分析伪代码。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_BYTE v4[<span class="number">12</span>]; <span class="comment">// [esp+12h] [ebp-2Eh] BYREF</span></span><br><span class="line">  _DWORD v5[<span class="number">3</span>]; <span class="comment">// [esp+1Eh] [ebp-22h]</span></span><br><span class="line">  _BYTE v6[<span class="number">5</span>]; <span class="comment">// [esp+2Ah] [ebp-16h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [esp+2Fh] [ebp-11h]</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [esp+33h] [ebp-Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [esp+37h] [ebp-9h]</span></span><br><span class="line">  <span class="keyword">char</span> v10; <span class="comment">// [esp+3Bh] [ebp-5h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [esp+3Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  __main();</span><br><span class="line">  qmemcpy(v4, <span class="string">&quot;*F&#x27;\&quot;N,\&quot;(I?+@&quot;</span>, <span class="keyword">sizeof</span>(v4));<span class="comment">//把字符串复制到v4里面</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please input:&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, v6);</span><br><span class="line">  <span class="keyword">if</span> ( v6[<span class="number">0</span>] != <span class="number">65</span> || v6[<span class="number">1</span>] != <span class="number">67</span> || v6[<span class="number">2</span>] != <span class="number">84</span> || v6[<span class="number">3</span>] != <span class="number">70</span> || v6[<span class="number">4</span>] != <span class="number">123</span> || v10 != <span class="number">125</span> )<span class="comment">//v6+v10的内容恰好是ACTF&#123;&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v5[<span class="number">0</span>] = v7;</span><br><span class="line">  v5[<span class="number">1</span>] = v8;</span><br><span class="line">  v5[<span class="number">2</span>] = v9;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">11</span>; ++i ) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v4[i] != _data_start__[*((<span class="keyword">char</span> *)v5 + i) - <span class="number">1</span>] )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//将v4里的值和_data_start__中对比，不相同返回0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;You are correct!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 重要的就是上面 for 语句中的比较，将 v4 中的字符串的 ASCII 码和_data_start__中的字符串进行对比，相同的话就是我们要找的 flag 了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v4[i] != _data_start__[*((char *)v5 + i) - 1] </span><br></pre></td></tr></table></figure><p> 这段代码的意思是在_data_start__中寻找到一个字符再减 1，然后再与 v4 中的字符串的 ASCII 码值对比。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220709214237.png" alt=""></p><p> 这是_data_start__中的字符串，其中 “7Eh”，“27h” 需要转成字符，分别是 “~”，“ ‘ ”。<br> 接下来我们写一个 py 脚本来输出 flag。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v4 = <span class="string">&quot;*F&#x27;\&quot;N,\&quot;(I?+@&quot;</span>  </span><br><span class="line">text = <span class="string">&#x27;~&#125;|&#123;zyxwvutsrqponmlkjihgfedcba`_^]\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;=&lt;;:9876543210/.-,+*)(\&#x27;&amp;%$# !&quot;&#x27;</span></span><br><span class="line">  <span class="comment">#注意该段字符串中有的字串需要转义，“ ‘ ”需要转义，还有后面的#后面有个空格不要忘了</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span>  <span class="comment">#空的数组</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> v4:</span><br><span class="line">    flag += <span class="built_in">chr</span>(text.find(i)+<span class="number">1</span>)   <span class="comment">#使用find函数进行查找</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;flag&#123;&quot;</span>+ flag +<span class="string">&quot;&#125;&quot;</span>)   <span class="comment">#以flag&#123;&#125;形式输出</span></span><br></pre></td></tr></table></figure><p>flag：flag{U9X_1S_W6@T?}<br> 总结：这道题我觉得最难得地方就在于字符串的处理，不仅在 IDA 中，v4 字符串的那堆乱码让人不好辨别，还有_data_start__中的字符串有的容易漏掉，有的容易忘记转换成字符，有的在写脚本的时候忘记转义。说实话，一开始我用 shift+E 提取字符串的时候长度恰好 64 位，我一度以为是 base64，结果编码函数都没找到，我还在那里用换表硬算，真的是让人笑掉大牙。所以做题的时候细心最重要。通过这道题，我也对字符串认识更加深了一步。</p><h4 id="简单题"><a class="markdownIt-Anchor" href="#简单题">#</a> 简单题</h4><p> 这道题思路不难理解，就是写脚本那一块卡了很久。这题不是 buu 的题，学长给的，找不到出处了，和之前 buu 的 xor 类似。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706205009.png" alt=""><br> 分析一波代码，还是很好理解的。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706205224.png" alt=""><br> 核心就是这段代码，将 buf 与 xor_str 进行异或，得到的结果与 result 进行比较。如果相同，就输出 right！<br> 再看 result 和 xor_str 中的值。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/SH7@G4~BEO8R2DLKJ5BT4%5DT.png" alt=""><br> 可以看到确实有东西，shift+E 提取。<br><img src="C:%5CUsers%5Ca%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220706205824410.png" alt="image-20220706205824410"><br> 然后再看 xor<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220706205857.png" alt=""><br> 同样 shift+E，最后写脚本。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1=[<span class="number">0xC0</span>,<span class="number">0x7A</span>,<span class="number">0xDB</span>,<span class="number">0x29</span>,<span class="number">0x2B</span>,<span class="number">0x5A</span>,<span class="number">0x9D</span>,<span class="number">0x78</span>,<span class="number">0x08</span>,<span class="number">0x1F</span>, </span><br><span class="line"><span class="number">0xA5</span>,<span class="number">0x30</span>,<span class="number">0x3D</span>,<span class="number">0x18</span>,<span class="number">0x6C</span>,<span class="number">0xFD</span>,<span class="number">0xD9</span>,<span class="number">0x9E</span>,<span class="number">0x07</span>,<span class="number">0xA0</span>, </span><br><span class="line"><span class="number">0x0D</span>,<span class="number">0xF2</span>,<span class="number">0x3A</span>,<span class="number">0xDE</span>,<span class="number">0xCE</span>,<span class="number">0xEF</span>,<span class="number">0x23</span>,<span class="number">0x58</span>,<span class="number">0xC3</span>,<span class="number">0x56</span>, </span><br><span class="line"><span class="number">0xA0</span>,<span class="number">0x67</span>,<span class="number">0xCC</span>,<span class="number">0x0E</span>,<span class="number">0x59</span>,<span class="number">0x33</span>,<span class="number">0x54</span>,<span class="number">0x70</span>]</span><br><span class="line">list2=[<span class="number">0xA6</span>,<span class="number">0x16</span>,<span class="number">0xBA</span>,<span class="number">0x4E</span>,<span class="number">0x50</span>,<span class="number">0x3E</span>,<span class="number">0xFE</span>,<span class="number">0x41</span>,<span class="number">0x31</span>,<span class="number">0x2F</span>, </span><br><span class="line"><span class="number">0xC4</span>,<span class="number">0x52</span>,<span class="number">0x5F</span>,<span class="number">0x2A</span>,<span class="number">0x08</span>,<span class="number">0xC8</span>,<span class="number">0xE9</span>,<span class="number">0xAA</span>,<span class="number">0x61</span>,<span class="number">0xC4</span>, </span><br><span class="line"><span class="number">0x6F</span>,<span class="number">0xCA</span>,<span class="number">0x0A</span>,<span class="number">0xBB</span>,<span class="number">0xFB</span>,<span class="number">0xDB</span>,<span class="number">0x12</span>,<span class="number">0x6D</span>,<span class="number">0xF4</span>,<span class="number">0x61</span>, </span><br><span class="line"><span class="number">0xC1</span>,<span class="number">0x5E</span>,<span class="number">0xFD</span>,<span class="number">0x37</span>,<span class="number">0x3C</span>,<span class="number">0x04</span>,<span class="number">0x36</span>,<span class="number">0x0D</span>]</span><br><span class="line">flag=<span class="string">&#x27;0&#x27;</span></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  <span class="keyword">if</span> i&lt;<span class="built_in">len</span>(list1):</span><br><span class="line">    flag += <span class="built_in">chr</span>(<span class="built_in">int</span>(list1[i])^<span class="built_in">int</span>(list2[i]))</span><br><span class="line">    i+=<span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p> 运行一下，输出结果。<br><img src="C:%5CUsers%5Ca%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220706210126210.png" alt="image-20220706210126210"><br>flag{dc990abb2d504fdb80e541577a919e7b}<br> 总结：这个脚本想了好久，也是因为之前做的 buuctf 的逆向 xor 题和这个十分类似，要不然脚本这一块真不知道怎么写。写脚本，以及逻辑运算这两块都有待提升。</p>]]></content>
      
      
      <categories>
          
          <category> writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buuCTF题解（一）</title>
      <link href="/2022/07/01/buuCTF%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/07/01/buuCTF%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h4 id="不一样的flag"><a class="markdownIt-Anchor" href="#不一样的flag">#</a> 不一样的 flag</h4><p> 这道题与传统的逆向题不同，更像是一个游戏，一个盲人走迷宫游戏。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220701162403.png" alt=""><br> 上来直接分析伪代码，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ( *((_BYTE *)&amp;v5 + 5 * v1 + v2 - 41) == &#x27;1&#x27; )</span><br><span class="line">if ( *((_BYTE *)&amp;v5 + 5 * v1 + v2 - 41) == &#x27;#&#x27; )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;\nok, the order you enter is the flag!&quot;);</span><br><span class="line">       exit(0);</span><br></pre></td></tr></table></figure><p> 关键就在于这两行代码，上面一句意思是说如果某个值等于 1，那么程序就终止，下面的意思是如果等于 #，则程序运行结束，游戏胜利。<br> 分析整个代码的话，大致理解为不断输入 1-4 这 4 个数，然后程序不断运行，最后输出 \nok, the order you enter is the flag! 代表胜利。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220701162913.png" alt=""><br> 程序运行，可以看到 1-4 代表上下左右四个方向，并且在 IDA 中我们可以找到一串字符。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220701163026.png" alt=""><br> 这串字符很有可能就是这个盲人迷宫的地图。并且字符的数目是 25，那么除以 5 可以得到：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*1111</span><br><span class="line">01000</span><br><span class="line">01010</span><br><span class="line">00010</span><br><span class="line">1111#</span><br></pre></td></tr></table></figure><p> 只有 0 和 1，并且前面我们分析程序输入 1 终止，那么只能输入 0，因此再看这个地图就很明显了。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220701163355.png" alt=""><br> 根据这个地图我们向程序中输入数字。最后就能得到 flag。<br>flag：222441144222<br> 总结：<br>1.exit (1)：非正常运行导致程序退出。exit（0) 程序正常退出<br> 2. 多开阔思维，再遇到这样的题型要多想想。</p><h4 id="变异凯撒"><a class="markdownIt-Anchor" href="#变异凯撒">#</a> 变异凯撒</h4><p> 这道题不是常规的凯撒解密，但是和凯撒密码的移位原理相同。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220702110439.png" alt=""><br>给了一串字符，放到常规凯撒解密中不能解出任何东西，可以说这个格式和常规凯撒没有任何关系，这时候就该想到 ASCII 码，前四个字符的 ASCII 码是 97,102,90,95，而 flag 的 ASCII 码是 102，108，97，103，刚好相差 5,6,7,8，所以可以看到这实际上是 ASCII 码的偏移，写个 c 简单减一下。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> sum[<span class="number">100</span>]=&#123;<span class="number">97</span>,<span class="number">102</span>,<span class="number">90</span>,<span class="number">95</span>,<span class="number">114</span>,<span class="number">57</span>,<span class="number">86</span>,<span class="number">89</span>,<span class="number">102</span>,<span class="number">83</span>,<span class="number">99</span>,<span class="number">79</span>,<span class="number">101</span>,<span class="number">79</span>,<span class="number">95</span>,<span class="number">85</span>,<span class="number">76</span>,<span class="number">94</span>,<span class="number">82</span>,<span class="number">87</span>,<span class="number">85</span>,<span class="number">99</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">22</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[i] = sum[i] + (<span class="number">5</span> + i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,sum[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>最后得到 flag：flag {Caesar_variation}<br> 总结：应该早点想到 ASCII 码的。<br>ASCII 码与字符串转化网站：<a href="https://www.asciim.cn/m/tools/convert_string_to_ascii.html">字符串转 ASCII 码 - ASCII 码 (asciim.cn)</a><br><a href="https://www.asciim.cn/m/tools/convert_ascii_to_string.html"> ASCII 码转字符串 - ASCII 码 (asciim.cn)</a></p><h4 id="rsa"><a class="markdownIt-Anchor" href="#rsa">#</a> RSA</h4><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220702161850.png" alt=""></p><p> 实在没看懂网上对于 RSA 的讲解，因为数学特别差，抽个时间还要再学一下，这道题感觉就像是数学的求解题，到网上找了个 py 脚本。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util <span class="keyword">import</span> number</span><br><span class="line">p = <span class="number">473398607161</span></span><br><span class="line">q = <span class="number">4511491</span></span><br><span class="line">e = <span class="number">17</span></span><br><span class="line">d = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure><p> 在用这个脚本的时候发现还要下载 gmpy2 和 Crypto 的模块，不然脚本是无法正常运行的，所以安装方法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux：</span><br><span class="line">sudo apt-get install libgmp-dev     //安装gmp</span><br><span class="line">sudo apt-get install libmpfr-dev    //安装mpfr</span><br><span class="line">sudo apt-get install libmpc-dev     //安装mpc</span><br><span class="line">sudo pip3 install gmpy2       //安装gmpy2</span><br><span class="line">sudo pip install gmpy2   </span><br><span class="line">pip install pycrypto        //安装Crypto</span><br></pre></td></tr></table></figure><p 125631357777427553="">flag：flag</p><h4 id="大帝的密码武器"><a class="markdownIt-Anchor" href="#大帝的密码武器">#</a> 大帝的密码武器</h4><p PbzrPuvan=""> 比较正常的一道凯撒密码题，主要思路就是穷举。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220702160455.png" alt=""><br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220702161123.png" alt=""><br> 通过穷举法我们得出的明文是 SECURITY（意为 “安全”)，偏移量是 13，再用偏移量去加密 ComeChina，得到 flag。<br>flag：flag</p><h4 id="alice和bob"><a class="markdownIt-Anchor" href="#alice和bob">#</a> Alice 和 Bob</h4><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220702162632.png" alt=""><br>将整数分解成两个素数，网上找一个在线网站，也就是在线分解质因数：<a href="http://tools.jb51.net/jisuanqi/factor_calc">在线分解质因数计算器工具 - 在线计算器 - 脚本之家在线工具 (jb51.net)</a><br> 分解整合得到的新数是：101999966233，然后按题目要求进行 md5 的 32 位小写加密得到 flag。<br>flag：flag{d450209323a847c8d01c6be47c81811a}<br> 总结：只要能看懂题目就能做出来，重要的是学会运用在线工具网站。推荐的 md5 加密网站：<a href="https://www.23bei.com/tool/1.html#">MD5 加密 (16 位，32 位，大写，小写) 在线计算器 (23bei.com)</a><br> md5 解密网站：<a href="https://cmd5.com/">md5 在线解密破解，md5 解密加密 (cmd5.com)</a></p><h4 id="windows系统密码"><a class="markdownIt-Anchor" href="#windows系统密码">#</a> Windows 系统密码</h4><p> 附件用记事本打开。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220702165352.png" alt=""><br> 可以看到第三行有个 ctf 字样，说明后面的字符串有可能是密文，并且看见这种样式首先想到的就是 md5，ctf 后面的字符串中间用分号隔开了，前半段无法解开，后半段解开是<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220702165657.png" alt=""><br>这个就是 flag 了。<br>flag：flag{good-luck}<br> 总结：<a href="https://cmd5.com/">md5 在线解密破解，md5 解密加密 (cmd5.com)</a> 这个网站很强大。</p><h4 id="信息化时代的步伐"><a class="markdownIt-Anchor" href="#信息化时代的步伐">#</a> 信息化时代的步伐</h4><p>这是个中文电码题，我还傻傻的去用 ASCII 转字符。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220702193518.png" alt=""><br>flag：flag {计算机要从娃娃抓起}<br> 总结：编码解码网站：<a href="http://code.mcdvisa.com/">中文电码查询 Chinese Commercial Code - 标准电报码免费在线查询 | 姓名电码 | 美国签证电码 (mcdvisa.com)</a></p><h4 id="凯撒替换呵呵"><a class="markdownIt-Anchor" href="#凯撒替换呵呵">#</a> 凯撒？替换？呵呵！</h4><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220702210825.png" alt=""><br> 这里的密文用常规的移位解密无法解出来，用 ASCII 码移位去解同样也是解不出来，并且 MTHJ 看似很对应 flag，所以有可能是简单的替换密码，原理大概是设置一个字母对应表，每一种字母均唯一对应一种字母，破解方式是词频分析进行破解。网站：<a href="https://quipqiup.com/">quipqiup - cryptoquip and cryptogram solver</a><br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220702211339.png" alt=""><br> 解密后是这样的：<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220702211423.png" alt=""><br> 第一行就是我们的 flag 了，flag substitution cipher decryption is always easy just like a piece of cake（标志替换密码解密总是很容易，就像小菜一碟一样)，去掉空格加上括号就是答案了。<br>flag：flag{substitutioncipherdecryptionisalwayseasyjustlikeapieceofcake}<br> 总结：虽然凯撒密码比较简单，但是这些变异也是让人防不胜防，替换的原理我还没搞清，所以还是要继续学。</p><h4 id="rsarsa"><a class="markdownIt-Anchor" href="#rsarsa">#</a> rsarsa</h4><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220703115158.png" alt=""></p><p> 我还是在网上找的脚本，我现在的能力着实写不粗来。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Decrypt</span>(<span class="params">c,e,p,q</span>):</span></span><br><span class="line">L=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d=gmpy2.invert(e,L)</span><br><span class="line">n=p*q</span><br><span class="line">m=gmpy2.powmod(c,d,n)</span><br><span class="line">flag=<span class="built_in">str</span>(m)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;flag&#123;&quot;</span>+flag+<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">p =  <span class="number">9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483</span></span><br><span class="line">q =  <span class="number">11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407</span></span><br><span class="line">e =  <span class="number">65537</span></span><br><span class="line">c =  <span class="number">83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034</span></span><br><span class="line">Decrypt(c,e,p,q)</span><br></pre></td></tr></table></figure><p 5577446633554466577768879988=""> 运行就能得到 flag。<br>flag：flag</p><h4 id="萌萌哒的八戒"><a class="markdownIt-Anchor" href="#萌萌哒的八戒">#</a> 萌萌哒的八戒</h4><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220703120347.png" alt=""><br>很明显是猪圈密码，解开后是 when the pig want to eat。<br>flag：flag{whenthepigwanttoeat}<br> 总结：猪圈密码对照表<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220703120558.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python(一)</title>
      <link href="/2022/06/30/python-%E4%B8%80/"/>
      <url>/2022/06/30/python-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h4 id="执行python的几个方式"><a class="markdownIt-Anchor" href="#执行python的几个方式">#</a> 执行 python 的几个方式</h4><p> 1. 解释器 —python/python3<br> 2. 交互式 —ipython<br> 3. 集成开发环境 —Pycharm</p><h4 id="第一个helloworld程序"><a class="markdownIt-Anchor" href="#第一个helloworld程序">#</a> 第一个 Helloworld 程序</h4><p> 写代码的第一步肯定是少不了 Helloworld 的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;HelloWorld&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;HelloPhython&quot;</span>)</span><br></pre></td></tr></table></figure><p> python <program>执行。</p><h4 id="python2x和python3x"><a class="markdownIt-Anchor" href="#python2x和python3x">#</a> python2.x 和 python3.x</h4><p> 1.Python2.x 的解释器名称是 python，python3.x 的解释器名称是 python3<br> 2. 两者开发的差别不是很大，新学的建议使用 python3.x。</p><h4 id="交互式python解释器"><a class="markdownIt-Anchor" href="#交互式python解释器">#</a> 交互式 python 解释器</h4><p> 1. 在终端输入 python/python3 就能打开交互式解释器，输入一句 py 语句就执行一句。<br> 2. 适合学习或者验证局部代码<br> 3. 代码不利于保存，不适合写较大的代码。<br> 4.exit（）或 ctrl+d 退出。</p><h4 id="ipython"><a class="markdownIt-Anchor" href="#ipython">#</a> IPython</h4><p>1. 特点<br>（1）支持自动补全<br>（2）自动缩进<br>（3）支持 bash shell 命令<br>（4）内置了许多有用的功能和函数<br> 2. 版本<br> python2.x 使用 ipython<br> python3.x 使用 ipython3<br>3. 安装<br>安装 ipython</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ipython</span><br></pre></td></tr></table></figure><p>安装 ipython3</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ipython3</span><br></pre></td></tr></table></figure><p>4. 使用<br> ipython/ipython3 进入，exit/ctrl+d 退出。</p><h4 id="pycharm"><a class="markdownIt-Anchor" href="#pycharm">#</a> PyCharm</h4><p>1.IDE<br> PyCharm 是一个强大的集成开发环境。<br>2. 下载安装<br> 在 linux 中直接到商城下载就行。</p><h4 id="常见出错"><a class="markdownIt-Anchor" href="#常见出错">#</a> 常见出错</h4><p>1. 符号不是英文下的符号<br> 2. 不必要的缩进，多添加的空格会导致程序出错。<br>3. 拼写错误</p><h4 id="变量和字符串"><a class="markdownIt-Anchor" href="#变量和字符串">#</a> 变量和字符串</h4><p>1. 变量<br> 简而言之，不要用数字开头就行，py3 支持中文做变量名，但是一般不用中文。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>2. 字符串<br> 通常用单引号或双引号包裹起来，两种形式并没有什么区别，我们只是根据具体情况来使用两种方式，有时候也可以使用转义字符来避免出错。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Let&#x27;s go&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;HelloWorld&#x27;</span>)</span><br></pre></td></tr></table></figure><p>3. 转义字符</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">r&quot;D:\three\two\one&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;D:\\three\\two\\one&quot;</span>)</span><br></pre></td></tr></table></figure><p> 第一行代码，在前面加上 r，可以使后面的所有转义字符失效。第二行则是转义 &quot;\&quot;。<br> 为了避免歧义，有时候我们需要使用转义字符来转义一些东西。<br>4. 拼接和复制</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;520&quot;</span> + <span class="string">&quot;1314&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我爱你\n&quot;</span>*<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p> 字符串的加法是拼接，字符串的乘法是复制。</p><h4 id="用py做第一个小游戏"><a class="markdownIt-Anchor" href="#用py做第一个小游戏">#</a> 用 py 做第一个小游戏</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用py设计的第一个小游戏</span></span><br><span class="line"></span><br><span class="line">counts = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> counts &gt; <span class="number">0</span>:</span><br><span class="line">    temp = <span class="built_in">input</span>(<span class="string">&quot;不妨猜一下我心中的所想的是那个数字：&quot;</span>)</span><br><span class="line">    guess = <span class="built_in">int</span>(temp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> guess == <span class="number">8</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;你是我肚子里的蛔虫么？&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;就算你猜中了也没有奖励&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> guess &lt; <span class="number">8</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;你的有点小&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;你的太大了&quot;</span>)</span><br><span class="line">        counts = counts - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;游戏结束！&quot;</span>)</span><br></pre></td></tr></table></figure><p>1.break 语句：跳出一层循环。<br>2. 记得加上 “：”。</p><h4 id="random"><a class="markdownIt-Anchor" href="#random">#</a> random</h4><p> 1.random 是 py 自带的伪随机数生成模块，特别的方便，如果是用其他语言进行编写的话，需要写的代码可就多了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random <span class="comment">#导入伪随机数模块</span></span><br><span class="line">random.randint(<span class="number">1</span>,<span class="number">10</span>) <span class="comment">#生成1-10的随机数</span></span><br></pre></td></tr></table></figure><p>2. 将伪随机数添加到小游戏中</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">counts = <span class="number">3</span></span><br><span class="line">x = random.randint(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> counts &gt; <span class="number">0</span>:</span><br><span class="line">    temp = <span class="built_in">input</span>(<span class="string">&quot;不妨猜一下我心中的所想的是那个数字：&quot;</span>)</span><br><span class="line">    guess = <span class="built_in">int</span>(temp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> guess == x:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;你是我肚子里的蛔虫么？&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;就算你猜中了也没有奖励&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> guess &lt; x:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;你的有点小&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;你的太大了&quot;</span>)</span><br><span class="line">        counts = counts - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;游戏结束！&quot;</span>)</span><br></pre></td></tr></table></figure><p>3. 伪随机数重现<br> random 生成的伪随机数根据当前操作系统的时间，可以被重现。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">x = random.getstate()</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">random.randint(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">random.randint(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">random.randint(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">random.setstate(x)</span><br><span class="line">random.randint(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">random.randint(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">random.randint(<span class="number">1</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p> 我们通过获取伪随机数的种子就可以重现伪随机数。</p><h4 id="数字类型"><a class="markdownIt-Anchor" href="#数字类型">#</a> 数字类型</h4><p>1. 整数<br> 整数的长度不受限制，有无限大的精度，所以能随时进行大数运算。<br>2. 浮点数<br> 浮点数采用 IEEE754 标准，在运算的时候和实例有时会不相同。就比如 0.1 + 0.2，在现实中等于 0.3，但是 py 运算的结果是 0.30000000000000004。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import decimal</span><br><span class="line">a = decimal.Decimal(&#x27;0.1&#x27;)</span><br><span class="line">b = decimal.Decimal(&#x27;0.2&#x27;)</span><br><span class="line">print(a + b)</span><br></pre></td></tr></table></figure><p> 但是我们可以采用 decimal 模块将结果更精确的运算出来。<br>3. 复数的表示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = 1 + 2j</span><br><span class="line">x.real</span><br><span class="line">x.imag</span><br></pre></td></tr></table></figure><p> 复数有实部和虚部，我们可以用 x.real 获取它的实部，用 x.imag 获取它的虚部。</p><h4 id="一些运算操作"><a class="markdownIt-Anchor" href="#一些运算操作">#</a> 一些运算操作</h4><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220701102223.png" alt=""><br> 一些比较常用的运算以及函数。</p><h4 id="布尔类型"><a class="markdownIt-Anchor" href="#布尔类型">#</a> 布尔类型</h4><p>1. 定义为 False 的对象：<br>（1）False 和 None<br>（2）值为 0 的数字类型：0,  0.0,  0j,Decimal（0），Fraction（0,1）。<br>（3）空的序列和集合：’’,  [],  (),  {},  set (),  range (0)。<br>2. 逻辑运算<br> 与或非，老生常谈，没啥可讲。<br> 唯一需要了解的是短路逻辑和运算符优先级。<br> 短路逻辑的核心思想就是：从左往右，只有当第一个操作数的值无法确定逻辑运算的结果时，才对第二个操作数进行求值。<br> 运算符有优先级，所以在遇到实际情况时该添加括号就添加括号。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>program Interaction的C前解题记录</title>
      <link href="/2022/06/25/pwncollege%E7%9A%84%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/"/>
      <url>/2022/06/25/pwncollege%E7%9A%84%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="program-interaction的c前解题记录"><a class="markdownIt-Anchor" href="#program-interaction的c前解题记录">#</a> program Interaction 的 C 前解题记录</h1><p>做题之前在终端输入：ssh -i key hacker@dojo.pwn.college，打开做题环境。</p><h3 id="11-3关"><a class="markdownIt-Anchor" href="#11-3关">#</a> 1.1-3 关</h3><p>前三关是密码传参。基本操作就是进入 challenge 文件夹，然后运行文件夹下的 embryoio_level，第一关没有密码，第二关程序运行后输入密码，第三关 embryoio_level + 密码，然后运行。密码都在提示中写了。</p><h3 id="2level47环境变量"><a class="markdownIt-Anchor" href="#2level47环境变量">#</a> 2.level4,7：环境变量</h3><p>主要就是使用指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">env -i &lt;program&gt;</span><br><span class="line">env -i NAME1=VALUE1 NAME2=VALUE2 </span><br><span class="line">//env -i ....=....  命令行（不用加括号）</span><br><span class="line">env -i ./embryoio_level7（设置空环境变量）</span><br></pre></td></tr></table></figure><p><command-line>使用指定的环境变量执行命令行<br> env -i …=…  命令行（不用加括号）<br>4 要求新增一个环境变量，7 要求设置一个空环境变量。</p><h3 id="3level56重定向"><a class="markdownIt-Anchor" href="#3level56重定向">#</a> 3.level5,6: 重定向</h3><p>5：重定向输入 : ./embryoio_level5 &lt;/tmp/mqetmb<br>6：重定向输出 : ./embryoio_level5 &gt;/tmp/mqetmb<br>5 题 vim 指定文件随便输入值，然后重定向，会提示输入某值替换掉你输入的值，然后再运行得出答案。<br>6 题 vim 指定文件随便输入值，然后重定向，再 vim 指定文件，答案就在文件中。</p><h3 id="48-14shell脚本"><a class="markdownIt-Anchor" href="#48-14shell脚本">#</a> 4.8-14：shell 脚本</h3><p>8：vim /tmp/my_script.sh 创建 shell 脚本，然后输入 /challenge/embryoio_level8 保存退出，再 bash /tmp/my_script.sh 运行脚本，得出答案。<br>14: 设置空环境变量并创建运行 shell 脚本，需要在脚本中写上：env -i /challenge/embryoio_level14。</p><h3 id="515-21ipython"><a class="markdownIt-Anchor" href="#515-21ipython">#</a> 5.15-21：ipython</h3><p>15：ipython 进入，然后使用下面这个指令运行程序。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess;subprocess.run([&quot;./embryoio_level15&quot;])</span><br></pre></td></tr></table></figure><p>16：要求输入密码<br> 17：要求传参，使用以下指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess;subprocess.run([&quot;./embryoio_level17&quot;,&quot;ianqniorrn&quot;])</span><br></pre></td></tr></table></figure><p>18：要求设置环境变量。使用以下指令。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess;subprocess.run([&quot;./embryoio_level18&quot;],env=&#123;&quot;yclqvl&quot;:&quot;gqfnjtrdva&quot;&#125;)</span><br></pre></td></tr></table></figure><p>19：要求重定向输入。使用以下指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">file = &#x27;/challenge/embryoio_level19&#x27;</span><br><span class="line">infile = open(&#x27;/tmp/...&#x27;)</span><br><span class="line">io = process(file,stdin=infile)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>20: 要求重定向输出。使用以下指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">file = &#x27;/challenge/embryoio_level20&#x27;</span><br><span class="line">outfile = open(&#x27;/tmp/...&#x27;,&#x27;a+&#x27;)</span><br><span class="line">io = process(file,stdout=outfile)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>21：设置空环境变量，需要以下指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess;subprocess.run([&quot;./embryoio_level21&quot;],env=&#123;&#125;)</span><br></pre></td></tr></table></figure><p> 以上指令也恰好差不多是 python 关卡的解题指令，所以说我在思考这些题的时候也把 python 给做完了，可能也是因为这些本来就很相似吧。</p><h3 id="622-28python"><a class="markdownIt-Anchor" href="#622-28python">#</a> 6.22-28:python</h3><p> python 做题的基本套路是 vim /tmp/my_script.py, 然后 python /tmp/my_script.py 运行即可。</p><p>22：要求创建并运行 python 文件，指令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">subprocess.run([&quot;./embryoio_level22&quot;])</span><br></pre></td></tr></table></figure><p>23：要求输入密码，和上题一样，运行之后在输入密码就行了。<br>24：要求传参，指令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">subprocess.run([&quot;./embryoio_level24&quot;,&quot;参数&quot;])</span><br></pre></td></tr></table></figure><p>25：要求设置环境变量，指令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">subprocess.run([&quot;./embryoio_level25&quot;],env=&#123;&quot;.....&quot;:&quot;....&quot;&#125;)</span><br></pre></td></tr></table></figure><p>26：要求输入重定向，指令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">file=&#x27;/challenge/embryoio_level26&#x27;</span><br><span class="line">infile=open(&#x27;/tmp/qxyfzu&#x27;)</span><br><span class="line">subprocess.run(file,stdin=infile)</span><br></pre></td></tr></table></figure><p>27：要求输出重定向，指令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">file=&#x27;/challenge/embryoio_level27&#x27;</span><br><span class="line">outfile=open(&#x27;/tmp/ayibsk&#x27;,&#x27;a+&#x27;)</span><br><span class="line">subprocess.run(file,stdout=outfile)</span><br></pre></td></tr></table></figure><p>28：要求设置空环境变量，指令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">subprocess.run([&quot;./embryoio_level28&quot;],env=&#123;&#125;)</span><br></pre></td></tr></table></figure><p> c 语言之前的关卡就已经打完了，对于很多指令代码我还都是一知半解的状态，特别是 python 这一块，我应该好好学一下。</p><h3 id="7python-file方法"><a class="markdownIt-Anchor" href="#7python-file方法">#</a> 7.python File 方法</h3><p> Python open () 方法用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。<br> ** 注意：** 使用 open () 方法一定要保证关闭文件对象，即调用 close () 方法。open () 函数常用形式是接收两个参数：文件名 (file) 和模式 (mode)。<br> 完整的语法是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open(file, mode=&#x27;r&#x27;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</span><br></pre></td></tr></table></figure><p>参数说明：<br>（1）file: 必需，文件路径（相对或者绝对路径）。<br>（2）mode: 可选，文件打开模式。<br>mode 参数有：</p><table><thead><tr><th style="text-align:left">模式</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">t</td><td style="text-align:left">文本模式 (默认)。</td></tr><tr><td style="text-align:left">x</td><td style="text-align:left">写模式，新建一个文件，如果该文件已存在则会报错。</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">二进制模式。</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">打开一个文件进行更新 (可读可写)。</td></tr><tr><td style="text-align:left">U</td><td style="text-align:left">通用换行模式（不推荐）。</td></tr><tr><td style="text-align:left">r</td><td style="text-align:left">以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr><td style="text-align:left">rb</td><td style="text-align:left">以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td></tr><tr><td style="text-align:left">r+</td><td style="text-align:left">打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td style="text-align:left">rb+</td><td style="text-align:left">以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td></tr><tr><td style="text-align:left">w</td><td style="text-align:left">打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td style="text-align:left">wb</td><td style="text-align:left">以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td style="text-align:left">w+</td><td style="text-align:left">打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td style="text-align:left">wb+</td><td style="text-align:left">以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td style="text-align:left">a</td><td style="text-align:left">打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td style="text-align:left">ab</td><td style="text-align:left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td style="text-align:left">a+</td><td style="text-align:left">打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr><td style="text-align:left">ab+</td><td style="text-align:left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> pwncolloge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滴水逆向：C语言（一）</title>
      <link href="/2022/06/24/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91%EF%BC%9AC%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/06/24/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91%EF%BC%9AC%E8%AF%AD%E8%A8%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="1c语言函数调用的基本流程"><a class="markdownIt-Anchor" href="#1c语言函数调用的基本流程">#</a> 1.c 语言函数调用的基本流程</h2><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220624090352079.png" alt=""><br> 在程序调用时，大致是按照这样的流程进行的，开栈也就是保存栈底，为缓冲区填充过数据之后，就开始进行我们函数所要干的事情，函数做的事情结束后，需要恢复现场，和开栈的顺序是相反的，然后降低堆栈，最后返回，一般返回之后会进行平栈，有的是外平栈，有的是内平栈。</p><h2 id="2c语言是怎样变成汇编的"><a class="markdownIt-Anchor" href="#2c语言是怎样变成汇编的">#</a> 2.c 语言是怎样变成汇编的？</h2><p>（1) 裸函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void __declspec(naked) Function()</span><br><span class="line">&#123;...&#125;</span><br><span class="line"></span><br><span class="line">void __declspec(naked) Function()  </span><br><span class="line">&#123;</span><br><span class="line">__asm ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 和正常的函数不同，裸函数生成汇编时啥也没有，所以要你自己添东西，正常函数还会生成一堆东西，防止出错。裸函数要自己添加一个 ret 返回，否则会报错。<br>（2) 调用约定</p><table><thead><tr><th>调用约定</th><th>参数压栈顺序</th><th>平衡堆栈</th></tr></thead><tbody><tr><td>__cdecl</td><td>从右至左入栈</td><td>调用者清理栈</td></tr><tr><td>__stdcall</td><td>从右至左入栈</td><td>自身清理堆栈</td></tr><tr><td>__fastcall</td><td>ECX/EDX 传送前两个剩下：从右至左入栈</td><td>自身清理堆栈</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eg:void __cdecl sum&#123;...&#125;</span><br></pre></td></tr></table></figure><p> 从右至左入栈就是设定的参数从右边往左边依次压栈，调用者清理堆栈就是外平栈，自身清理堆栈就是内平栈，__ fastcall 设定不多于两个参数时，用寄存器传参，这样比用内存传参更快，当设定参数过多时，多出的参数依然用内存传，也就是 PUSH，但是这样的话，快速传参的意义就消失了，所以使用__fastcall 时一般不设置那么多参数。</p><h2 id="3c语言中的数据类型"><a class="markdownIt-Anchor" href="#3c语言中的数据类型">#</a> 3.c 语言中的数据类型</h2><p>（1）数据类型<br> 基本类型：整数类型、浮点类型。<br> 构造类型：数组、结构体、共用体。<br> 指针类型。<br> 空类型。<br>（2）学习数据类型的要素<br> 存储数据的宽度<br> 存储数据的格式<br> 作用范围 (作用域)<br>（3）整数类型：char    short    int    long</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char    8BIT   1字节</span><br><span class="line">short   16BIT  2字节</span><br><span class="line">int     32BIT  4字节</span><br><span class="line">long    32BIT  4字节</span><br></pre></td></tr></table></figure><p>（4）有无符号数<br> 默认的数据类型都是有符号数，如果定义无符号数需要在开头加上 unsigned，计算机对于有无符号数的存储都是相同的。<br>（5）浮点类型<br> float 和 double 在存储方式上都是遵从 IEEE 的规范的。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220625215456.png" alt=""><br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220625215548.png" alt=""></p><p>将一个 float 型转化为内存存储格式的步骤为：<br> a. 先将这个实数的绝对值化为二进制格式<br> b. 将这个二进制格式实数的小数点左移或右移 n 位，直到小数点移动到第一个有效数字的右边。<br> c. 从小数点右边第一位开始数出二十三位数字放入第 22 到第 0 位。<br> d. 如果实数是正的，则在第 31 位放入 “0”，否则放入 “1”。<br> e. 如果 n 是左移得到的，说明指数是正的，第 30 位放入 “1”。如果 n 是右移得到的或 n=0，则第 30 位放入 “0”。<br> f. 如果 n 是左移得到的，则将 n 减去 1 后化为二进制，并在左边加 “0” 补足七位，放入第 29 到第 23 位。如果 n 是右移得到的或 n=0，则将 n 化为二进制后在左边加 “0” 补足七位，再各位求反，再放入第 29 到第 23 位。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220626001447.png" alt=""></p><h2 id="4程序的真正入口"><a class="markdownIt-Anchor" href="#4程序的真正入口">#</a> 4. 程序的真正入口</h2><p>（1） main 或 WinMain  是 “语法规定的用户入口”，而不是 “应用程序入口”。应用程序入口通常是启动函数。<br>（2） mainCRTStartup 和  wmainCRTStartup 是控制台环境下多字节编码和 Unicode 编码的启动函数。而 WinMainCRTStartup  和 wWinMainCRTStartup 是 windows 环境下多字节编码和 Unicode 编码的启动函数.<br>（3）main 函数的识别:<br>main  函数被调用前要先调用的函数如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GetVersion() </span><br><span class="line">_heap_init() </span><br><span class="line">GetCommandLineA() </span><br><span class="line">_crtGetEnvironmentStringsA() </span><br><span class="line">_setargv()</span><br><span class="line">_setenvp()</span><br><span class="line">_cinit()</span><br></pre></td></tr></table></figure><p> 这些函数调用结束后就会调用 main 函数。根据 main 调用参数的特征就可以找到函数的入口。</p><h2 id="5ascii编码和中文编码"><a class="markdownIt-Anchor" href="#5ascii编码和中文编码">#</a> 5.ASCII 编码和中文编码</h2><p>（1）ASCII 编码：<br> a.ASCII 码使用指定的 7 位或  8 位二进制数组合来表示 128 或 256 种可能的字符。<br> b. 标准 ASCII 码使用 7  位二进制数来表示所有的大写和小写字母，数字 0 到 9、标点符号，以及在美式英语中使用的特殊控制字符。<br> c. 扩展 ASCII  码允许将每个字符的第 8 位用于确定附加的 128 个特殊符号字符、外来语字母和图形符号。<br> 一般我们使用的都是标准的 ASCII 编码表，因为已经够用了。<br>（2）GB2312 和 GB2312-80<br> 这些编码设计视为了能够显示中文，用于将汉字转为计算机可以接受的数字系统的数。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220625235637.png" alt=""><br> 从图中可以看出一个汉字用两个 ASCII 码表示，这样可以将所表示的量大大增加，可以组合大约 7000 多个汉字。</p>]]></content>
      
      
      <categories>
          
          <category> 逆向学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯云+PicGo搭建图床</title>
      <link href="/2022/06/24/%E8%85%BE%E8%AE%AF%E4%BA%91-PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"/>
      <url>/2022/06/24/%E8%85%BE%E8%AE%AF%E4%BA%91-PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<p> 前段时间 github 博客崩了好长时间，好在后来又恢复了，但是我搭建的图床彻底崩了，图片上传不上，因为是用 github+picx 搭建的图床，不稳定也是在意料之内，索性用腾讯云更安稳一些。</p><h1 id="1腾讯云创建存储桶"><a class="markdownIt-Anchor" href="#1腾讯云创建存储桶">#</a> 1. 腾讯云创建存储桶</h1><p> 先注册个账号，然后在云产品中找到它的对象存储服务。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220624173311.png" alt=""><br> 云产品在页面左上，进入对象存储。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220624173620.png" alt=""><br> 点击创建存储桶<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220624173831.png" alt=""><br> 输入名称，不做啥要求，只不过这个是你的域名的一部分。访问权限一定要选公有读私有写，否则你上传的图片无法使用。默认警告可以打开，内容安全闭掉，然后下一步。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220624174051.png" alt=""><br> 直接下一步即可。确认配置也是直接过就行。</p><h1 id="2设置密钥"><a class="markdownIt-Anchor" href="#2设置密钥">#</a> 2. 设置密钥</h1><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220624180103.png" alt=""><br> 密钥管理 -&gt; 访问密钥<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220624183646.png" alt=""><br> API 密钥管理 -&gt; 新建密钥</p><h1 id="3下载picgo"><a class="markdownIt-Anchor" href="#3下载picgo">#</a> 3. 下载 PicGo</h1><p>下载 PicGo 地址：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/Molunerfinn/PicGo/releases</span><br></pre></td></tr></table></figure><p> 建议挂一个代理，或者网上找网盘资源，现在 github 下个东西真是太难了。<br> 下载好之后打开。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220624175241.png" alt=""><br> 在图床设置 -&gt; 腾讯云 COS 中，先设置前三个选项，前三个选项其实就是你设置的密钥了，除此之外 COS 版本选 v5。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220624180601.png" alt=""></p><p> 接着设置存储空间名、存储区域、自定义域名。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220624180939.png" alt=""><br> 存储桶列表 -&gt; 点击存储桶名称 -&gt; 概览，就能找到上图这个界面，然后根据信息完善你的设置，注意存储区域写的是你的所属地域后面括号里的内容。都设置好之后保存，然后开始测试能否上传图片。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/20220624181444.png" alt=""><br> 上传区上传一张图片，然后在相册中查看你上传的图片。可以复制一下网址在浏览器打开，能打开说明你的图床已经配置好了。</p><h1 id="4壁纸"><a class="markdownIt-Anchor" href="#4壁纸">#</a> 4. 壁纸</h1><p> 最后推荐一个肥肠好用的壁纸网站：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wall.alphacoders.com</span><br></pre></td></tr></table></figure><p> 不管是写博客用，还是主题用，或者电脑用，都力荐！</p>]]></content>
      
      
      <categories>
          
          <category> 图床搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reverse的wp</title>
      <link href="/2022/06/18/reverse%E7%9A%84wp/"/>
      <url>/2022/06/18/reverse%E7%9A%84wp/</url>
      
        <content type="html"><![CDATA[<h1 id="一-bobs-code"><a class="markdownIt-Anchor" href="#一-bobs-code">#</a> 一、Bob‘s Code</h1><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618164821624.png" alt=""><br> 首先，1 是给定的字符串，然后我们看 2 和 3，这两个都属于 base64 解密，但是其中一个 base 换了表。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618165248386.png" alt=""><br> 再看 4,4 的作用是将字符串的开头和结尾加上一个 &quot;.&quot;。</p><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618165639761.png" alt=""><br> 然后观察第 5 个函数，这个函数是一个爆破，可以写一个脚本逆一下。也就是遍历字符串对应的 ascII 可见字符串。<br>逆过来后是这样的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.U1ZorfEzdEZomVZkTXPOb.U5TmVLHaKP6VLZvmK5DmDBsaKUwULdZnVLYmD0.</span><br></pre></td></tr></table></figure><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618165521925.png" alt=""><br> 然后将逆过来的字符串去点，再进行 base 解码和换表解码。<br> base64 换表网上找的脚本可以用一下，然后正常的 base64 解码找个网站解。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import base64</span><br><span class="line">import string</span><br><span class="line">str1 = &quot;U1ZorfEzdEZomVZkTXPOb.U5TmVLHaKP6VLZvmK5DmDBsaKUwULdZnVLYmD0====&quot;</span><br><span class="line">string1 = &quot;ABCDEfghijklmnopqrsTUVWXYZabcdeFGHIJKLMNOPQRStuvwxyz0123456789-_&quot;</span><br><span class="line">string2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span><br><span class="line">print (base64.b64decode(str1.translate(str.maketrans(string1,string2))))</span><br></pre></td></tr></table></figure><p E7UI38f5-Xj2sUZ64-4F14Ef9a=""> Flag：ISCC</p><h1 id="二-经典base"><a class="markdownIt-Anchor" href="#二-经典base">#</a> 二、经典 base</h1><p gA6JawpVMZdVL=""><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618160430174.png" alt=""><br> 根据下面那一串字符可以知道这是 base58, 编码，把上面那串字符找一个网站拖进去就可以解出来。<br> Flag：ISCC</p><h1 id="三-经典re1用x64dbug进行调试"><a class="markdownIt-Anchor" href="#三-经典re1用x64dbug进行调试">#</a> 三、经典 re1（用 x64Dbug 进行调试)</h1><p> 拖进 IDA 中无法搜到字符串，也不能看到 mian 函数的伪代码，那就拖到 x64Dbug 中调试。运行一下程序，然后直接搜索字符串。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618184409092.png" alt=""></p><h1 id="四-手动脱壳"><a class="markdownIt-Anchor" href="#四-手动脱壳">#</a> 四、手动脱壳</h1><p> 将修狗程序拖入 ollyDbug。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618200250285.png" alt=""><br> F8 运行一步，可以看到 ESP 发生变化，然后右键。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618200328565.png" alt=""><br> 选择数据窗口跟随。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618200427735.png" alt=""><br> 选择硬件写入，然后 shift+f9<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618200528957.png" alt=""><br> F8 运行几步，在 jnz 这里的下面设置一个断点，f4 执行跳过 jnz，因为 jnz 是往上跳转的，所以要跳过这里。然后执行完 jmp 来到一个新的入口。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618200817646.png" alt=""><br> 右键选择用 OllyDump 脱壳调试进程。</p><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618203916051.png" alt=""><br> 先点获取 EIP 作为 OEP，然后再点脱壳进行保存。<br> 保存的文件再用 IDA 打开就可以发现 flag 了。</p><h1 id="五-squid"><a class="markdownIt-Anchor" href="#五-squid">#</a> 五、squid</h1><p>用 IDA 打开程序，发现很多 py，可以确定这是和 python 反编译有关。<br><a href="http://xn--pyinstxtractor-9v1wl125b.py">使用 pyinstxtractor.py</a>，将文件拖入文件夹，使用以下指令，可以分出一些文件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objcopy --dump-section pydata=pydata.dump</span><br><span class="line">python pyinstxtractor.py &lt;filename&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 逆向学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆栈图</title>
      <link href="/2022/06/18/%E5%A0%86%E6%A0%88%E5%9B%BE/"/>
      <url>/2022/06/18/%E5%A0%86%E6%A0%88%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>一、堆栈图<br> 1.Windows 堆栈的特点<br> （1）先进后出<br> （2）向低地址扩展<br> Windows 中的堆栈，是一块普通的内存，主要用来存储一些临时的数据和参数等可以把 Windows 中的堆栈想象成是一个公用的书箱，函数就像是使用箱子的人函数在执行的时候，会用到这个书箱，把一些数据存到里面，但用完的时候一定要记得把书拿走，否则会乱的，也就是说，你放进去几本书，走的时候也要拿走几本书，这个就是堆栈平衡。<br>2. 函数<br> 计算机的函数，是一个固定的一个程序段，或称其为一个子程序，它在可以实现固定运算功能的同时还带有一入口和一个出口，所谓的入口，就是函数所带的各个参数，我们可以通过这个入口，把函数的参数值代入子程序，供计算机处理，所谓出口，就是指函数的计算结果，也称为返回值，在计算机求得之后，由此口带回给调用它的程序。<br>3. 汇编中的函数<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618144251704.png" alt=""><br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618144323907.png" alt=""><br> 4. 常见的操作<br>（1）CALL 指令压入栈的地址我们称作函数执行完之后的返回地址。在 OD 里面画堆栈图执行 call 函数按 F7。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220608124647230.png" alt=""></p><p>（2）这条指令的作用是将 EBP-40 的地址取出放入 EDI 寄存器中。</p><p>（3）<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220608130217339.png" alt=""><br> 这三条指令的作用是防止缓冲区溢出。</p><p>（4）<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220608131538958.png" alt=""><br> 恢复现场。<br> 堆栈平衡：调用函数前后堆栈没有变化<br>（5) return 指令相当于 pop eip<br> 二、画堆栈图<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618152056355.png" alt=""><br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618152152522.png" alt=""><br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220618152243776.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 逆向学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滴水逆向（二）</title>
      <link href="/2022/06/07/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/06/07/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="一-jcc"><a class="markdownIt-Anchor" href="#一-jcc">#</a> 一、JCC</h1><p>1.JMP 指令<br> JMP 指令的作用就是修改 EIP 寄存器的值，MOV 指令不能用来修改 EIP。<br> 简写为：JMP    寄存器 / 立即数<br> 2.CALL 指令<br> PUSH   地址 B<br> 简写为：CALL  地址 A / 寄存器<br>两者的区别：JMP 只修改 EIP，CALL 指令将程序运行的下一行地址 PUSH 堆栈中，再修改 EIP。<br>需要注意：CALL 和 ret 指令一般同时出现，CALL 结束之后，再 ret 返回。<br>3.ESP 寄存器<br> ESP 寄存器就是栈指针寄存器，存储堆栈使用到的地址。<br>4.EIP 寄存器<br> EIP 存储程序运行到的位置。JMP 指令和 CALL 指令就是用来修改 EIP 的指令。<br>5.PUSH 和 POP（压栈和出栈）<br>（1）PUSH 指令<br> 将数据压入栈中。<br>（2）POP 指令<br> 将数据</p><p>6.CMP 指令</p><p><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220607205200559.png" alt=""></p><p> CMP 指令操作和 SUB 指令相当，但是它不会将结果保存，而是只会修改标志寄存器的值。<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220607205342455.png" alt=""></p><p> TEST 指令与 CMP 指令同理。<br>7.JCC<br><img src="https://xmzbk-1310919595.cos.ap-nanjing.myqcloud.com/image-20220607205439657.png" alt=""><br><img src="C:%5CUsers%5Ca%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220607205500689.png" alt="image-20220607205500689"><br> JCC 指令就是 JMP 指令，只不过在执行前增加了一个判断条件，并且也只会修改 EIP 寄存器的值。比如：JE 指令执行时，首先判断 ZF 位是否为 1，为 1 则执行，不为 1 则不执行。JNE 和 JE 的判断条件相反。</p>]]></content>
      
      
      <categories>
          
          <category> 逆向学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现base64编码</title>
      <link href="/2022/04/27/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0base64%E7%BC%96%E7%A0%81/"/>
      <url>/2022/04/27/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0base64%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求">#</a> 题目要求</h1><p> 使用 c/c++ 完成以下下算法:<br> 输入一个字符串，检查该字符串总 ascii 码值。如果值大于 1000 则对该字符串进行 base64 加密输出，否则该字符串与 base64 编码表进行异或输出。<br> 说实话我的 c 语言能力真的弱，这道题看着这么简单，实际上实现起来很有难度。这道题目主要是这几个部分：1. 检测字符串 ASCII 码值；2.base64 编码；3. 将字符串与 base64 编码表异或。</p><h2 id="一-检测字符串的ascii码值"><a class="markdownIt-Anchor" href="#一-检测字符串的ascii码值">#</a> 一、检测字符串的 ASCII 码值</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; chuanchuan[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        n=chuanchuan[i];</span><br><span class="line">        sum = sum +n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你的串串的长度是：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br></pre></td></tr></table></figure><p> 这段代码实现起来十分简单，使用 for 循环就可以了，采用累加的方式将所得单个字符的 ASCII 码值相加，最后得到总的 ASCII 码值。</p><h2 id="二-实现base64编码"><a class="markdownIt-Anchor" href="#二-实现base64编码">#</a> 二、实现 base64 编码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">base64</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *chuanchuan)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *base64laobiao = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line">    <span class="keyword">long</span> changdu = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *res;</span><br><span class="line">     changdu= <span class="built_in">strlen</span>(chuanchuan);</span><br><span class="line">     <span class="keyword">if</span>(changdu%<span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        len = changdu/<span class="number">3</span>*<span class="number">4</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        len = (changdu/<span class="number">3</span>+<span class="number">1</span>)*<span class="number">4</span>;</span><br><span class="line">     res = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>)*len + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//malloc()函数在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。</span></span><br><span class="line">     res[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">     <span class="keyword">int</span> i,j;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;=len<span class="number">-1</span>;j+=<span class="number">3</span>,i+=<span class="number">4</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         res[i] = base64laobiao[chuanchuan[j]&gt;&gt;<span class="number">2</span>];</span><br><span class="line">         res[i+<span class="number">1</span>] = base64laobiao[(chuanchuan[j]&amp; <span class="number">0x3</span>)&lt;&lt;<span class="number">4</span> | (chuanchuan[j+<span class="number">1</span>]&gt;&gt;<span class="number">4</span>)];</span><br><span class="line">         res[i+<span class="number">2</span>] = base64laobiao [(chuanchuan[j+<span class="number">1</span>] &amp; <span class="number">0xf</span>)&lt;&lt;<span class="number">2</span> | (chuanchuan[j+<span class="number">2</span>])&gt;&gt;<span class="number">6</span>];</span><br><span class="line">         res[i+<span class="number">3</span>] = base64laobiao[chuanchuan[j+<span class="number">2</span>]&amp;<span class="number">0x3f</span>];</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//第一个字符的前6位</span></span><br><span class="line"><span class="comment">//第一个字符的后两位与第二个字符的前四位结合</span></span><br><span class="line"><span class="comment">//第二个字符的后四位与第三个字符的前两位结合</span></span><br><span class="line"><span class="comment">//第三个字符的六位</span></span><br><span class="line">     <span class="keyword">switch</span>(changdu%<span class="number">3</span>)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        res[i - <span class="number">2</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        res[i - <span class="number">1</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">             <span class="comment">//对剩余4位的补两个“=”</span></span><br><span class="line">     <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        res[i - <span class="number">1</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">             <span class="comment">//对剩余2位的补一个“=”</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 代码有借鉴别人的成分，只有我自己我可写不出来。<br> 主要难度就在于编码部分，下面附上 base64 编码的简单讲解。<br> Base64 编码，是我们程序开发中经常使用到的编码方法。它是一种基于用 64 个可打印字符来表示二进制数据的表示方法。它通常用作存储、传输一些二进制数据编码方法！</p><p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/base64%E7%BC%96%E7%A0%81%E8%A1%A8.3uee5rdheyi0.webp" alt="base64编码表"><br> base64 其实就是用 64 个可打印的字符去表示所有的二进制数，base64 的编码原理也很简单，假如给定三个字符：M a n，然后找到他们的各自对应的 ASCII 码值，然后将这些码值换算成十六进制，接着再都换算成二进制，然后对所有二进制数重新分割再组合，将最后组合成的二进制数再对照 base64 表编码。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2022-04-27-221311.76lhq8bfrck0.webp" alt="屏幕截图-2022-04-27-221311"><br> 每个字符占八位内存，但是 base64 编码每位占 6 位内存，所以在进行转换的时候，如果源码恰好是 3 的倍数，则可以恰好转换成 base64 编码，就比如上述所举的例子，M a n，对应 24 位内存，除以 6，是四位 base64 编码，所以一般来说，源码在进行编译之后，长度都会变长，如果是 3 的倍数，在编码过后的长度就是源码的 4/3 倍。<br> 但是，如果不是三的倍数的时候，进行编码的时候就会出现位数不足的情况，这种情况下，base64 另有一套解决方案，编码位数不足的时候补 0，并且还要满足凑出的位数是 8 的倍数，因为编码位数的特殊，所以剩余位数不是 2 位就是 4 位，因此当剩余二位的时候，补一个特殊的 6 位符号 “=”，当剩余 4 位的时候，补两个 “=”。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2022-04-27-223118.3x4yepw2t5m0.webp" alt="屏幕截图-2022-04-27-223118"></p><h3 id="三-实现字符串与base64异或运算"><a class="markdownIt-Anchor" href="#三-实现字符串与base64异或运算">#</a> 三、实现字符串与 base64 异或运算</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *n = chuanchuan;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你的串串太短了，接下来将你的串串和base64编码表进行异或：\n&quot;</span>);</span><br><span class="line">        <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; chuanchuan[i]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m= chuanchuan[i]^base64laobiao[i];</span><br><span class="line">            <span class="built_in">sprintf</span> (str, <span class="string">&quot;%c&quot;</span>, m);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, m);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p> 实现这段代码的时候用了好久，主要是没明白计算机怎样计算字符串之间的异或运算，我在尝试了一番之后，我认为的是计算机计算字符串的异或，字符串转十六进制，再异或，最后得到的结果类型可以是整形，我将整形转换成字符串类型，然后再输出。<br>结尾附上源代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _BASE64_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BASE64_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _BASE64_H</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">base64</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *chuanchuan)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">haoduan</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *chuanchuan)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *base64laobiao = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> chuanchuan[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你的串串：\n&quot;</span>);</span><br><span class="line">    gets(chuanchuan);</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; chuanchuan[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        n=chuanchuan[i];</span><br><span class="line">        sum = sum +n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你的串串的长度是：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">if</span>(sum&gt;<span class="number">1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;你的串串有点长，接下来进行base64加密：\n&quot;</span>);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, base64(chuanchuan));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> *n = chuanchuan;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你的串串太短了，接下来将你的串串和base64编码表进行异或：\n&quot;</span>);</span><br><span class="line">        <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; chuanchuan[i]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m= chuanchuan[i]^base64laobiao[i];</span><br><span class="line">            <span class="built_in">sprintf</span> (str, <span class="string">&quot;%c&quot;</span>, m);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">base64</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *chuanchuan)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *base64laobiao = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line">    <span class="keyword">long</span> changdu = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *res;</span><br><span class="line">     changdu= <span class="built_in">strlen</span>(chuanchuan);</span><br><span class="line">     <span class="keyword">if</span>(changdu%<span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        len = changdu/<span class="number">3</span>*<span class="number">4</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        len = (changdu/<span class="number">3</span>+<span class="number">1</span>)*<span class="number">4</span>;</span><br><span class="line">     res = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>)*len + <span class="number">1</span>);</span><br><span class="line">     res[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">     <span class="keyword">int</span> i,j;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;=len<span class="number">-1</span>;j+=<span class="number">3</span>,i+=<span class="number">4</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         res[i] = base64laobiao[chuanchuan[j]&gt;&gt;<span class="number">2</span>];</span><br><span class="line">         res[i+<span class="number">1</span>] = base64laobiao[(chuanchuan[j]&amp; <span class="number">0x3</span>)&lt;&lt;<span class="number">4</span> | (chuanchuan[j+<span class="number">1</span>]&gt;&gt;<span class="number">4</span>)];</span><br><span class="line">         res[i+<span class="number">2</span>] = base64laobiao [(chuanchuan[j+<span class="number">1</span>] &amp; <span class="number">0xf</span>)&lt;&lt;<span class="number">2</span> | (chuanchuan[j+<span class="number">2</span>])&gt;&gt;<span class="number">6</span>];</span><br><span class="line">         res[i+<span class="number">3</span>] = base64laobiao[chuanchuan[j+<span class="number">2</span>]&amp;<span class="number">0x3f</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">switch</span>(changdu%<span class="number">3</span>)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        res[i - <span class="number">2</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        res[i - <span class="number">1</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        res[i - <span class="number">1</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> c语言代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滴水逆向（一）</title>
      <link href="/2022/04/07/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/04/07/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="数据宽度与逻辑运算"><a class="markdownIt-Anchor" href="#数据宽度与逻辑运算">#</a> 数据宽度与逻辑运算</h1><p>  数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的制约，数据都是有长度限制的（我们称为超过最多宽度的数据会被丢弃，也就是说存不下的超出限制的那些数据直接被抛弃了、不存了）。</p><h2 id="一-数据宽度的表示"><a class="markdownIt-Anchor" href="#一-数据宽度的表示">#</a> 一、数据宽度的表示</h2><p>  1.4 位宽度表示：假设计算机只能存储 4 位 2 进制数<br>  存储无符号数，那么从 0 到 F，再往后还是从零开始。<br>  存储正数和负数，那么正数是 0,1,2,3,4,5,6,7（在计算机里把 0 看做正数），负数是 - 1，-2，-3，-4，-5，-6，-7，-8，对应 F,E，D，C，B，A,9,8, 并且，二进制数 1 开头的都是负数，0 开头的都是正数。<br><img src="https://img-blog.csdnimg.cn/7a6a3da130044aa18779a5f8098fab7b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGwyNjU1ODk0NTIw,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p>  2.8 位宽度表示：假设计算机只能存储 8 位 2 进制数<br><img src="https://img-blog.csdnimg.cn/995858070d7e41bb906a8caf8da0cd3d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGwyNjU1ODk0NTIw,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p>  3.16 位宽度表示：假设计算机只能存储 16 位 2 进制数<br><img src="https://img-blog.csdnimg.cn/508b17abfc7543e08520e3a45006008c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGwyNjU1ODk0NTIw,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p>  4.32 位宽度表示：假设计算机只能存储 32 位 2 进制数<br><img src="https://img-blog.csdnimg.cn/c1cf763a4c9c4825a90b5b9552722401.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGwyNjU1ODk0NTIw,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p>  注：有符号、无符号什么的都是自己定义的。</p><h2 id="二-几个重要的计量单位"><a class="markdownIt-Anchor" href="#二-几个重要的计量单位">#</a> 二、几个重要的计量单位</h2><p>  BYTE      字节       8BIT<br>  WORD     字        16BIT     2 字节<br>  DWORD   双字     32BIT    4 字节</p><h2 id="三-二进制的逻辑运算"><a class="markdownIt-Anchor" href="#三-二进制的逻辑运算">#</a> 三、二进制的逻辑运算</h2><p>  1. 逻辑运算：或（or    |  ）只要有一个为 1 就是 1<br><img src="https://img-blog.csdnimg.cn/fa4c890ad712426eb8f30f80d83ff1d6.png" alt=""></p><p>  在这个电路图中，只要有一个开关闭上，灯泡就亮，然后就为 1，所以或运算只要有一个为 1 就是 1。<br>  2. 逻辑运算：与（and   &amp;  ）两个都为 1 才是 1</p><p><img src="https://img-blog.csdnimg.cn/de08c7de76094741a3ab2c8cfa583484.png" alt=""><br>  在这个电路图中，两个开关都闭上才为 1，<br>  3. 逻辑运算：异或（xor   ^   ) 不一样为 1<br><img src="https://img-blog.csdnimg.cn/9cb90835a6b8498fb2ae16ff93591d47.png" alt=""></p><p>  4. 逻辑运算：非（not     ！ ）1 是 0    0 是 1<br><img src="https://img-blog.csdnimg.cn/514f8aa407ec406293b7341457a900b7.png" alt=""></p><h2 id="四-32位通用寄存器"><a class="markdownIt-Anchor" href="#四-32位通用寄存器">#</a> 四、32 位通用寄存器</h2><p>  32 位意思是能存 32 个 0 或 1，这些寄存器能存 0 到 8 个 F<br><img src="https://img-blog.csdnimg.cn/6de7862a41444a8ab9ae088556ab9059.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGwyNjU1ODk0NTIw,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""><br>  学好这些内容的前提要求：要把二进制与十六进制的映射记到无比熟练的地步。</p><h1 id="通用寄存器内存读写"><a class="markdownIt-Anchor" href="#通用寄存器内存读写">#</a> 通用寄存器 —— 内存读写</h1><p>一、通用寄存器<br><img src="https://img-blog.csdnimg.cn/086eebf3e7d140839772185aafe1193e.png" alt=""><br><img src="https://img-blog.csdnimg.cn/b690fa40ba664d44ad65c77560086800.png" alt=""></p><p>  32 位寄存器从中间分开，其中一半形成了 16 位寄存器，16 位寄存器前四个再从中间分开，形成 8 个 8 位的寄存器，并不是说 32 位、16 位、8 位寄存器是分开来算的，而是包含关系，我只需要 8 位，那就只用到 8 位，我需要 32 位的，那我就用到 32 位。<br>二、汇编代码<br>  所要学的内容：<br>  1.MOV 指令<br>  2.ADD 指令<br>  3.SUB 指令<br>  4.AND 指令<br>  5.OR 指令<br>  6.XOR 指令<br>  7.NOT 指令<br>  各指令所在网址：<a href="https://www.bcdaren.com/video/videoPlay/330285640321339392">https://www.bcdaren.com/video/videoPlay/330285640321339392</a><br>1.MOV 指令<br>  操作码 目标操作数  源操作数<br>  MOV   EAX，OxAAAAAAAA<br>  MOV   AX，OxBBBB<br>  MOV   AH,OxCC<br>  MOV   AL,OxDD</p><p>  MOV 的作用：拷贝源操作数到目标操作数（也就是将源操作数复制到目标操作数中）。<br>  （1）源操作数可以是立即数、通用寄存数、段寄存器、或者内存单元。<br>  （2）目标操作数可以是通用寄存器、段寄存器或者内存单元。<br>  （3）操作数的宽度必须一样。<br>  （4）源操作数和目标操作数不能同时为内存单元。<br>MOV 指令：<br><img src="https://img-blog.csdnimg.cn/6a6bdab14d8f43298ff514d68a628f51.png" alt=""><br>MOV 的语法：<br><img src="https://img-blog.csdnimg.cn/b92b0fe9d99f45f3bebdc74c18b0beb8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGwyNjU1ODk0NTIw,size_11,color_FFFFFF,t_70,g_se,x_16" alt=""><br>三、内存读写</p><p>1. 寄存器与内存的区别<br>  （1）寄存器位于 CPU 内部，执行速度快，但比较贵<br>  （2）内存速度相对较慢，但成本低，所以可以做的很大<br>  （3）寄存器和内存没有本质区别，都是用于存储数据的容器，都是定宽的（即都是有边界的）。<br>  （4）寄存器常用的有 8 个：EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI。<br>  （5）计算机中的几个常用计量单位：BYTE,WORD,DWORD。</p><p>  BYTE      字节    =   8BIT<br>  WORD     字     =  16（BIT）<br>  DWORD   双字     32（BIT）</p><p>  1KB = 1024BYTE<br>  1MB = 1024KB<br>  1GB = 1024MB</p><p>  2. 内存的数量特别庞大，无法每个内存单元都起一个名字，所以用编号来代替，我们称计算机 CPU 是 32 位或者 64 位，有很多书上说之所以叫 32 位计算机是因为寄存器的宽度是 32 位，是不准确的，因为还有很多寄存器是大于 32 位的。<br>计算机内存的每一个字节会有一个编号（即内存编号的单位是字节），如下图：</p><p>  3. 内存格式<br><img src="https://img-blog.csdnimg.cn/3b742423b1f14a70ae1653ed9ea4cb28.png" alt="">  只要涉及内存读写的，一定要指定它的宽度</p><p>  4. 从指定内存中写入 / 读取数据<br><img src="https://img-blog.csdnimg.cn/c0a68e95d5db47878e8e1f028244fa55.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGwyNjU1ODk0NTIw,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h1 id="内存地址堆栈"><a class="markdownIt-Anchor" href="#内存地址堆栈">#</a> 内存地址 —— 堆栈</h1><p>1. 关于 32 位、16 位、8 位通用寄存器<br>  这几个寄存器的关系可以说是包含的关系，32 位寄存器分为上位和下位的话，16 位寄存器就是 32 位寄存器的下位，这几个寄存器不是分开来算的，8 位寄存器发生变化，16 位、32 位寄存器也可能发生变化。</p><p>2. 寄存器的结构：EAX-AX-AH-AL 的对应关系</p><pre><code>这几个寄存器是包含关系</code></pre><p>3. 为什么 8 位寄存器只能存放 2 个十六进制的数？<br>  因为 8 位寄存器只能存 8 位，而一位的十六进制数对应四位二进制数，所以两个 16 进制数换算成 2 进制数正好占 8 位，</p><p>4. 内存单元：字节。<br>  每个字节有个编号，称为内存地址，一个字节等于 8 比特位，也就是一字节等于 8 位。<br>  每个编号对应一块内存，这个内存就是一个字节<br>  内存中的最小单元就是字节</p><pre><code>    内存单元的换算：    1GB=1024MB    1MB=1024KB    1KB=1024B    1B（字节）=8b yte（位）    BYTE      字节    =   8BIT          一个字节    WORD     字     =  16（BIT）   两个字节    DWORD   双字     32（BIT）    四个字节</code></pre><p>5. 数据窗口的使用、数据窗口与堆栈窗口的显示方式<br>反汇编窗口<br>  程序是怎么跑的，汇编的执行都在这个窗口<br><img src="https://img-blog.csdnimg.cn/d1224f538b7b4da1b0ee1803929d7107.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p-Q5Lq65LiN5Lya5pWy5Luj56CB,size_11,color_FFFFFF,t_70,g_se,x_16" alt=""><br>寄存器窗口<br>  8 位的、16 位的、32 位的寄存器都在这个窗口<br><img src="https://img-blog.csdnimg.cn/bd5a0f8d100642a9813275904da34768.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p-Q5Lq65LiN5Lya5pWy5Luj56CB,size_10,color_FFFFFF,t_70,g_se,x_16" alt=""> 堆栈窗口<br>   一个特殊的内存窗口<br>  这个窗口里面的编号是四个字节组成一组进行显示，四个字节换算一下就是 32 位<br><img src="https://img-blog.csdnimg.cn/22a31b34f6d248c69de62f8f9c41d97f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p-Q5Lq65LiN5Lya5pWy5Luj56CB,size_11,color_FFFFFF,t_70,g_se,x_16" alt=""><br>数据窗口<br>  在这个窗口可以了解数据<br><img src="https://img-blog.csdnimg.cn/b5851a587dc84aceb6ac74250c3297a0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p-Q5Lq65LiN5Lya5pWy5Luj56CB,size_12,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p>6. 寻址方式：<br>  寻址公式一：[立即数]<br>  读取内存的值：<br>  MOV EAX,DWORD  PTR  DS:[0x13FFC4]<br>  MOV EAX,DWORD  PTR  DS:[0x13FFC4]<br>  也就是将内存单元的数据给显示出来</p><pre><code>    向内存中写入数据：    MOV DWORD PTR DS:[0x13FFC4],eax    MOV DWORD PTR DS:[0x13FFC4],ebx    获取内存编号：    LEA EAX,DWORD PTR DS:[0X13FFC4]    LEA EAX,DWORD PTR DS:[ESP+8]    和读取内存的值不一样，这个是把内存单元的编号给显示出来的指令</code></pre><p>寻址公式二:[reg]<br>  注：reg 代表寄存器   可以是 8 个通用寄存器中的任意一个<br>  读取内存的值：<br>  MOV ECX,0x13FFD0<br>  MOV EAX,DWORD PTR DS:[ECX]<br>  把地址编号放到 ECX 这个寄存器里面，然后在通过这个寄存器找到内存，再放到 EAX 里面</p><pre><code>    向内存中写入数据：    MOV EDX,0x13FFD8    MOV DWORD PTR DS:[EDX],0x87654321    获取内存编号：    LEA EAX,DWORD PTR DS:[EDX]    MOV EAX,DWORD PTR DS:[EDX]</code></pre><p>寻址公式三:[reg + 立即数]<br>  读取内存的值:<br>  MOV ECX,0x13FFD0<br>  MOV EAX,DWORD PTR DS:[ECX+4]</p><pre><code>    向内存中写入数据:    MOV EDX,0x13FFD8    MOV DWORD PTR DS:[EDX+0xC],0x87654321    获取内存编号:    LEA EAX,DWORD PTR DS:[EDX+4]    MOV EAX,DWORD PTR DS:[EDX+4]</code></pre><p>寻址公式四:[reg+reg*{1,2,4,8}]<br>  读取内存的值<br>  MOV EAX,13FFC4<br>  MOV ECX,2<br>  MOV EDX,DWORD PTR DS:[EAX+ECX*4]<br>  注：1,2,4,8 是固定不变的，不要随意改</p><pre><code>    向内存中写入数据:    MOV EAX,13FFC4    MOV ECX,2    MOV DWORD PTR DS:[EAX+ECX*4],87654321    获取内存编号:    LEA EAX,DWORD PTR DS:[EAX+ECX*4]</code></pre><p>寻址公式五:[reg+reg*{1,2,4,8}+ 立即数]<br>  和寻址公式四同样的道理<br> 7. 堆栈</p><pre><code>    1.什么是堆栈    2.堆栈操作</code></pre><p>思考：<br>  假设我们需要一块内存，有如下的要求：<br>  1. 主要用于临时存储一些数据，如果数量很少就放到寄存器中<br>  2. 能够记录存了多少数据<br> 3. 能够非常快速的找到某个数据<br>那么堆栈的原理可以理解为：</p><pre><code>    1.BASE,TOP是2个32位的通用寄存器，里面存储的是内存单元编号（内存地址）    2.BASE里面存储了一个地址，记录的起始地址    3.TOP里面也存储了一个地址，记录的是结束的地址    4.存入数据的时候，TOP的值减4（为方便演示，每次存取都是4个字节）    5.释放数据的时候，TOP的值加4（为方便演示，每次存取都是4个字节）    6.如果要读取中间的某个数据的时候可以通过TOP或者BASE加上偏移的方式去读取    7.这个内存的读取方式有个学名：堆栈    堆栈的优点：临时存储大量的数据，便于查找。</code></pre><h1 id="标志寄存器"><a class="markdownIt-Anchor" href="#标志寄存器">#</a> 标志寄存器</h1><p>1.push 指令：<br>  PUSH r32<br>  PUSH r16<br>  PUSH m16<br>  PUSH m32<br>  PUSH imm8/imm16/imm32<br>2.POP 指令<br>  把堆栈里面的值取出来放到一个容器里<br>  POP r16<br>  POP r32<br>  POP m16<br>  POP m32<br>  PUSHAD、POPAD 这两个指令稍作了解即可<br> 3.EFLAGS 寄存器<br><img src="https://img-blog.csdnimg.cn/8cf8ce13d4d84ca89fb6898eb3455455.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p-Q5Lq65LiN5Lya5pWy5Luj56CB,size_14,color_FFFFFF,t_70,g_se,x_16" alt=""><br>  查看 DTDBUG 中的 EFLAGS 的值，然后转换成二进制的形式，并取出 CF/PF/AF/ZF/SF/OF 的值<br>记住这几个寄存器的位置和名称<br>  （1）进位标志 CF（Carry Flag）：如果运算结果的最高位产生了一个进位或借位，那么，其值为 1，否则其值为 0。<br>  MOV AL,0xEF<br>  MOV AL,0xFE<br>  ADD AL,2<br>  ADD AL,2<br>  （2）奇偶标志 PF（Parity Flag)：奇偶标志 PF 用于反映运算结果中 “1” 的个数的奇偶性。如果 “1” 的个数为偶数，则 PF 的值为 1，否则其值为 0。<br>  MOV AL,3<br>  MOV AL,3<br>  MOV AL,2</p><p>  （3）辅助进位标志 AF（Auxiliary Carry Flag）:<br> 在发生下列情况是，辅助进位标志 AF 的值被设置为 1，否则其值为 0：<br>  在字操作时，发生低字节向高字节进位或借位时；<br>  在字节操作时，发生低 4 位向高 4 位进位或借位时。<br>MOV EAX,0x55EEFFFF    MOV AX,5EFE    MOV AL,4E<br>ADD EAX,2         ADD AX,2      ADD AL,2</p><p>  （4）零标志 ZF（Zero Flag），零标志 ZF 用来反映运算是否为 0。如果运算结果为 0，则其值为 1，否则为 0。在判断运算结果是否为 0 时，可使用此标志位。<br>  XOR EAX,EAX<br>  MOV EAX,2<br>  SUB EAX,2<br>  （5）符号标志 SF（Sign Flag）：符号标志 SF 用来反映运算结果的符号位，它与运算结果的最高位相同。<br>  MOV AL,7F<br>  ADD AL,2</p><p>  （6）溢出标志 OF（Overflow Flag）：溢出标志 OF 用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF 的值被置为 1，否则，OF 的值被清为 0</p><p>4.ADC 指令：带进位加法<br>  格式：ADC  R/M,R/M/IMM   两边不能同时为内存   宽度要一样<br>  ADC AL,CL<br>  ADC BYTE PTR DS:[12FFC4],2<br>  ADC BYTE PTR DS:[12FFC4],AL</p><p>SBB 指令：带借位减法<br>  格式：SBB  R/M,R/M  两边不能同时为内存  宽度要一样<br>  SBB AL,CL<br>  SBB BYTE PTR DS:[12FFC4],2<br>  SBB BYTE PTR DS:[12FFC4],AL</p><p>XCHG 指令：交换数据<br>  格式：XCGH  R/M,R/M   两边不能同时为内存，宽度要一样<br>  XCGH AL,CL<br>  XCGH DWORD PTR DS:[12FFC4],EAX<br>  XCGH BYTE PTR DS:[12FFC4],AL</p><p>MOVS 指令：移动数据  内存 - 内存<br>  BYTE/WORD/DWORD<br>  MOVS BYTE PTR ES:[EDI],BYTE PTR DS:[ESI]  简写为：MOVSB<br>  MOVS WORD PTR ES:[EDI],BYTE PTR DS:[ESI]  简写为：MOVSW<br>  MOVS DWORD PTR ES:[EDI],BYTE PTR DS:[ESI] 简写为：MOVSD</p><p>5.STOS 指令：将 AI/AX/EAX 的值存储到 [EDI] 指定的内存单元<br>  STOS BYTE PTR ES:[EDI]   简写为 STOSB<br>  STOS WORD PTR ES:[EDI]   简写为 STOSW<br>  STOS DWORD PTR ES:[EDI]   简写为 STOSD</p><p>6.REP 指令：按计数寄存器（ECX）中指定的次数重复执行字符串指令<br>  MOV ECX,10<br>  REP MOVSD<br>  REP STOSD</p><p>本文图片取自我自己的 CSDN 博客的文章。</p>]]></content>
      
      
      <categories>
          
          <category> 逆向学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp datelab详解</title>
      <link href="/2022/04/05/csapp%20datelab%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/04/05/csapp%20datelab%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>  环境搭建用了我好久的时间，这个电脑我是真的服气，进入 vm 卡半天，刚搭建好的 Ubuntu 又遇到一些问题，直接寄了。没办法，只能再耗费一些时间重新搭建 Ubuntu， 结果又因为网卡，下载镜像就下了两天，搭建环境是真滴累。好在是经过一番努力终于将环境搞定，可以开始实验了。</p><h1 id="1bitxor"><a class="markdownIt-Anchor" href="#1bitxor">#</a> 1.bitXor</h1><p>  这道题的目的大致就是用于运算和非运算实现实现异或运算，难度还可以。  逻辑运算有三种基本运算：与、或、非，其他复杂的运算可以用这三种运算实现。</p><p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/1.363n09yqcnk0.webp" alt=""><br>  我推了几遍只推出一个公式，也就是 return (~x &amp; y)|(x &amp; ~y); 大致过程就是先画出真值表，然后推导公式，最后是画逻辑电路图，不过这一步就没必要了。但是这显然不符合题目要求，题目要求只用与和非，所以进一步推导的公式就是 return <sub>(</sub>x &amp; ~y) &amp; ~(x &amp; y); 后面这个式子我是从网上找的。</p><h1 id="2tmin"><a class="markdownIt-Anchor" href="#2tmin">#</a> <strong>2.tmin</strong></h1><p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/2.66yb55z398w0.webp" alt=""><br>  题目大致意思就是返回 32 位二进制补码的最小整数。<br>  首先要知道位移符的作用，对于一个 n 位的操作数 x，x&lt;&lt;k 操作会生成一个值：x 向左移动 k 位，丢弃最高的 k 位，并在右端补 k 个 0。位移量应该是一个 0~n-1 之间的值。计算机中的数都是用补码进行表示的，并且最高位是符号位，应用的运算系统是模运算。</p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/3.6bnxv13upo0.webp" style="zoom:80%;" />&emsp;&emsp;我们可以以这个图位例，使用的是4位二进制数，一共有16个机器数，因为最高位是符号位，所以0111是最大的正数，1000是最小的负数，而在模运算系统中，一个负数的补码等于模减该负数的绝对值，所以1000就是该4位二进制补码的最小整数。因此，对于32位二进制补码来说，最小整数就是0x80000000，1左移31位就得到了答案。<h1 id="3istmax"><a class="markdownIt-Anchor" href="#3istmax">#</a> <strong>3.isTmax</strong></h1><p>  这个题目的大意是：输入的 x 如果是最大值就返回 1，否则返回 0。</p><p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/4.786lnmp907s0.webp" alt=""><br>  我们知道 32 位二进制数的最大值是 0x7FFFFFFF, 则 x+1 就是超出了 int 的这个范围，因此 x 与 x+1 进行比较，x 就是最大值，那么返回值就是应该是 1。所以我们需要做的就是通过逻辑运算让返回值为 1。x+1 是 0x80000000，取反的话就和原来的最大值相同，又因为两个相同的值进行异或得到的结果为 0，所以异或结果再非运算就能得到结果为 1，写成式子就是：!(x<sup>~(x+1))。但是这个式子依然不能涵盖所有结果，还有一种特殊情况，那就是 x=-1 的时候，即 x=0xFFFFFFFF，x+1=0x00000000，取反结果和 x 一样，因此按上述方法运算得到的结果也是 1，但实际上 x=-1 是最小值，输出应该为 0，所以我们应该排除 - 1 这种情况，因此使用与运算就是！(x</sup>~(x+1))&amp;!!(x+1), 在 x+1 前面加上两个非，这样就可以避免 - 1 这种特殊情况了。</p><h1 id="4all0ddbits"><a class="markdownIt-Anchor" href="#4all0ddbits">#</a> <strong>4.ALL0ddBits</strong></h1><p>  这道题的大致意思就是 x 的奇数位上如果都是 1，则返回 1，反之则返回 0。</p><p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/5.6mb6nnvd7vk0.webp" alt=""><br>  那么关键就是判定奇数位上是否都为 1，只要有一个不为 1，那么这个数字就不符合要求了，那么判断它是不是 1，只需要和 1 进行与运算就行了，为 1 则得出 1，为 0 则得出 0，因此 0xAAAAAAAA 恰好符合条件，拿 0xAAAAAAAA 和 x 进行与运算，如果 x 符合条件，那么输出的结果依然是 0xAAAAAAAA，然后让结果继续和 0xAAAAAAAA 进行异或运算，一个值与它自身异或得到的结果为 0，最后！0 即为 1，如果 x 不符合条件，那么最后输出的结果就是 0。最后得到的式子就是：return !((0xAAAAAAAA &amp; x) ^ 0xAAAAAAAA);</p><h1 id="5negate"><a class="markdownIt-Anchor" href="#5negate">#</a> <strong>5.negate</strong></h1><p>  这道题的大致意思就是返回一个值的负数，这绝对是最简单的题，那就短话短说。</p><p><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/6.34rl6www7u60.webp" alt=""><br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/7.2c9aqnxv2gsg.webp" style="zoom:80%;" /></p><p>  还得是看这张表，数值取反后加 1 就是对应的负数了。  最后得到的式子为：return ~x + 1 ;</p><h1 id="6isasciidigit"><a class="markdownIt-Anchor" href="#6isasciidigit">#</a> <strong>6.isAsciiDigit</strong></h1><p>  这道题也是挺简单的，题目大致意思是输入的 x 如果大于 0x30 且小于 0x39，则输出 1，反之输出 0，并且有提示这个范围就是‘0’到‘9’的 ASCII 码值。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/8.1w1stnrmxdk0.webp" alt=""><br>  因为计算机在比较大小的时候，是做减法，两数相减，然后判断结果是否为正数，因此我们可以将 x 与范围边界进行减法，而减法又可以转换为加法，所以就是 x + (~48 + 1) 和 (~x + 1) + 57，48 和 57 是‘0’和‘9’对应的 ASCII 值，又因为计算机中的数由补码表示，正数的符号位为 0，负数的符号位为 1，故我们可以将前面两个算式得到的结果进行移位，假设 x 在范围里面，那么那两个算式的结果移位之后都应该为 0，两个结果都加上 1，然后进行与运算，就能得到返回值为 1，如果 x 不在范围内，返回值就是 0。<br>  最后得到的返回式子为 return (((x + (~48 + 1))&gt;&gt;31)+1) &amp; ((((~x + 1) + 57)&gt;&gt;31)+1);</p><h1 id="7conditional"><a class="markdownIt-Anchor" href="#7conditional">#</a> <strong>7.conditional</strong></h1><p>  这道题的大致意思就是用逻辑运算和取反、位移等实现 x ? y : z。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/9.1kg7qeqcoetc.webp" alt=""><br>  x ? y : z 的原理就是:<br>   （1）判断 x 的真假；<br>   （2）如果 x 为真，那么就输出 y；<br>   （3）如果 x 为假，那么输出 z。<br>  那么这道题也就很好理解了，思路首先就是判断 x 的真假，然后选择输出 y 还是 z。判断 x 真假很好办，两次 “非” 运算就能得出真假。之后，将上一步结果取反加 1，也就是换算成结果的负数，如果结果为 1（真），那么转换成 - 1，再与 y 进行与运算，就可以保留 y。然后就是 z，z 与第一步结果的取反进行与运算，如果第一步结果为 1，那么取反之后就是 0，这样就可以消掉 z。最后总结，x 为真：保留 y、消掉 z；x 为假：消掉 y，保留 z。   根据上述描述得到的式子：return ((~A + 1) &amp; y) + (<sub>(</sub>A + 1) &amp; z);</p><h1 id="8islessorequal"><a class="markdownIt-Anchor" href="#8islessorequal">#</a> <strong>8.isLessOrEqual</strong></h1><p>  这道题的大致意思就是使用基本运算实现 “x&lt;=y”，还是有一定难度的。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/10.db1kj4asbuw.webp" alt=""><br>  计算机在比较两个数的大小的时候会先进行减法运算，然后判断正负，所以我们可以按照这个思路来解题，但是用减法的话需要考虑溢出，所以首先判断两个数的符号，c1 是 x+，y-，c2 是 x-,y+。因为我们是用 y 减 x，所以当 c1 为真且 d 为假的时候就发生了溢出，这时候计算得到的结果就与实际情况相反，所以要避免。在 c2 成立的时候，因为是负数和正数进行比较，所以整个运算就直接成立。  最后得到的返回运算式就是 return (!d &amp; !c1) | c2;</p><h1 id="9logicalneg"><a class="markdownIt-Anchor" href="#9logicalneg">#</a> <strong>9.logicalNeg</strong></h1><p>  这道题的大致意思就是实现非运算（!），还是很有难度的。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/11.v6b4eso67ts.webp" alt=""><br>  非运算就是非 0 为 1，非 1 为 0，除了 0 这种特殊情况，其它数取反加 1 都是原来的数的相反数，相反数与原来的数进行位或运算得到的结果符号位都为 1，然后再进行位移 31 位再加 1，得到的结果就是 0。对于 0 来说，取反加 1 再位或得到的结果仍然为 0，右移 31 位再加 1 就是 1。</p><h1 id="10howmanybits"><a class="markdownIt-Anchor" href="#10howmanybits">#</a> <strong>10.howManyBits</strong></h1><p>  这道题的大致意思就是一个数的补码最少可以用多少位来表示。比如 12，二进制形式 0x1100，再加上一位符号位，就是 5 位，再看 0，用二进制表示就是 0x0，只有一位，-1 用二进制表示，是 1，也只有一位。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/12.59q9mec5pt80.webp" alt=""><br>  这道题我自己做是没有任何思路，看着别人的 wp 我才能搞懂。  大致分为 3 种情况：0、-1 和其它数。  0 只用一个符号位就能够表示，-1 和 0 一样，-1 的二进制补码是全 1，取反之后就是 0，所以也能用一个符号位表示。  我们主要考虑一般的数，一般的数取反之后和取反之前都可以用相同的符号位进行表示。  对于传输进去的负数，进行取反，正数就不用管。  然后是判断高 16 位有没有 1，接着判断 8 位，然后是 4 位、2 位、1 位。</p><h1 id="11floatscale2"><a class="markdownIt-Anchor" href="#11floatscale2">#</a> <strong>11.floatScale2</strong></h1><p>  这道题是求浮点数乘以 2。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/13.1xmf11aubrcw.webp" alt=""><br>  对于一般的浮点数乘以二来说，是阶码加一，因为不同类型的数相乘是转化成同一种类型的，浮点数相乘是尾数相乘除、阶码相加减，2 的阶码是 1，尾数为 0。<br>  因此我们只需要考虑特殊情况就可以了：<br>  （1）0 乘以 2<br>  （2）无穷大或 NaN（非数）乘以 2；<br>  （3) 非规格化数乘以 2；<br>  我们看上述的代码，首先提取出阶码部分和尾数部分，然后再判断 uf 是否为 0 或无穷大或 NaN 或非规格化数，如果 uf 为无穷大或 NaN 就直接返回，乘以二之后依旧是原数。为 0 和非规格化数时，尾数只需左移一位，0 左移还是 0，非规格化数左移一位后阶码加 1，变成了规格化数。</p><h1 id="12floatfloat2int"><a class="markdownIt-Anchor" href="#12floatfloat2int">#</a> <strong>12.floatFloat2Int</strong></h1><p>  这道题是将浮点数转化成整形。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/14.1yt1vvu91fgg.webp" alt=""><br>  将浮点型转化为整形，会舍去小数，但是浮点型所表示的范围要比整形所表示的范围大，所以某些浮点型的值超过了整形所能表示的范围，根据题目要求，就需要返回 0x80000000 了，并且当浮点型小于 1 时，转化成整形就是 0。和上一道题目类似，首先提取出阶码和尾数，并且还要判断 uf 的符号位。如果阶码超过整形所能返回的最大值，则返回题目所要求的数值，如果阶码小于 127，也就是 uf 小于 1，则返回 0。如果是一般范围内的浮点数，则去掉小数转换成整形。</p><h1 id="13floatpower2"><a class="markdownIt-Anchor" href="#13floatpower2">#</a> <strong>13.floatPower2</strong></h1><p>  这道题是求 2 的 x 次方，并以浮点数的形式输出。<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/15.62dhb4518yg0.webp" alt=""><br>  这个很好理解，阶码的范围就是 - 126~127，小于 - 126 返回 0，大于 127 返回无穷大，如果是正确范围内的，则返回 x 加上偏移量后再左移 23 位，得到这个以浮点数形式输出的 2 的 x 次方。</p><p>最后附上测试表：<br><img src="https://cdn.jsdelivr.net/gh/xmzbk/blog-img@main/16.hikvbikrfzs.webp" alt=""><br>  我的 csapp 实验一的旅程到此就结束了，我最深的感触就是这门学科真的很有难度，但是也带给我很大的精神愉悦，特别是在做实验的时候，每做出一道题并且通过测试之后，我真的很开心，比我打一把游戏胜利之后都要开心，因为我确实是看到了自己的进步。但是它也使我认识到了和别人的差距，不努力是真的不行，和别人的差距只会越来越大。并且，这次实验我的理解还不够深，特别是最后四道题，我看着别人写的 wp 一步一步来的，学的不精是我的问题，以后更是不能放弃，学得更多之后，还要回过头来再把这个实验刷几遍，必须学得透彻之后我才能走的更远。<br>  以后会持续更新 csapp 的，还有更多的实验等着我呢！</p>]]></content>
      
      
      <categories>
          
          <category> csapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> csapp datelab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编基础-菜鸟的入门之路</title>
      <link href="/2022/02/23/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80-%E8%8F%9C%E9%B8%9F%E7%9A%84%E5%85%A5%E9%97%A8%E4%B9%8B%E8%B7%AF/"/>
      <url>/2022/02/23/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80-%E8%8F%9C%E9%B8%9F%E7%9A%84%E5%85%A5%E9%97%A8%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>​初学汇编，本篇文章的内容主要包含一些基础的汇编知识以及个人的见解，难免会有出错的地方，望各位师傅多多包涵。</p><h2 id="一-进制和进制运算"><a class="markdownIt-Anchor" href="#一-进制和进制运算">#</a> 一、进制和进制运算</h2><p>​1. 每一种进制都是完美的，想要学好进制首先要忘掉十进制，也要忘掉进制之间的转化。<br>​2. 进制的定义：<br>​（1）八进制：由八个符号组成，分别是 01234567，逢八进一。<br>​（2）十进制：由十个符号组成，分别是 0123456789，逢十进一。<br>​（3）N 进制：由 N 个符号组成，逢 N 进一。<br>​3. 进制的运算<br>​进制的运算的本质就是查数。<br>​十进制运算用十进制运算表，那八进制就用八进制的运算表。<br>​每一种进制自身都是一个完整的体系，可以直接做各种运算。</p><h2 id="二-二进制简写形式"><a class="markdownIt-Anchor" href="#二-二进制简写形式">#</a> 二、二进制简写形式</h2><p>​1. 计算机为什么要使用二进制<br>​（1）计算机是需要用电的，电路只有两种状态：<br>​                               1      真（通电）<br>​                               0      假（未通电）<br>​          计算机中存储的任何文件，接收的任何指令，都是由 0 和 1 组成的。<br>​（2）16 进制在计算机中可以看成二进制的简写形式</p><p>​二进制         十六进制                   二进制                  十六进制</p><p>​0000             0                             1001                        9</p><p>​0001             1                             1010                        A</p><p>​0010             2                             1011                        B</p><p>​0011             3                              1100                       C</p><p>​0100             4                              1101                       D</p><p>​0101             5                              1110                       E</p><p>​0110             6                               1111                       F</p><p>​0111              7</p><p>​1000             8<br>​这些转换是需要记住的，对以后的学习会有很大的帮助</p><h2 id="三-数据宽度"><a class="markdownIt-Anchor" href="#三-数据宽度">#</a> 三、数据宽度</h2><p>​数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的限制，数据都是有长度限制的，我们称之为数据宽度，超过最多宽度的数据会被丢掉。</p><p>​在计算机中常见的数据宽度：<br>​首先就是位（bit），然后是字节（byte），1 字节 = 8 位，再者就是字（word），1 字 = 16 位，双字（Doubleword）=32 位。</p><p>​存储范围<br>​在计算机中，每个位能存一个 0 或 1，另外，在二进制中四位 1 等于十六进制中的一个 F，那么我们就能根据这些能够知道每个宽度所能存储的范围，<br>​字节：0~0xFF<br>​字：0~0xFFFF<br>​双字：0~0xFFFFFFFF</p><h2 id="四-有符号数和无符号数"><a class="markdownIt-Anchor" href="#四-有符号数和无符号数">#</a> 四、有符号数和无符号数</h2><p>​在计算机中，所有东西都是用二进制的 0 和 1 来进行存储的，比如说一个逗号、一个程序、一个有符号数，一个无符号数等等，都是用 0 和 1 进行存储的。所以在进行编码的时候，会按照相应的编码规则进行编码，有符号数按有符号数的编码规则，无符号数按无符号数的编码规则，所以说给你一串数字：1 0 0 1 1 1 0 1 0，告诉你他是个文本，那么他可能就代表 0 一个逗号。不谈这个文本，如果它是一个无符号数，我们就需要按照无符号数的编码规则去进行编码，既然是无符号，顾名思义，可以直接转换成十六进制数，或者是十进制数，转换成 16 进制就是 0x9A   十进制就是 154。<br>​但如果是有符号数的话，因为是有正数和负数之分的，所以编码规则相对不同，即正数和负数的编码不同。<br>​有符号数，拿上面的一串数字来说：0 0 0 1 1 0 1 0，最高位是 1，这个数就是负数，最高数是 0，这个数就是正数，那么很显然这个是正数。至于有、无符号数是怎么进行编码的，就需要了解到原码、补码和反码了。</p><h2 id="五-原码-补码和反码"><a class="markdownIt-Anchor" href="#五-原码-补码和反码">#</a> 五、原码、补码和反码</h2><p>​1. 编码规则<br>​首先在计算机中，靠二进制数 0 和 1 存储信息，例如 0 1 0 1 0 1 0 1，不同的文件有着不同的编码规则，也就是说这些 0 和 1 按照编码规则，解析成文本，视频，音乐等等。</p><p>​2. 原码、反码和补码<br>​原码：最高位为符号位，其余各位为数值本身的绝对值</p><p>​反码：<br>​正数：反码与原码相同<br>​负数：符号位为 1，其余位对原码取反</p><p>​补码：<br>​正数：补码与原码相同<br>​负数：符号位为 1，其余位对原码取反加 1</p><p>​了解到原码、反码和补码之后，我们也就能够轻松地理解有、无符号数是怎样进行编码的了。</p><h2 id="六-计算机做的运算"><a class="markdownIt-Anchor" href="#六-计算机做的运算">#</a> 六、计算机做的运算</h2><p>​1. 与运算（and&amp;）<br>​       两个位都为 1 时，结果才为 1</p><p>​2. 或运算（or|）<br>​      只要有一个为 1 就是 1</p><p>​3. 异或运算（xor^）<br>不一样的时候是 1</p><p>​4. 非运算（not~）<br>​      0 就是 1    1 就是 0</p><p>​5. 移位运算<br>​左移（shl &lt;&lt;）<br>​各二进位全部左移若干位，高位丢弃，低位补 0<br>​eg：1101 1000    左移 2 位为：0110 0000</p><p>​右移（shr    sar    &gt;&gt;）<br>​各二进位全部右移若干位，低位丢弃，高位补 0 或者补符号位<br>​注：右移是分两种情况的，就是高位补 0 和补符号位</p><p>​shr   1101 0101        右移    0011 0101<br>​对应 C 语言（&gt;&gt;）<br>​unsigned int a= 10；<br>​printf(&quot;%d\n&quot;,a&gt;&gt;2);</p><p>​sar   1101 0101        右移    1111 0101<br>​对应 C 语言（&gt;&gt;）<br>​int a=10;<br>​printf(&quot;%d\n&quot;,a&gt;&gt;2):</p><p>​C 语言中，有符号的右移是补符号位，无符号位的右移是补 0。上述字母代表的是汇编中对应的指令，符号代表的是 C 语言中对应的指令。所以说计算机做的所有运算归根到底都是位运算。</p><h2 id="七-位运算加减乘除用位运算来实现四则运算"><a class="markdownIt-Anchor" href="#七-位运算加减乘除用位运算来实现四则运算">#</a> 七、位运算加减乘除（用位运算来实现四则运算）</h2><p>​不考虑进位的情况下，异或的结果和加结果一样。所以计算机在进行加法的时候的大致过程是这样的：<br>​举个例子：4+5=？<br>​（1）首先，两个二进制数进行异或<br>​0000  0100<br>​0000  0101   异或<br>​————————<br>​0000  0001<br>​（2）其次，两个数进行与运算<br>​0000  0100<br>​0000  0101   与<br>​————————<br>​0000  0100<br>​（3）因为与运算是计算机能够判断在进行加法时是否发生了进位的运算，所如果发生了进位，那么就会再次进行异或运算，如果没有进位，第一次进行的异或运算的结果就是真实的结果，以下是发生了进位之后的异或运算<br>​0000 0001                 —&gt; 第一次异或的结果<br>​0000 1000   异或        —&gt; 上次与运算的结果左移一位之后<br>​————————<br>​0000  1001<br>​（4）再次进行与运算，判断上次异或是否发生进位，没有进位，直接出结果，进位了，继续进行异或运算<br>​0000  0001<br>​0000  1000     与<br>​————————<br>​0000  0000</p><p>​注：（1）与运算结果有 1 的地方就是发生了进位，如果没有发生进位，那么结果就应该全部为 0<br>​      （2）第二次异或之所以要加左移一位的结果是因为与运算结果为 1 的地方本应该是要进一位的</p><p>​其他运算的运算过程<br>​4-5=4+（-5）<br>​减法就是加法，所以运算的过程和加法基本是一致的，<br>​至于乘法，乘法就是加法，x*y 的本质就是 x 个 y 相加，<br>​除法的本质就是减法，X/Y 其实就是 X 能减去多少个 Y，<br>​归根结底，四则运算就是加法的运算，用计算机的位运算进行运算，本质都是一样的。<br>​所以说计算机可以通过位运算来进行最基本的四则运算，那么也就可以以此进行一些更复杂的运算。</p><h2 id="八-汇编环境搭建"><a class="markdownIt-Anchor" href="#八-汇编环境搭建">#</a> 八、汇编环境搭建</h2><p>​汇编环境搭建<br>​1. 学汇编不是为了写代码<br>​学汇编对学习应用开发和安全相关方面都有帮助<br>​2. 环境配置<br>​下载 DTDebug，在滴水官网下载，下载完成之后进行简单配置，在 options—&gt;Appearance—&gt;Directories 中，将 UDD 和 Plugin 的路径指向对应名称的目录中。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 菜鸟入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈博客搭建</title>
      <link href="/2022/02/18/%E6%B5%85%E8%B0%88%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/02/18/%E6%B5%85%E8%B0%88%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>第一次接触博客，不知道说啥，好紧张。<br>年前花了几天时间在网上找课程，搭建最基础的博客，然后就是漫长的主题美化，中间一直耽搁着，直到今天才顺利的把主题美化好，各种该有的全部添了上去，不该有的也弄了个七七八八。<br>我用的是 butterfly 主题，当时满世界的找主题，唯有这款主题深深的吸引了我，但是这个主题对于新手十分的不友好，我差点就删档重新来过，好在经历了各种错误之后，还是将美化给做完了。<br>还有就是我要开始写博客了，学习怎样写博客，也不失为一种乐趣，这也是最最基本的事情了。就目前看来，Sublime Text 确实用的不是很习惯。<br>不说了，我要去下载 Typora 了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 浅谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
